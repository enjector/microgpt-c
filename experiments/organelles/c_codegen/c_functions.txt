/* bisection root finder */
double bisect(double (*f)(double), double a, double b, double tol) {
  double c;
  for (int i = 0; i < 100; i++) {
    c = (a + b) * 0.5;
    if (f(c) * f(a) < 0) b = c; else a = c;
    if (b - a < tol) break;
  }
  return c;
}

/* Newton-Raphson root finder */
double newton(double (*f)(double), double (*df)(double), double x, double tol) {
  for (int i = 0; i < 50; i++) {
    double fx = f(x), dfx = df(x);
    if (fabs(dfx) < 1e-15) break;
    double dx = fx / dfx;
    x -= dx;
    if (fabs(dx) < tol) break;
  }
  return x;
}

/* secant method root finder */
double secant(double (*f)(double), double x0, double x1, double tol) {
  double f0 = f(x0), f1 = f(x1);
  for (int i = 0; i < 50; i++) {
    if (fabs(f1 - f0) < 1e-15) break;
    double x2 = x1 - f1 * (x1 - x0) / (f1 - f0);
    x0 = x1; f0 = f1;
    x1 = x2; f1 = f(x2);
    if (fabs(x1 - x0) < tol) break;
  }
  return x1;
}

/* trapezoidal integration */
double trapez(double (*f)(double), double a, double b, int n) {
  double h = (b - a) / n, s = 0.5 * (f(a) + f(b));
  for (int i = 1; i < n; i++) s += f(a + i * h);
  return s * h;
}

/* Simpson's rule integration */
double simpson(double (*f)(double), double a, double b, int n) {
  if (n % 2 != 0) n++;
  double h = (b - a) / n, s = f(a) + f(b);
  for (int i = 1; i < n; i++) s += (i % 2 == 0 ? 2.0 : 4.0) * f(a + i * h);
  return s * h / 3.0;
}

/* Romberg integration */
double romberg(double (*f)(double), double a, double b, int n) {
  double h = b - a;
  double R[16][16];
  R[0][0] = 0.5 * h * (f(a) + f(b));
  for (int i = 1; i < n; i++) {
    h *= 0.5;
    double s = 0;
    for (int k = 1; k <= (1 << (i - 1)); k++) s += f(a + (2 * k - 1) * h);
    R[i][0] = 0.5 * R[i - 1][0] + h * s;
    for (int j = 1; j <= i; j++) {
      double p = pow(4.0, j);
      R[i][j] = (p * R[i][j - 1] - R[i - 1][j - 1]) / (p - 1.0);
    }
  }
  return R[n - 1][n - 1];
}

/* Monte Carlo integration */
double integrate_mc(double (*f)(double), double a, double b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double x = a + (b - a) * ((double)rand() / RAND_MAX);
    s += f(x);
  }
  return (b - a) * s / n;
}

/* linear interpolation */
double lerp(double a, double b, double t) {
  return a + t * (b - a);
}

/* bilinear interpolation */
double bilinear(double f00, double f10, double f01, double f11, double u, double v) {
  return f00 * (1 - u) * (1 - v) + f10 * u * (1 - v) + f01 * (1 - u) * v + f11 * u * v;
}

/* clamp value to range */
double clamp(double x, double lo, double hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

/* dot product of two vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* vector addition */
void vec_add(double *r, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] + b[i];
}

/* vector scaling */
void vec_scale(double *r, const double *a, double s, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] * s;
}

/* vector Euclidean norm */
double vec_norm(const double *v, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += v[i] * v[i];
  return sqrt(s);
}

/* normalize a vector to unit length */
void vec_normalize(double *v, int n) {
  double len = vec_norm(v, n);
  if (len > 1e-15) for (int i = 0; i < n; i++) v[i] /= len;
}

/* matrix-vector multiply */
void mat_vec(double *y, const double *A, const double *x, int m, int n) {
  for (int i = 0; i < m; i++) {
    double s = 0;
    for (int j = 0; j < n; j++) s += A[i * n + j] * x[j];
    y[i] = s;
  }
}

/* matrix multiplication */
void mat_mul(double *C, const double *A, const double *B, int m, int n, int p) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < p; j++) {
      double s = 0;
      for (int k = 0; k < n; k++) s += A[i * n + k] * B[k * p + j];
      C[i * p + j] = s;
    }
}

/* matrix transpose */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* matrix trace */
double mat_trace(const double *A, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += A[i * n + i];
  return s;
}

/* identity matrix */
void mat_identity(double *A, int n) {
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) A[i * n + j] = (i == j) ? 1.0 : 0.0;
}

/* matrix addition */
void mat_add(double *C, const double *A, const double *B, int m, int n) {
  for (int i = 0; i < m * n; i++) C[i] = A[i] + B[i];
}

/* matrix scaling */
void mat_scale(double *B, const double *A, double s, int m, int n) {
  for (int i = 0; i < m * n; i++) B[i] = A[i] * s;
}

/* outer product of two vectors */
void outer_product(double *M, const double *a, const double *b, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) M[i * n + j] = a[i] * b[j];
}

/* Frobenius norm of a matrix */
double frobenius_norm(const double *A, int m, int n) {
  double s = 0;
  for (int i = 0; i < m * n; i++) s += A[i] * A[i];
  return sqrt(s);
}

/* Hadamard element-wise product */
void hadamard(double *c, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) c[i] = a[i] * b[i];
}

/* Gaussian elimination with partial pivoting */
int gauss_elim(double *A, double *b, int n) {
  for (int k = 0; k < n; k++) {
    int pivot = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[pivot * n + k])) pivot = i;
    if (fabs(A[pivot * n + k]) < 1e-12) return -1;
    for (int j = 0; j < n; j++) {
      double t = A[k * n + j]; A[k * n + j] = A[pivot * n + j]; A[pivot * n + j] = t;
    }
    double t = b[k]; b[k] = b[pivot]; b[pivot] = t;
    for (int i = k + 1; i < n; i++) {
      double f = A[i * n + k] / A[k * n + k];
      for (int j = k; j < n; j++) A[i * n + j] -= f * A[k * n + j];
      b[i] -= f * b[k];
    }
  }
  for (int i = n - 1; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) b[i] -= A[i * n + j] * b[j];
    b[i] /= A[i * n + i];
  }
  return 0;
}

/* LU decomposition with pivoting */
void lu_decompose(double *A, int *piv, int n) {
  for (int i = 0; i < n; i++) piv[i] = i;
  for (int k = 0; k < n; k++) {
    int mx = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[mx * n + k])) mx = i;
    int tp = piv[k]; piv[k] = piv[mx]; piv[mx] = tp;
    for (int j = 0; j < n; j++) { double t = A[k * n + j]; A[k * n + j] = A[mx * n + j]; A[mx * n + j] = t; }
    for (int i = k + 1; i < n; i++) {
      A[i * n + k] /= A[k * n + k];
      for (int j = k + 1; j < n; j++) A[i * n + j] -= A[i * n + k] * A[k * n + j];
    }
  }
}

/* Jacobi iterative solver */
void jacobi_iter(double *x, const double *A, const double *b, int n, int iters) {
  double xnew[64];
  for (int it = 0; it < iters; it++) {
    for (int i = 0; i < n; i++) {
      double s = b[i];
      for (int j = 0; j < n; j++) if (j != i) s -= A[i * n + j] * x[j];
      xnew[i] = s / A[i * n + i];
    }
    for (int i = 0; i < n; i++) x[i] = xnew[i];
  }
}

/* Householder reflection vector */
void householder(double *v, const double *x, int n) {
  double s = vec_norm(x, n);
  for (int i = 0; i < n; i++) v[i] = x[i];
  v[0] += (x[0] >= 0 ? 1.0 : -1.0) * s;
  double vn = vec_norm(v, n);
  if (vn > 1e-15) for (int i = 0; i < n; i++) v[i] /= vn;
}

/* polynomial evaluation using Horner's method */
double horner(const double *a, int n, double x) {
  double r = a[n];
  for (int i = n - 1; i >= 0; i--) r = r * x + a[i];
  return r;
}

/* polynomial evaluation */
double poly_eval(const double *c, int deg, double x) {
  double r = c[deg];
  for (int i = deg - 1; i >= 0; i--) r = r * x + c[i];
  return r;
}

/* polynomial derivative */
void poly_deriv(double *dc, const double *c, int deg) {
  for (int i = 1; i <= deg; i++) dc[i - 1] = c[i] * i;
}

/* Lagrange interpolation */
double lagrange(const double *xi, const double *yi, int n, double x) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double p = yi[i];
    for (int j = 0; j < n; j++)
      if (j != i) p *= (x - xi[j]) / (xi[i] - xi[j]);
    s += p;
  }
  return s;
}

/* Chebyshev nodes for interpolation */
void cheby_nodes(double *x, int n, double a, double b) {
  for (int i = 0; i < n; i++)
    x[i] = 0.5 * (a + b) + 0.5 * (b - a) * cos((2 * i + 1) * 3.14159265 / (2 * n));
}

/* Runge-Kutta 4th order ODE step */
void rk4_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  double k2 = h * f(*t + 0.5 * h, *y + 0.5 * k1);
  double k3 = h * f(*t + 0.5 * h, *y + 0.5 * k2);
  double k4 = h * f(*t + h, *y + k3);
  *y += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0;
  *t += h;
}

/* Euler method ODE step */
void euler_step(double (*f)(double, double), double *t, double *y, double h) {
  *y += h * f(*t, *y);
  *t += h;
}

/* midpoint method ODE step */
void midpoint_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  *y += h * f(*t + 0.5 * h, *y + 0.5 * k1);
  *t += h;
}

/* arithmetic mean */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* sample variance */
double variance(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - m) * (x[i] - m);
  return s / (n - 1);
}

/* standard deviation */
double stddev(const double *x, int n) {
  return sqrt(variance(x, n));
}

/* sample covariance */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* Pearson correlation coefficient */
double correlation(const double *x, const double *y, int n) {
  return covariance(x, y, n) / (stddev(x, n) * stddev(y, n));
}

/* linear regression slope and intercept */
void linreg(const double *x, const double *y, int n, double *slope, double *intercept) {
  double mx = mean(x, n), my = mean(y, n);
  double num = 0, den = 0;
  for (int i = 0; i < n; i++) {
    num += (x[i] - mx) * (y[i] - my);
    den += (x[i] - mx) * (x[i] - mx);
  }
  *slope = num / den;
  *intercept = my - *slope * mx;
}

/* sigmoid activation function */
double sigmoid(double x) {
  return 1.0 / (1.0 + exp(-x));
}

/* ReLU activation function */
double relu(double x) {
  return x > 0 ? x : 0;
}

/* softplus activation function */
double softplus(double x) {
  return log(1.0 + exp(x));
}

/* softmax normalization */
void softmax(double *p, const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  double s = 0;
  for (int i = 0; i < n; i++) { p[i] = exp(x[i] - m); s += p[i]; }
  for (int i = 0; i < n; i++) p[i] /= s;
}

/* cross entropy loss */
double cross_entropy(const double *p, int target, int n) {
  return -log(p[target] > 1e-15 ? p[target] : 1e-15);
}

/* logistic function with steepness */
double logistic(double x, double k, double x0) {
  return 1.0 / (1.0 + exp(-k * (x - x0)));
}

/* FFT radix-2 butterfly */
void fft_radix2(double *re, double *im, int n) {
  for (int i = 1, j = 0; i < n; i++) {
    int b = n >> 1;
    while (j & b) { j ^= b; b >>= 1; }
    j ^= b;
    if (i < j) {
      double t = re[i]; re[i] = re[j]; re[j] = t;
      t = im[i]; im[i] = im[j]; im[j] = t;
    }
  }
  for (int len = 2; len <= n; len <<= 1) {
    double ang = -6.283185307 / len;
    double wr = cos(ang), wi = sin(ang);
    for (int i = 0; i < n; i += len) {
      double cr = 1, ci = 0;
      for (int j = 0; j < len / 2; j++) {
        double ur = re[i + j], ui = im[i + j];
        double vr = re[i + j + len / 2] * cr - im[i + j + len / 2] * ci;
        double vi = re[i + j + len / 2] * ci + im[i + j + len / 2] * cr;
        re[i + j] = ur + vr; im[i + j] = ui + vi;
        re[i + j + len / 2] = ur - vr; im[i + j + len / 2] = ui - vi;
        double t = cr * wr - ci * wi; ci = cr * wi + ci * wr; cr = t;
      }
    }
  }
}

/* inverse FFT */
void ifft(double *re, double *im, int n) {
  for (int i = 0; i < n; i++) im[i] = -im[i];
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) { re[i] /= n; im[i] = -im[i] / n; }
}

/* FFT power spectrum */
void fft_power(double *power, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* FFT magnitude spectrum */
void fft_magnitude(double *mag, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) mag[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* FFT phase spectrum */
void fft_phase(double *phase, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) phase[i] = atan2(im[i], re[i]);
}

/* Hann window function */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* Hamming window function */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Blackman window function */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* apply window to signal */
void apply_window(double *out, const double *signal, const double *window, int n) {
  for (int i = 0; i < n; i++) out[i] = signal[i] * window[i];
}

/* FFT with Hann window */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Hamming window */
void fft_windowed_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Blackman window */
void fft_windowed_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* DFT brute force */
void dft_naive(double *re_out, double *im_out, const double *re_in, const double *im_in, int n) {
  for (int k = 0; k < n; k++) {
    re_out[k] = 0; im_out[k] = 0;
    for (int j = 0; j < n; j++) {
      double ang = -6.283185307 * k * j / n;
      re_out[k] += re_in[j] * cos(ang) - im_in[j] * sin(ang);
      im_out[k] += re_in[j] * sin(ang) + im_in[j] * cos(ang);
    }
  }
}

/* 1D convolution */
void conv1d(double *y, const double *x, int nx, const double *h, int nh) {
  int ny = nx + nh - 1;
  for (int i = 0; i < ny; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0 && i - j < nx) y[i] += x[i - j] * h[j];
  }
}

/* moving average filter */
void moving_avg(double *y, const double *x, int n, int w) {
  double s = 0;
  for (int i = 0; i < w && i < n; i++) s += x[i];
  for (int i = 0; i < n; i++) {
    if (i >= w) s -= x[i - w];
    if (i < w) y[i] = s / (i + 1);
    else y[i] = s / w;
  }
}

/* exponential moving average */
double ema(double prev, double cur, double alpha) {
  return alpha * cur + (1.0 - alpha) * prev;
}

/* 2x2 determinant */
double det2(double a, double b, double c, double d) {
  return a * d - b * c;
}

/* 3x3 determinant */
double det3(const double *m) {
  return m[0] * (m[4] * m[8] - m[5] * m[7])
       - m[1] * (m[3] * m[8] - m[5] * m[6])
       + m[2] * (m[3] * m[7] - m[4] * m[6]);
}

/* 3D cross product */
void cross3(double *r, const double *a, const double *b) {
  r[0] = a[1] * b[2] - a[2] * b[1];
  r[1] = a[2] * b[0] - a[0] * b[2];
  r[2] = a[0] * b[1] - a[1] * b[0];
}

/* 3D dot product */
double vec3_dot(const double *a, const double *b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/* 3D vector length */
double vec3_len(const double *v) {
  return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/* degrees to radians */
double deg2rad(double d) {
  return d * 3.14159265358979 / 180.0;
}

/* radians to degrees */
double rad2deg(double r) {
  return r * 180.0 / 3.14159265358979;
}

/* greatest common divisor */
int gcd(int a, int b) {
  while (b) { int t = b; b = a % b; a = t; }
  return a;
}

/* least common multiple */
int lcm(int a, int b) {
  return a / gcd(a, b) * b;
}

/* factorial */
long factorial(int n) {
  long r = 1;
  for (int i = 2; i <= n; i++) r *= i;
  return r;
}

/* binomial coefficient */
double binomial(int n, int k) {
  double r = 1;
  for (int i = 0; i < k; i++) r = r * (n - i) / (i + 1);
  return r;
}

/* primality test */
int is_prime(int n) {
  if (n < 2) return 0;
  if (n < 4) return 1;
  if (n % 2 == 0 || n % 3 == 0) return 0;
  for (int i = 5; i * i <= n; i += 6)
    if (n % i == 0 || n % (i + 2) == 0) return 0;
  return 1;
}

/* fast integer exponentiation */
double power(double base, int exp) {
  double r = 1.0;
  int e = exp < 0 ? -exp : exp;
  while (e > 0) {
    if (e & 1) r *= base;
    base *= base;
    e >>= 1;
  }
  return exp < 0 ? 1.0 / r : r;
}

/* nth root via Newton's method */
double nth_root(double x, int n) {
  if (x == 0) return 0;
  double r = x;
  for (int i = 0; i < 100; i++) {
    double rn = power(r, n - 1);
    if (fabs(rn) < 1e-15) break;
    r = r - (power(r, n) - x) / (n * rn);
  }
  return r;
}

/* Gaussian probability density */
double gauss_pdf(double x, double mu, double sigma) {
  double z = (x - mu) / sigma;
  return exp(-0.5 * z * z) / (sigma * 2.506628274631);
}

/* error function approximation */
double erf_approx(double x) {
  double t = 1.0 / (1.0 + 0.3275911 * fabs(x));
  double p = t * (0.254829592 + t * (-0.284496736 + t * (1.421413741 + t * (-1.453152027 + t * 1.061405429))));
  double r = 1.0 - p * exp(-x * x);
  return x < 0 ? -r : r;
}

/* Box-Muller normal random */
void box_muller(double *z0, double *z1) {
  double u1 = (double)rand() / RAND_MAX;
  double u2 = (double)rand() / RAND_MAX;
  if (u1 < 1e-10) u1 = 1e-10;
  *z0 = sqrt(-2.0 * log(u1)) * cos(6.283185307 * u2);
  *z1 = sqrt(-2.0 * log(u1)) * sin(6.283185307 * u2);
}

/* Chebyshev polynomial of first kind */
double chebyshev_t(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double t0 = 1.0, t1 = x, t2;
  for (int i = 2; i <= n; i++) {
    t2 = 2.0 * x * t1 - t0;
    t0 = t1; t1 = t2;
  }
  return t1;
}

/* Legendre polynomial */
double legendre(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double p0 = 1.0, p1 = x, p2;
  for (int i = 2; i <= n; i++) {
    p2 = ((2 * i - 1) * x * p1 - (i - 1) * p0) / i;
    p0 = p1; p1 = p2;
  }
  return p1;
}

/* Bessel function J0 */
double bessel_j0(double x) {
  double s = 1.0, t = 1.0;
  for (int k = 1; k < 20; k++) {
    t *= -x * x / (4.0 * k * k);
    s += t;
  }
  return s;
}

/* sinc function */
double sinc(double x) {
  if (fabs(x) < 1e-10) return 1.0;
  return sin(x) / x;
}

/* bubble sort ascending */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* insertion sort ascending */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* binary search in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* median value */
double median(double *a, int n) {
  bubble_sort(a, n);
  if (n % 2 == 0) return (a[n / 2 - 1] + a[n / 2]) * 0.5;
  return a[n / 2];
}

/* cumulative sum */
void cumsum(double *y, const double *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* prefix sum for integers */
void prefix_sum(int *y, const int *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* maximum value in array */
double max_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  return m;
}

/* minimum value in array */
double min_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] < m) m = x[i];
  return m;
}

/* argmax index */
int argmax(const double *x, int n) {
  int k = 0;
  for (int i = 1; i < n; i++) if (x[i] > x[k]) k = i;
  return k;
}

/* L1 norm */
double l1_norm(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(x[i]);
  return s;
}

/* L-infinity norm */
double linf_norm(const double *x, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) if (fabs(x[i]) > m) m = fabs(x[i]);
  return m;
}

/* Euclidean distance */
double dist_euclidean(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += (a[i] - b[i]) * (a[i] - b[i]);
  return sqrt(s);
}

/* Manhattan distance */
double dist_manhattan(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(a[i] - b[i]);
  return s;
}

/* central finite difference */
void diff_central(double *dy, const double *y, double h, int n) {
  dy[0] = (y[1] - y[0]) / h;
  for (int i = 1; i < n - 1; i++) dy[i] = (y[i + 1] - y[i - 1]) / (2.0 * h);
  dy[n - 1] = (y[n - 1] - y[n - 2]) / h;
}

/* golden section minimization */
double golden_section(double (*f)(double), double a, double b, double tol) {
  double gr = 0.6180339887;
  double c = b - gr * (b - a), d = a + gr * (b - a);
  while (fabs(b - a) > tol) {
    if (f(c) < f(d)) { b = d; d = c; c = b - gr * (b - a); }
    else { a = c; c = d; d = a + gr * (b - a); }
  }
  return (a + b) * 0.5;
}

/* gradient descent optimizer */
void gradient_descent(double *x, double (*grad)(double), double lr, int steps) {
  for (int i = 0; i < steps; i++) *x -= lr * grad(*x);
}

/* exponential decay */
double exponential_decay(double x0, double lam, double t) {
  return x0 * exp(-lam * t);
}

/* harmonic series sum */
double harmonic(int n) {
  double s = 0;
  for (int i = 1; i <= n; i++) s += 1.0 / i;
  return s;
}

/* Stirling approximation to gamma */
double gamma_stirling(double x) {
  return sqrt(6.283185307 / x) * pow(x / 2.718281828, x);
}

/* beta function */
double beta_func(double a, double b) {
  return gamma_stirling(a) * gamma_stirling(b) / gamma_stirling(a + b);
}

/* swap two doubles */
void swap(double *a, double *b) {
  double t = *a; *a = *b; *b = t;
}

/* sign function */
double sign(double x) {
  return x > 0 ? 1.0 : (x < 0 ? -1.0 : 0.0);
}

/* step function */
double step_func(double x) {
  return x >= 0 ? 1.0 : 0.0;
}

/* ramp function */
double ramp(double x) {
  return x > 0 ? x : 0;
}

/* tanh approximation */
double tanh_approx(double x) {
  if (x > 3.0) return 1.0;
  if (x < -3.0) return -1.0;
  double x2 = x * x;
  return x * (1.0 + x2 * (1.0 / 3.0 + x2 / 15.0));
}

/* generate sine wave */
void gen_sine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr);
}

/* generate cosine wave */
void gen_cosine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = cos(6.283185307 * freq * i / sr);
}

/* generate square wave */
void gen_square(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr) >= 0 ? 1.0 : -1.0;
}

/* generate sawtooth wave */
void gen_sawtooth(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) {
    double phase = fmod(freq * i / sr, 1.0);
    out[i] = 2.0 * phase - 1.0;
  }
}

/* add white noise to signal */
void add_noise(double *signal, int n, double amplitude) {
  for (int i = 0; i < n; i++) signal[i] += amplitude * (2.0 * rand() / RAND_MAX - 1.0);
}

/* low pass filter first order IIR */
void lowpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* high pass filter first order IIR */
void highpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * (y[i - 1] + x[i] - x[i - 1]);
}

/* signal energy */
double signal_energy(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i] * x[i];
  return s;
}

/* signal RMS */
double signal_rms(const double *x, int n) {
  return sqrt(signal_energy(x, n) / n);
}

/* zero crossing rate */
int zero_crossings(const double *x, int n) {
  int count = 0;
  for (int i = 1; i < n; i++)
    if ((x[i] >= 0 && x[i - 1] < 0) || (x[i] < 0 && x[i - 1] >= 0)) count++;
  return count;
}

/* autocorrelation at lag k */
double autocorrelation(const double *x, int n, int k) {
  double m = mean(x, n), s = 0, v = 0;
  for (int i = 0; i < n; i++) v += (x[i] - m) * (x[i] - m);
  for (int i = 0; i < n - k; i++) s += (x[i] - m) * (x[i + k] - m);
  return s / v;
}

/* peak detection in signal */
int find_peaks(int *peaks, const double *x, int n, double threshold) {
  int count = 0;
  for (int i = 1; i < n - 1; i++)
    if (x[i] > x[i - 1] && x[i] > x[i + 1] && x[i] > threshold)
      peaks[count++] = i;
  return count;
}

/* normalize signal to range -1 to 1 */
void normalize_signal(double *x, int n) {
  double mx = fabs(x[0]);
  for (int i = 1; i < n; i++) if (fabs(x[i]) > mx) mx = fabs(x[i]);
  if (mx > 1e-15) for (int i = 0; i < n; i++) x[i] /= mx;
}

/* windowed FFT power spectrum */
void fft_windowed_power(double *power, const double *signal, int n) {
  double re[1024], im[1024], w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* spectral centroid of FFT */
double spectral_centroid(const double *mag, int n, double sr) {
  double num = 0, den = 0;
  for (int i = 0; i < n / 2; i++) {
    double freq = i * sr / n;
    num += freq * mag[i];
    den += mag[i];
  }
  return den > 1e-15 ? num / den : 0;
}

/* complex multiply */
void complex_mul(double *re, double *im, double ar, double ai, double br, double bi) {
  *re = ar * br - ai * bi;
  *im = ar * bi + ai * br;
}

/* signal downsample by factor */
void downsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n / factor; i++) out[i] = in[i * factor];
}

/* signal upsample by factor with zero insertion */
void upsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n * factor; i++) out[i] = 0;
  for (int i = 0; i < n; i++) out[i * factor] = in[i];
}

/* weighted mean */
double weighted_mean(const double *x, const double *w, int n) {
  double sw = 0, sx = 0;
  for (int i = 0; i < n; i++) { sx += x[i] * w[i]; sw += w[i]; }
  return sx / sw;
}

/* geometric mean */
double geometric_mean(const double *x, int n) {
  double lp = 0;
  for (int i = 0; i < n; i++) lp += log(x[i]);
  return exp(lp / n);
}

/* harmonic mean */
double harmonic_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += 1.0 / x[i];
  return n / s;
}

/* trimmed mean */
double trimmed_mean(double *x, int n, int trim) {
  bubble_sort(x, n);
  double s = 0;
  for (int i = trim; i < n - trim; i++) s += x[i];
  return s / (n - 2 * trim);
}

/* sample skewness */
double skewness(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s3 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s3 += d * d * d;
  }
  s2 /= n; s3 /= n;
  return s3 / pow(s2, 1.5);
}

/* sample kurtosis */
double kurtosis(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s4 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s4 += d * d * d * d;
  }
  s2 /= n; s4 /= n;
  return s4 / (s2 * s2) - 3.0;
}

/* percentile using linear interpolation */
double percentile(double *x, int n, double p) {
  bubble_sort(x, n);
  double rank = p * (n - 1) / 100.0;
  int lo = (int)rank;
  double frac = rank - lo;
  if (lo >= n - 1) return x[n - 1];
  return x[lo] + frac * (x[lo + 1] - x[lo]);
}

/* interquartile range */
double iqr(double *x, int n) {
  return percentile(x, n, 75.0) - percentile(x, n, 25.0);
}

/* z-score normalization */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* min-max normalization to 0-1 */
void minmax_normalize(double *out, const double *x, int n) {
  double mn = min_val(x, n), mx = max_val(x, n);
  double range = mx - mn;
  if (range < 1e-15) range = 1.0;
  for (int i = 0; i < n; i++) out[i] = (x[i] - mn) / range;
}

/* Welford online variance */
void welford_update(double *mean_out, double *var_out, double x, int n) {
  double delta = x - *mean_out;
  *mean_out += delta / n;
  double delta2 = x - *mean_out;
  *var_out += delta * delta2;
}

/* running mean */
void running_mean(double *out, const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { s += x[i]; out[i] = s / (i + 1); }
}

/* running standard deviation */
void running_stddev(double *out, const double *x, int n) {
  double m = 0, m2 = 0;
  for (int i = 0; i < n; i++) {
    double delta = x[i] - m;
    m += delta / (i + 1);
    m2 += delta * (x[i] - m);
    out[i] = (i > 0) ? sqrt(m2 / i) : 0;
  }
}

/* histogram with uniform bins */
void histogram(int *counts, const double *x, int n, double lo, double hi, int nbins) {
  double bw = (hi - lo) / nbins;
  for (int i = 0; i < nbins; i++) counts[i] = 0;
  for (int i = 0; i < n; i++) {
    int b = (int)((x[i] - lo) / bw);
    if (b < 0) b = 0;
    if (b >= nbins) b = nbins - 1;
    counts[b]++;
  }
}

/* kernel density estimation with Gaussian kernel */
double kde_gaussian(const double *x, int n, double bw, double point) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double z = (point - x[i]) / bw;
    s += exp(-0.5 * z * z);
  }
  return s / (n * bw * 2.506628274631);
}

/* Spearman rank correlation */
double rank_correlation(const double *x, const double *y, int n) {
  double d2 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - y[i];
    d2 += d * d;
  }
  return 1.0 - 6.0 * d2 / (n * ((double)n * n - 1));
}

/* exponential distribution PDF */
double exp_pdf(double x, double lambda) {
  return x >= 0 ? lambda * exp(-lambda * x) : 0;
}

/* Poisson probability mass function */
double poisson_pmf(int k, double lambda) {
  return pow(lambda, k) * exp(-lambda) / factorial(k);
}

/* chi-squared statistic */
double chi_squared(const double *observed, const double *expected, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double d = observed[i] - expected[i];
    s += d * d / expected[i];
  }
  return s;
}

/* Kalman filter 1D predict step */
void kalman_predict(double *x, double *p, double q) {
  *p += q;
}

/* Kalman filter 1D update step */
void kalman_update(double *x, double *p, double z, double r) {
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* Goertzel algorithm for single frequency DFT */
double goertzel(const double *x, int n, double freq, double sr) {
  double w = 6.283185307 * freq / sr;
  double coeff = 2.0 * cos(w);
  double s0 = 0, s1 = 0, s2 = 0;
  for (int i = 0; i < n; i++) {
    s0 = x[i] + coeff * s1 - s2;
    s2 = s1; s1 = s0;
  }
  return s0 * s0 + s1 * s1 - coeff * s0 * s1;
}

/* short-time Fourier transform one frame */
void stft_frame(double *re, double *im, const double *signal, int offset, int fftsize) {
  double w[1024];
  hann_window(w, fftsize);
  for (int i = 0; i < fftsize; i++) {
    re[i] = signal[offset + i] * w[i];
    im[i] = 0;
  }
  fft_radix2(re, im, fftsize);
}

/* real cepstrum */
void cepstrum(double *cep, const double *signal, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = signal[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) re[i] = log(sqrt(re[i] * re[i] + im[i] * im[i]) + 1e-15);
  for (int i = 0; i < n; i++) im[i] = 0;
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) cep[i] = re[i] / n;
}

/* Hilbert transform envelope */
void hilbert_envelope(double *env, const double *x, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = x[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 1; i < n / 2; i++) { re[i] *= 2; im[i] *= 2; }
  for (int i = n / 2 + 1; i < n; i++) { re[i] = 0; im[i] = 0; }
  ifft(re, im, n);
  for (int i = 0; i < n; i++) env[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* biquad filter direct form I */
void biquad_filter(double *y, const double *x, int n,
                   double b0, double b1, double b2, double a1, double a2) {
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* resonant bandpass filter */
void bandpass_filter(double *y, const double *x, int n, double freq, double q, double sr) {
  double w0 = 6.283185307 * freq / sr;
  double alpha = sin(w0) / (2.0 * q);
  double b0 = alpha, b1 = 0, b2 = -alpha;
  double a0 = 1.0 + alpha, a1 = -2.0 * cos(w0), a2 = 1.0 - alpha;
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = (b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2) / a0;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* FIR filter */
void fir_filter(double *y, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < nx; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0) y[i] += h[j] * x[i - j];
  }
}

/* Kaiser window */
void kaiser_window(double *w, int n, double beta) {
  double denom = bessel_j0(beta);
  for (int i = 0; i < n; i++) {
    double t = 2.0 * i / (n - 1) - 1.0;
    w[i] = bessel_j0(beta * sqrt(1.0 - t * t)) / denom;
  }
}

/* overlap-add convolution */
void overlap_add(double *y, int ny, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < ny; i++) y[i] = 0;
  for (int i = 0; i < nx; i++)
    for (int j = 0; j < nh && i + j < ny; j++)
      y[i + j] += x[i] * h[j];
}

/* Welch power spectral density estimate */
void welch_psd(double *psd, const double *x, int n, int seglen, int overlap) {
  int step = seglen - overlap;
  int nseg = 0;
  for (int i = 0; i < seglen; i++) psd[i] = 0;
  for (int start = 0; start + seglen <= n; start += step) {
    double re[1024], im[1024], w[1024];
    hann_window(w, seglen);
    for (int i = 0; i < seglen; i++) { re[i] = x[start + i] * w[i]; im[i] = 0; }
    fft_radix2(re, im, seglen);
    for (int i = 0; i < seglen; i++) psd[i] += re[i] * re[i] + im[i] * im[i];
    nseg++;
  }
  if (nseg > 0) for (int i = 0; i < seglen; i++) psd[i] /= nseg;
}

/* simple moving average */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* exponential moving average */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* weighted moving average */
void wma(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    double ws = 0, s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    for (int j = start; j <= i; j++) {
      double w = j - start + 1;
      s += x[j] * w;
      ws += w;
    }
    out[i] = s / ws;
  }
}

/* relative strength index */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* MACD line and signal */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* Bollinger Bands */
void bollinger_bands(double *upper, double *middle, double *lower,
                     const double *close, int n, int period, double mult) {
  sma(middle, close, n, period);
  for (int i = 0; i < n; i++) {
    double s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    for (int j = start; j <= i; j++) {
      double d = close[j] - middle[i];
      s += d * d;
    }
    double sd = sqrt(s / cnt);
    upper[i] = middle[i] + mult * sd;
    lower[i] = middle[i] - mult * sd;
  }
}

/* stochastic oscillator %K */
void stochastic_k(double *k_out, const double *high, const double *low,
                  const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    k_out[i] = (hi - lo > 1e-15) ? 100.0 * (close[i] - lo) / (hi - lo) : 50.0;
  }
}

/* average true range */
void atr(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tr = high[i] - low[i];
    if (i > 0) {
      double d1 = fabs(high[i] - close[i - 1]);
      double d2 = fabs(low[i] - close[i - 1]);
      if (d1 > tr) tr = d1;
      if (d2 > tr) tr = d2;
    }
    if (i == 0) out[i] = tr;
    else out[i] = (out[i - 1] * (period - 1) + tr) / period;
  }
}

/* on-balance volume */
void obv(double *out, const double *close, const double *volume, int n) {
  out[0] = volume[0];
  for (int i = 1; i < n; i++) {
    if (close[i] > close[i - 1]) out[i] = out[i - 1] + volume[i];
    else if (close[i] < close[i - 1]) out[i] = out[i - 1] - volume[i];
    else out[i] = out[i - 1];
  }
}

/* volume-weighted average price */
double vwap(const double *price, const double *volume, int n) {
  double pv = 0, v = 0;
  for (int i = 0; i < n; i++) { pv += price[i] * volume[i]; v += volume[i]; }
  return pv / (v + 1e-15);
}

/* rate of change */
void roc(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    if (i < period) out[i] = 0;
    else out[i] = 100.0 * (x[i] - x[i - period]) / (x[i - period] + 1e-15);
  }
}

/* Williams %R */
void williams_r(double *out, const double *high, const double *low,
                const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi - lo > 1e-15) ? -100.0 * (hi - close[i]) / (hi - lo) : -50.0;
  }
}

/* commodity channel index */
void cci(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tp = (high[i] + low[i] + close[i]) / 3.0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double sma_tp = 0;
    for (int j = start; j <= i; j++) sma_tp += (high[j] + low[j] + close[j]) / 3.0;
    sma_tp /= cnt;
    double mad = 0;
    for (int j = start; j <= i; j++) mad += fabs((high[j] + low[j] + close[j]) / 3.0 - sma_tp);
    mad /= cnt;
    out[i] = (mad > 1e-15) ? (tp - sma_tp) / (0.015 * mad) : 0;
  }
}

/* parabolic SAR */
void parabolic_sar(double *sar, const double *high, const double *low, int n,
                   double af_start, double af_step, double af_max) {
  int uptrend = 1;
  double af = af_start;
  double ep = high[0];
  sar[0] = low[0];
  for (int i = 1; i < n; i++) {
    sar[i] = sar[i - 1] + af * (ep - sar[i - 1]);
    if (uptrend) {
      if (high[i] > ep) { ep = high[i]; af += af_step; if (af > af_max) af = af_max; }
      if (low[i] < sar[i]) { uptrend = 0; sar[i] = ep; ep = low[i]; af = af_start; }
    } else {
      if (low[i] < ep) { ep = low[i]; af += af_step; if (af > af_max) af = af_max; }
      if (high[i] > sar[i]) { uptrend = 1; sar[i] = ep; ep = high[i]; af = af_start; }
    }
  }
}

/* average directional index */
void adx(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  double atr_val = 0;
  double plus_dm = 0, minus_dm = 0;
  for (int i = 1; i < n; i++) {
    double tr = high[i] - low[i];
    double d1 = fabs(high[i] - close[i - 1]);
    double d2 = fabs(low[i] - close[i - 1]);
    if (d1 > tr) tr = d1;
    if (d2 > tr) tr = d2;
    double pdm = high[i] - high[i - 1];
    double mdm = low[i - 1] - low[i];
    if (pdm < 0) pdm = 0;
    if (mdm < 0) mdm = 0;
    if (pdm > mdm) mdm = 0; else pdm = 0;
    atr_val = (atr_val * (period - 1) + tr) / period;
    plus_dm = (plus_dm * (period - 1) + pdm) / period;
    minus_dm = (minus_dm * (period - 1) + mdm) / period;
    double pdi = 100.0 * plus_dm / (atr_val + 1e-15);
    double mdi = 100.0 * minus_dm / (atr_val + 1e-15);
    double dx = 100.0 * fabs(pdi - mdi) / (pdi + mdi + 1e-15);
    if (i == 1) out[i] = dx;
    else out[i] = (out[i - 1] * (period - 1) + dx) / period;
  }
  out[0] = 0;
}

/* Ichimoku cloud tenkan-sen */
void ichimoku_tenkan(double *out, const double *high, const double *low, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi + lo) / 2.0;
  }
}

/* Hull moving average */
void hull_ma(double *out, const double *x, int n, int period) {
  double wma1[1024], wma2[1024], diff[1024];
  int half = period / 2;
  int root = (int)sqrt((double)period);
  wma(wma1, x, n, half);
  wma(wma2, x, n, period);
  for (int i = 0; i < n; i++) diff[i] = 2.0 * wma1[i] - wma2[i];
  wma(out, diff, n, root);
}

/* double exponential moving average */
void dema(double *out, const double *x, int n, int period) {
  double ema1[1024], ema2[1024];
  ema_series(ema1, x, n, period);
  ema_series(ema2, ema1, n, period);
  for (int i = 0; i < n; i++) out[i] = 2.0 * ema1[i] - ema2[i];
}

/* Aroon oscillator */
void aroon(double *up, double *down, const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period;
    if (start < 0) start = 0;
    int hi_idx = start, lo_idx = start;
    for (int j = start + 1; j <= i; j++) {
      if (close[j] >= close[hi_idx]) hi_idx = j;
      if (close[j] <= close[lo_idx]) lo_idx = j;
    }
    int span = i - start;
    if (span == 0) span = 1;
    up[i] = 100.0 * (i - hi_idx) / span;
    down[i] = 100.0 * (i - lo_idx) / span;
  }
}

/* linear returns from prices */
void linear_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = (price[i] - price[i - 1]) / price[i - 1];
}

/* log returns from prices */
void log_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = log(price[i] / price[i - 1]);
}

/* Sharpe ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* maximum drawdown */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* rolling beta against benchmark */
void rolling_beta(double *beta, const double *ret, const double *bench, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double cov = 0, var_b = 0;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    for (int j = start; j <= i; j++) {
      cov += (ret[j] - mr) * (bench[j] - mb);
      var_b += (bench[j] - mb) * (bench[j] - mb);
    }
    beta[i] = (var_b > 1e-15) ? cov / var_b : 0;
  }
}

/* rolling alpha */
void rolling_alpha(double *alpha, const double *ret, const double *bench,
                   const double *beta_arr, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    alpha[i] = mr - beta_arr[i] * mb;
  }
}

/* portfolio variance from weights and covariance matrix */
double portfolio_variance(const double *weights, const double *cov_matrix, int n) {
  double var = 0;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      var += weights[i] * weights[j] * cov_matrix[i * n + j];
  return var;
}

/* value at risk historical method */
double value_at_risk(double *returns, int n, double confidence) {
  bubble_sort(returns, n);
  int idx = (int)((1.0 - confidence) * n);
  if (idx < 0) idx = 0;
  if (idx >= n) idx = n - 1;
  return -returns[idx];
}

/* CAGR compound annual growth rate */
double cagr(double begin_val, double end_val, double years) {
  return pow(end_val / begin_val, 1.0 / years) - 1.0;
}

/* Sortino ratio */
double sortino_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = 0;
  int cnt = 0;
  for (int i = 0; i < n; i++) {
    double d = returns[i] - risk_free;
    if (d < 0) { s += d * d; cnt++; }
  }
  double dd = (cnt > 0) ? sqrt(s / cnt) : 1e-15;
  return m / dd;
}

/* Calmar ratio */
double calmar_ratio(const double *equity, int n, double annual_return) {
  double mdd = max_drawdown(equity, n);
  return annual_return / (mdd + 1e-15);
}


/* compute average of array */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* arithmetic mean */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* array average */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* calculate standard deviation */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* standard deviation of array */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* sort array ascending */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort values in ascending order */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort array in place */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* insertion sort */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* sort using insertion method */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* compute dot product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* inner product of vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* vector dot product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* apply FFT with window */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* windowed FFT */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT of windowed signal */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* transpose matrix */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* matrix transpose */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* binary search */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* search sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* find value in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* compute sigmoid */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* sigmoid function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* logistic function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* compute ReLU */
double relu(double x) { return x > 0 ? x : 0; }

/* rectified linear unit */
double relu(double x) { return x > 0 ? x : 0; }

/* ReLU activation */
double relu(double x) { return x > 0 ? x : 0; }

/* simple moving average of series */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* compute SMA */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* moving average */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* compute EMA */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* exponential moving average series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* EMA of price series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* Hann window function */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* compute Hann window */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* Hann window coefficients */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* compute RSI */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* relative strength indicator */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* compute Sharpe */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* risk-adjusted return ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* return to volatility ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* normalize to z-scores */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* standardize array */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* compute z-scores */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* Pearson correlation */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* compute correlation coefficient */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* linear correlation */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* low pass filter first order IIR */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* first order IIR filter */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* IIR low pass */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* smooth signal with low pass */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* maximum drawdown of equity curve */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* compute max drawdown */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* largest peak to trough decline */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* compute MACD */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* MACD indicator */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* moving average convergence divergence */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* Kalman filter step */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* 1D Kalman update */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* Kalman predict and update */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* vector scale */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* multiply vector by scalar */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* scale array elements */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* vector add */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* add two vectors */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* element-wise sum of arrays */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* Hamming window */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* compute Hamming window */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Hamming window coefficients */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Blackman window */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* compute Blackman window */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* Blackman window coefficients */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* mean squared error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* compute MSE */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* mean squared prediction error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* root mean squared error */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* compute RMSE */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* vector L2 norm */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* compute vector magnitude */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* Euclidean norm */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* normalize vector to unit length */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* unit vector */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* make vector unit length */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* cross correlation of two signals */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* compute cross correlation */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* signal cross correlation */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* median filter */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* sliding window median */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* compute median filter */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* rolling Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* compute rolling Sharpe */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* windowed Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* FFT with Hamming window */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* Hamming windowed FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply Hamming then FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Blackman window */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* Blackman windowed FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply Blackman then FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* Kalman smoothed moving average */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* Kalman filter as smoother */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* smooth signal with Kalman filter */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* EMA crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* fast slow EMA crossover */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* moving average crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* low pass filtered power spectrum */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* power spectrum of filtered signal */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* filter then compute power spectrum */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* normalized correlation */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* z-score correlation */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* correlation of standardized signals */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* Bollinger band width */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* compute Bollinger bandwidth */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* Bollinger band spread */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* RSI with moving average */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* smoothed RSI */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* moving average of RSI */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* MACD histogram */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* compute MACD histogram */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* MACD bar chart values */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* signal to noise ratio */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* compute SNR in dB */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* signal noise ratio */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* normal CDF approximation */
double norm_cdf(double x) {
  double t = 1.0 / (1.0 + 0.2316419 * fabs(x));
  double d = 0.3989422804 * exp(-0.5 * x * x);
  double p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
  return x > 0 ? 1.0 - p : p;
}

/* normal PDF */
double norm_pdf(double x) {
  return 0.3989422804 * exp(-0.5 * x * x);
}

/* Black-Scholes call option price */
double bs_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return S * norm_cdf(d1) - K * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes put option price */
double bs_put(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * exp(-r * T) * norm_cdf(-d2) - S * norm_cdf(-d1);
}

/* Black-Scholes delta for call */
double bs_delta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_cdf(d1);
}

/* Black-Scholes gamma */
double bs_gamma(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_pdf(d1) / (S * sigma * sqrt(T));
}

/* Black-Scholes vega */
double bs_vega(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return S * norm_pdf(d1) * sqrt(T);
}

/* Black-Scholes theta for call */
double bs_theta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return -(S * norm_pdf(d1) * sigma) / (2.0 * sqrt(T)) - r * K * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes rho for call */
double bs_rho_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * T * exp(-r * T) * norm_cdf(d2);
}

/* geometric Brownian motion step */
double gbm_step(double S, double mu, double sigma, double dt, double z) {
  return S * exp((mu - 0.5 * sigma * sigma) * dt + sigma * sqrt(dt) * z);
}

/* log returns from price series */
void log_returns(double *out, const double *prices, int n) {
  for (int i = 1; i < n; i++) out[i - 1] = log(prices[i] / prices[i - 1]);
}

/* cumulative returns from return series */
void cumulative_returns(double *out, const double *returns, int n) {
  out[0] = 1.0 + returns[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * (1.0 + returns[i]);
}

/* annualized volatility from returns */
double annualized_vol(const double *returns, int n, int periods_per_year) {
  double s = stddev(returns, n);
  return s * sqrt((double)periods_per_year);
}

/* Sortino ratio */
double sortino_ratio(const double *returns, int n, double target) {
  double m = mean(returns, n) - target;
  double ds = 0; int cnt = 0;
  for (int i = 0; i < n; i++)
    if (returns[i] < target) { double d = returns[i] - target; ds += d * d; cnt++; }
  return cnt > 0 ? m / sqrt(ds / cnt) : 0;
}

/* Treynor ratio */
double treynor_ratio(double port_return, double risk_free, double beta) {
  return (port_return - risk_free) / (beta + 1e-15);
}

/* information ratio */
double information_ratio(const double *port, const double *bench, int n) {
  double diff[1024];
  for (int i = 0; i < n; i++) diff[i] = port[i] - bench[i];
  return mean(diff, n) / (stddev(diff, n) + 1e-15);
}

/* Calmar ratio */
double calmar_ratio(double ann_return, double max_dd) {
  return ann_return / (fabs(max_dd) + 1e-15);
}

/* portfolio beta */
double portfolio_beta(const double *port, const double *market, int n) {
  double mp = mean(port, n), mm = mean(market, n);
  double cov = 0, var = 0;
  for (int i = 0; i < n; i++) {
    cov += (port[i] - mp) * (market[i] - mm);
    var += (market[i] - mm) * (market[i] - mm);
  }
  return cov / (var + 1e-15);
}

/* Jensen's alpha */
double jensens_alpha(double port_return, double rf, double beta, double mkt_return) {
  return port_return - (rf + beta * (mkt_return - rf));
}

/* GARCH(1,1) variance forecast */
void garch_variance(double *h, const double *ret, int n, double omega, double alpha, double beta) {
  h[0] = omega / (1.0 - alpha - beta);
  for (int i = 1; i < n; i++)
    h[i] = omega + alpha * ret[i - 1] * ret[i - 1] + beta * h[i - 1];
}

/* covariance of two series */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* drawdown series from equity curve */
void drawdown_series(double *dd, const double *equity, int n) {
  double peak = equity[0];
  for (int i = 0; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    dd[i] = (equity[i] - peak) / peak;
  }
}

/* gain to pain ratio */
double gain_to_pain(const double *returns, int n) {
  double gains = 0, losses = 0;
  for (int i = 0; i < n; i++) {
    if (returns[i] > 0) gains += returns[i]; else losses -= returns[i];
  }
  return gains / (losses + 1e-15);
}

/* tail ratio */
double tail_ratio(const double *returns, int n) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int p95 = (int)(0.95 * n), p5 = (int)(0.05 * n);
  return fabs(sorted[p95]) / (fabs(sorted[p5]) + 1e-15);
}

/* expected shortfall CVaR */
double expected_shortfall(const double *returns, int n, double alpha) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int cutoff = (int)(alpha * n);
  double s = 0;
  for (int i = 0; i < cutoff; i++) s += sorted[i];
  return s / (cutoff > 0 ? cutoff : 1);
}

/* implied volatility using Newton-Raphson */
double implied_vol(double mkt_price, double S, double K, double r, double T) {
  double sigma = 0.2;
  for (int i = 0; i < 100; i++) {
    double price = bs_call(S, K, r, sigma, T);
    double v = bs_vega(S, K, r, sigma, T);
    if (fabs(v) < 1e-15) break;
    sigma -= (price - mkt_price) / v;
  }
  return sigma;
}

/* mean absolute error */
double mean_absolute_error(const double *y_true, const double *y_pred, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(y_true[i] - y_pred[i]);
  return s / n;
}

/* cosine similarity */
double cosine_similarity(const double *a, const double *b, int n) {
  double d = 0, na = 0, nb = 0;
  for (int i = 0; i < n; i++) { d += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
  return d / (sqrt(na) * sqrt(nb) + 1e-15);
}

/* euclidean distance between vectors */
double euclidean_distance(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = a[i] - b[i]; s += d * d; }
  return sqrt(s);
}

/* Manhattan distance */
double manhattan_distance(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(a[i] - b[i]);
  return s;
}

/* R-squared coefficient of determination */
double r_squared(const double *y_true, const double *y_pred, int n) {
  double m = mean(y_true, n), ss_res = 0, ss_tot = 0;
  for (int i = 0; i < n; i++) {
    double d = y_true[i] - y_pred[i]; ss_res += d * d;
    d = y_true[i] - m; ss_tot += d * d;
  }
  return 1.0 - ss_res / (ss_tot + 1e-15);
}

/* gravitational force between two masses */
double gravitational_force(double m1, double m2, double r) {
  return 6.674e-11 * m1 * m2 / (r * r);
}

/* orbital velocity */
double orbital_velocity(double M, double r) {
  return sqrt(6.674e-11 * M / r);
}

/* escape velocity */
double escape_velocity(double M, double r) {
  return sqrt(2.0 * 6.674e-11 * M / r);
}

/* kinetic energy */
double kinetic_energy(double m, double v) {
  return 0.5 * m * v * v;
}

/* gravitational potential energy */
double potential_energy_grav(double m, double g, double h) {
  return m * g * h;
}

/* spring potential energy */
double spring_energy(double k, double x) {
  return 0.5 * k * x * x;
}

/* simple harmonic oscillator position */
double sho_position(double A, double omega, double t, double phi) {
  return A * cos(omega * t + phi);
}

/* damped oscillator position */
double damped_oscillator(double A, double gamma, double omega, double t) {
  return A * exp(-gamma * t) * cos(omega * t);
}

/* projectile range */
double projectile_range(double v0, double theta, double g) {
  return v0 * v0 * sin(2.0 * theta) / g;
}

/* projectile maximum height */
double projectile_max_height(double v0, double theta, double g) {
  double vy = v0 * sin(theta);
  return vy * vy / (2.0 * g);
}

/* projectile time of flight */
double projectile_time(double v0, double theta, double g) {
  return 2.0 * v0 * sin(theta) / g;
}

/* Coulomb force between charges */
double coulomb_force(double q1, double q2, double r) {
  return 8.9875e9 * q1 * q2 / (r * r);
}

/* electric field from point charge */
double electric_field(double q, double r) {
  return 8.9875e9 * q / (r * r);
}

/* Lorentz factor */
double lorentz_factor(double v) {
  double c = 299792458.0;
  return 1.0 / sqrt(1.0 - (v * v) / (c * c));
}

/* relativistic time dilation */
double time_dilation(double t0, double v) {
  return t0 * lorentz_factor(v);
}

/* de Broglie wavelength */
double de_broglie(double m, double v) {
  return 6.626e-34 / (m * v);
}

/* Doppler shift frequency */
double doppler_freq(double f0, double v_source, double v_obs) {
  double c = 343.0;
  return f0 * (c + v_obs) / (c + v_source);
}

/* Stefan-Boltzmann radiation power */
double stefan_boltzmann(double emissivity, double area, double T) {
  return emissivity * 5.67e-8 * area * T * T * T * T;
}

/* Wien peak wavelength */
double wien_peak(double T) {
  return 2.898e-3 / T;
}

/* ideal gas pressure */
double ideal_gas_pressure(double n_moles, double T, double V) {
  return n_moles * 8.314 * T / V;
}

/* heat conduction Fourier law */
double heat_conduction(double k, double A, double dT, double L) {
  return k * A * dT / L;
}

/* entropy change at constant temperature */
double entropy_change(double Q, double T) {
  return Q / T;
}

/* centripetal acceleration */
double centripetal_accel(double v, double r) {
  return v * v / r;
}

/* pendulum period */
double pendulum_period(double L, double g) {
  return 2.0 * 3.14159265358979 * sqrt(L / g);
}

/* relativistic kinetic energy */
double relativistic_ke(double m, double v) {
  double c = 299792458.0;
  return m * c * c * (lorentz_factor(v) - 1.0);
}

/* present value */
double present_value(double FV, double r, double n) {
  return FV / pow(1.0 + r, n);
}

/* net present value */
double npv(const double *cashflows, int n, double r) {
  double s = 0;
  for (int i = 0; i < n; i++) s += cashflows[i] / pow(1.0 + r, (double)i);
  return s;
}

/* compound interest */
double compound_interest(double P, double r, int n, int t) {
  return P * pow(1.0 + r / n, (double)(n * t));
}

/* continuous compounding */
double continuous_compound(double P, double r, double t) {
  return P * exp(r * t);
}

/* discount factor */
double discount_factor(double r, double t) {
  return exp(-r * t);
}

/* forward rate from spot rates */
double forward_rate(double r1, double t1, double r2, double t2) {
  return (r2 * t2 - r1 * t1) / (t2 - t1);
}

/* bond price from yield */
double bond_price(double face, double coupon, double yield, int periods) {
  double price = 0;
  for (int i = 1; i <= periods; i++)
    price += coupon / pow(1.0 + yield, (double)i);
  price += face / pow(1.0 + yield, (double)periods);
  return price;
}

/* Macaulay duration */
double macaulay_duration(double face, double coupon, double yield, int periods) {
  double price = 0, dur = 0;
  for (int i = 1; i <= periods; i++) {
    double pv = coupon / pow(1.0 + yield, (double)i);
    price += pv; dur += i * pv;
  }
  double pv_f = face / pow(1.0 + yield, (double)periods);
  price += pv_f; dur += periods * pv_f;
  return dur / price;
}

/* modified duration */
double modified_duration(double mac_dur, double yield, int freq) {
  return mac_dur / (1.0 + yield / freq);
}

/* DV01 dollar value of basis point */
double dv01(double face, double coupon, double yield, int periods) {
  double p1 = bond_price(face, coupon, yield - 0.0001, periods);
  double p2 = bond_price(face, coupon, yield + 0.0001, periods);
  return (p1 - p2) / 2.0;
}

/* bond convexity */
double bond_convexity(double face, double coupon, double yield, int periods) {
  double price = bond_price(face, coupon, yield, periods);
  double p_up = bond_price(face, coupon, yield + 0.01, periods);
  double p_dn = bond_price(face, coupon, yield - 0.01, periods);
  return (p_up + p_dn - 2.0 * price) / (price * 0.0001);
}

/* amortization payment */
double amort_payment(double principal, double rate, int periods) {
  return principal * rate * pow(1.0 + rate, (double)periods) / (pow(1.0 + rate, (double)periods) - 1.0);
}

/* binomial tree European call */
double binomial_call(double S, double K, double r, double sigma, double T, int steps) {
  double dt = T / steps;
  double u = exp(sigma * sqrt(dt));
  double d = 1.0 / u;
  double p = (exp(r * dt) - d) / (u - d);
  double v[256];
  for (int i = 0; i <= steps; i++) {
    double ST = S * pow(u, steps - i) * pow(d, i);
    v[i] = ST > K ? ST - K : 0;
  }
  for (int j = steps - 1; j >= 0; j--)
    for (int i = 0; i <= j; i++)
      v[i] = exp(-r * dt) * (p * v[i] + (1.0 - p) * v[i + 1]);
  return v[0];
}

/* Vasicek interest rate step */
double vasicek_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(dt) * z;
}

/* CIR interest rate step */
double cir_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(fabs(r) * dt) * z;
}

/* default probability from hazard rate */
double default_probability(double hazard_rate, double t) {
  return 1.0 - exp(-hazard_rate * t);
}

/* survival probability */
double survival_probability(double hazard_rate, double t) {
  return exp(-hazard_rate * t);
}

/* IRR by bisection */
double irr_bisect(const double *cashflows, int n) {
  double lo = -0.5, hi = 1.0;
  for (int iter = 0; iter < 100; iter++) {
    double mid = (lo + hi) / 2.0, npv_val = 0;
    for (int i = 0; i < n; i++) npv_val += cashflows[i] / pow(1.0 + mid, (double)i);
    if (npv_val > 0) lo = mid; else hi = mid;
  }
  return (lo + hi) / 2.0;
}

/* accrued interest */
double accrued_interest(double coupon, int days_since, int days_in_period) {
  return coupon * (double)days_since / (double)days_in_period;
}

/* parametric VaR */
double parametric_var(double mu, double sigma, double z, double horizon) {
  return -(mu * horizon - z * sigma * sqrt(horizon));
}

/* qubit state normalization */
void qubit_normalize(double *re, double *im, int n) {
  double norm = 0;
  for (int i = 0; i < n; i++) norm += re[i] * re[i] + im[i] * im[i];
  norm = sqrt(norm);
  for (int i = 0; i < n; i++) { re[i] /= norm; im[i] /= norm; }
}

/* Born rule measurement probability */
double born_probability(double re, double im) {
  return re * re + im * im;
}

/* Hadamard gate on single qubit */
void hadamard_gate(double *re, double *im) {
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  double s = 0.7071067811865476;
  re[0] = s * (r0 + r1); im[0] = s * (i0 + i1);
  re[1] = s * (r0 - r1); im[1] = s * (i0 - i1);
}

/* Pauli-X gate */
void pauli_x_gate(double *re, double *im) {
  double t;
  t = re[0]; re[0] = re[1]; re[1] = t;
  t = im[0]; im[0] = im[1]; im[1] = t;
}

/* Pauli-Z gate */
void pauli_z_gate(double *re, double *im) {
  re[1] = -re[1]; im[1] = -im[1];
}

/* phase gate */
void phase_gate(double *re, double *im, double phi) {
  double r1 = re[1], i1 = im[1];
  re[1] = r1 * cos(phi) - i1 * sin(phi);
  im[1] = r1 * sin(phi) + i1 * cos(phi);
}

/* rotation around X axis */
void rx_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i1; im[0] = c * i0 - s * r1;
  re[1] = s * i0 + c * r1; im[1] = -s * r0 + c * i1;
}

/* rotation around Y axis */
void ry_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 - s * r1; im[0] = c * i0 - s * i1;
  re[1] = s * r0 + c * r1; im[1] = s * i0 + c * i1;
}

/* rotation around Z axis */
void rz_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i0; im[0] = c * i0 - s * r0;
  re[1] = c * r1 - s * i1; im[1] = c * i1 + s * r1;
}

/* Bloch sphere theta coordinate */
double bloch_theta(double *re, double *im) {
  double p0 = re[0] * re[0] + im[0] * im[0];
  return 2.0 * acos(sqrt(p0));
}

/* Bloch sphere phi coordinate */
double bloch_phi(double *re, double *im) {
  return atan2(im[1], re[1]) - atan2(im[0], re[0]);
}

/* quantum state fidelity */
double quantum_fidelity(double *re1, double *im1, double *re2, double *im2, int n) {
  double re_s = 0, im_s = 0;
  for (int i = 0; i < n; i++) {
    re_s += re1[i] * re2[i] + im1[i] * im2[i];
    im_s += re1[i] * im2[i] - im1[i] * re2[i];
  }
  return re_s * re_s + im_s * im_s;
}

/* quantum expectation value of diagonal observable */
double quantum_expectation(const double *re, const double *im, const double *obs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += obs[i] * (re[i] * re[i] + im[i] * im[i]);
  return s;
}

/* tensor product of two qubit states */
void tensor_product_2q(double *re_out, double *im_out,
                       const double *re_a, const double *im_a,
                       const double *re_b, const double *im_b) {
  for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++) {
      int k = i * 2 + j;
      re_out[k] = re_a[i] * re_b[j] - im_a[i] * im_b[j];
      im_out[k] = re_a[i] * im_b[j] + im_a[i] * re_b[j];
    }
}

/* von Neumann entropy */
double von_neumann_entropy(const double *probs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++)
    if (probs[i] > 1e-15) s -= probs[i] * log(probs[i]);
  return s;
}

/* softmax activation */
void softmax(double *out, const double *x, int n) {
  double mx = x[0];
  for (int i = 1; i < n; i++) if (x[i] > mx) mx = x[i];
  double sum = 0;
  for (int i = 0; i < n; i++) { out[i] = exp(x[i] - mx); sum += out[i]; }
  for (int i = 0; i < n; i++) out[i] /= sum;
}

/* leaky ReLU activation */
double leaky_relu(double x, double alpha) {
  return x > 0 ? x : alpha * x;
}

/* linear interpolation */
double lerp(double a, double b, double t) {
  return a + t * (b - a);
}

/* clamp value to range */
double clamp(double x, double lo, double hi) {
  return x < lo ? lo : (x > hi ? hi : x);
}

/* map value between ranges */
double map_range(double x, double in_lo, double in_hi, double out_lo, double out_hi) {
  return out_lo + (x - in_lo) * (out_hi - out_lo) / (in_hi - in_lo);
}

/* cumulative product */
void cumulative_product(double *out, const double *x, int n) {
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * x[i];
}

/* moving minimum */
void moving_min(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] < m) m = x[j];
    out[i] = m;
  }
}

/* moving maximum */
void moving_max(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] > m) m = x[j];
    out[i] = m;
  }
}

/* weighted mean */
double weighted_mean(const double *x, const double *w, int n) {
  double num = 0, den = 0;
  for (int i = 0; i < n; i++) { num += x[i] * w[i]; den += w[i]; }
  return num / den;
}

/* geometric mean */
double geometric_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += log(x[i]);
  return exp(s / n);
}

/* harmonic mean */
double harmonic_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += 1.0 / x[i];
  return (double)n / s;
}

/* Chebyshev distance */
double chebyshev_distance(const double *a, const double *b, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) {
    double d = fabs(a[i] - b[i]);
    if (d > m) m = d;
  }
  return m;
}

/* compute bisection root finder */
double bisect(double (*f)(double), double a, double b, double tol) {
  double c;
  for (int i = 0; i < 100; i++) {
    c = (a + b) * 0.5;
    if (f(c) * f(a) < 0) b = c; else a = c;
    if (b - a < tol) break;
  }
  return c;
}

/* calculate bisection root finder */
double bisect(double (*f)(double), double a, double b, double tol) {
  double c;
  for (int i = 0; i < 100; i++) {
    c = (a + b) * 0.5;
    if (f(c) * f(a) < 0) b = c; else a = c;
    if (b - a < tol) break;
  }
  return c;
}

/* bisection root finder of array */
double bisect(double (*f)(double), double a, double b, double tol) {
  double c;
  for (int i = 0; i < 100; i++) {
    c = (a + b) * 0.5;
    if (f(c) * f(a) < 0) b = c; else a = c;
    if (b - a < tol) break;
  }
  return c;
}

/* bisection root finder function */
double bisect(double (*f)(double), double a, double b, double tol) {
  double c;
  for (int i = 0; i < 100; i++) {
    c = (a + b) * 0.5;
    if (f(c) * f(a) < 0) b = c; else a = c;
    if (b - a < tol) break;
  }
  return c;
}

/* compute Newton-Raphson root finder */
double newton(double (*f)(double), double (*df)(double), double x, double tol) {
  for (int i = 0; i < 50; i++) {
    double fx = f(x), dfx = df(x);
    if (fabs(dfx) < 1e-15) break;
    double dx = fx / dfx;
    x -= dx;
    if (fabs(dx) < tol) break;
  }
  return x;
}

/* calculate Newton-Raphson root finder */
double newton(double (*f)(double), double (*df)(double), double x, double tol) {
  for (int i = 0; i < 50; i++) {
    double fx = f(x), dfx = df(x);
    if (fabs(dfx) < 1e-15) break;
    double dx = fx / dfx;
    x -= dx;
    if (fabs(dx) < tol) break;
  }
  return x;
}

/* Newton-Raphson root finder of array */
double newton(double (*f)(double), double (*df)(double), double x, double tol) {
  for (int i = 0; i < 50; i++) {
    double fx = f(x), dfx = df(x);
    if (fabs(dfx) < 1e-15) break;
    double dx = fx / dfx;
    x -= dx;
    if (fabs(dx) < tol) break;
  }
  return x;
}

/* Newton-Raphson root finder function */
double newton(double (*f)(double), double (*df)(double), double x, double tol) {
  for (int i = 0; i < 50; i++) {
    double fx = f(x), dfx = df(x);
    if (fabs(dfx) < 1e-15) break;
    double dx = fx / dfx;
    x -= dx;
    if (fabs(dx) < tol) break;
  }
  return x;
}

/* compute secant method root finder */
double secant(double (*f)(double), double x0, double x1, double tol) {
  double f0 = f(x0), f1 = f(x1);
  for (int i = 0; i < 50; i++) {
    if (fabs(f1 - f0) < 1e-15) break;
    double x2 = x1 - f1 * (x1 - x0) / (f1 - f0);
    x0 = x1; f0 = f1;
    x1 = x2; f1 = f(x2);
    if (fabs(x1 - x0) < tol) break;
  }
  return x1;
}

/* calculate secant method root finder */
double secant(double (*f)(double), double x0, double x1, double tol) {
  double f0 = f(x0), f1 = f(x1);
  for (int i = 0; i < 50; i++) {
    if (fabs(f1 - f0) < 1e-15) break;
    double x2 = x1 - f1 * (x1 - x0) / (f1 - f0);
    x0 = x1; f0 = f1;
    x1 = x2; f1 = f(x2);
    if (fabs(x1 - x0) < tol) break;
  }
  return x1;
}

/* secant method root finder of array */
double secant(double (*f)(double), double x0, double x1, double tol) {
  double f0 = f(x0), f1 = f(x1);
  for (int i = 0; i < 50; i++) {
    if (fabs(f1 - f0) < 1e-15) break;
    double x2 = x1 - f1 * (x1 - x0) / (f1 - f0);
    x0 = x1; f0 = f1;
    x1 = x2; f1 = f(x2);
    if (fabs(x1 - x0) < tol) break;
  }
  return x1;
}

/* secant method root */
double secant(double (*f)(double), double x0, double x1, double tol) {
  double f0 = f(x0), f1 = f(x1);
  for (int i = 0; i < 50; i++) {
    if (fabs(f1 - f0) < 1e-15) break;
    double x2 = x1 - f1 * (x1 - x0) / (f1 - f0);
    x0 = x1; f0 = f1;
    x1 = x2; f1 = f(x2);
    if (fabs(x1 - x0) < tol) break;
  }
  return x1;
}

/* compute trapezoidal integration */
double trapez(double (*f)(double), double a, double b, int n) {
  double h = (b - a) / n, s = 0.5 * (f(a) + f(b));
  for (int i = 1; i < n; i++) s += f(a + i * h);
  return s * h;
}

/* calculate trapezoidal integration */
double trapez(double (*f)(double), double a, double b, int n) {
  double h = (b - a) / n, s = 0.5 * (f(a) + f(b));
  for (int i = 1; i < n; i++) s += f(a + i * h);
  return s * h;
}

/* trapezoidal integproportionn */
double trapez(double (*f)(double), double a, double b, int n) {
  double h = (b - a) / n, s = 0.5 * (f(a) + f(b));
  for (int i = 1; i < n; i++) s += f(a + i * h);
  return s * h;
}

/* trapezoidal integrelative measuren */
double trapez(double (*f)(double), double a, double b, int n) {
  double h = (b - a) / n, s = 0.5 * (f(a) + f(b));
  for (int i = 1; i < n; i++) s += f(a + i * h);
  return s * h;
}

/* compute Simpson's rule integration */
double simpson(double (*f)(double), double a, double b, int n) {
  if (n % 2 != 0) n++;
  double h = (b - a) / n, s = f(a) + f(b);
  for (int i = 1; i < n; i++) s += (i % 2 == 0 ? 2.0 : 4.0) * f(a + i * h);
  return s * h / 3.0;
}

/* calculate Simpson's rule integration */
double simpson(double (*f)(double), double a, double b, int n) {
  if (n % 2 != 0) n++;
  double h = (b - a) / n, s = f(a) + f(b);
  for (int i = 1; i < n; i++) s += (i % 2 == 0 ? 2.0 : 4.0) * f(a + i * h);
  return s * h / 3.0;
}

/* Simpson's rule integproportionn */
double simpson(double (*f)(double), double a, double b, int n) {
  if (n % 2 != 0) n++;
  double h = (b - a) / n, s = f(a) + f(b);
  for (int i = 1; i < n; i++) s += (i % 2 == 0 ? 2.0 : 4.0) * f(a + i * h);
  return s * h / 3.0;
}

/* Simpson's rule integrelative measuren */
double simpson(double (*f)(double), double a, double b, int n) {
  if (n % 2 != 0) n++;
  double h = (b - a) / n, s = f(a) + f(b);
  for (int i = 1; i < n; i++) s += (i % 2 == 0 ? 2.0 : 4.0) * f(a + i * h);
  return s * h / 3.0;
}

/* compute Romberg integration */
double romberg(double (*f)(double), double a, double b, int n) {
  double h = b - a;
  double R[16][16];
  R[0][0] = 0.5 * h * (f(a) + f(b));
  for (int i = 1; i < n; i++) {
    h *= 0.5;
    double s = 0;
    for (int k = 1; k <= (1 << (i - 1)); k++) s += f(a + (2 * k - 1) * h);
    R[i][0] = 0.5 * R[i - 1][0] + h * s;
    for (int j = 1; j <= i; j++) {
      double p = pow(4.0, j);
      R[i][j] = (p * R[i][j - 1] - R[i - 1][j - 1]) / (p - 1.0);
    }
  }
  return R[n - 1][n - 1];
}

/* calculate Romberg integration */
double romberg(double (*f)(double), double a, double b, int n) {
  double h = b - a;
  double R[16][16];
  R[0][0] = 0.5 * h * (f(a) + f(b));
  for (int i = 1; i < n; i++) {
    h *= 0.5;
    double s = 0;
    for (int k = 1; k <= (1 << (i - 1)); k++) s += f(a + (2 * k - 1) * h);
    R[i][0] = 0.5 * R[i - 1][0] + h * s;
    for (int j = 1; j <= i; j++) {
      double p = pow(4.0, j);
      R[i][j] = (p * R[i][j - 1] - R[i - 1][j - 1]) / (p - 1.0);
    }
  }
  return R[n - 1][n - 1];
}

/* Romberg integproportionn */
double romberg(double (*f)(double), double a, double b, int n) {
  double h = b - a;
  double R[16][16];
  R[0][0] = 0.5 * h * (f(a) + f(b));
  for (int i = 1; i < n; i++) {
    h *= 0.5;
    double s = 0;
    for (int k = 1; k <= (1 << (i - 1)); k++) s += f(a + (2 * k - 1) * h);
    R[i][0] = 0.5 * R[i - 1][0] + h * s;
    for (int j = 1; j <= i; j++) {
      double p = pow(4.0, j);
      R[i][j] = (p * R[i][j - 1] - R[i - 1][j - 1]) / (p - 1.0);
    }
  }
  return R[n - 1][n - 1];
}

/* Romberg integrelative measuren */
double romberg(double (*f)(double), double a, double b, int n) {
  double h = b - a;
  double R[16][16];
  R[0][0] = 0.5 * h * (f(a) + f(b));
  for (int i = 1; i < n; i++) {
    h *= 0.5;
    double s = 0;
    for (int k = 1; k <= (1 << (i - 1)); k++) s += f(a + (2 * k - 1) * h);
    R[i][0] = 0.5 * R[i - 1][0] + h * s;
    for (int j = 1; j <= i; j++) {
      double p = pow(4.0, j);
      R[i][j] = (p * R[i][j - 1] - R[i - 1][j - 1]) / (p - 1.0);
    }
  }
  return R[n - 1][n - 1];
}

/* compute Monte Carlo integration */
double integrate_mc(double (*f)(double), double a, double b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double x = a + (b - a) * ((double)rand() / RAND_MAX);
    s += f(x);
  }
  return (b - a) * s / n;
}

/* calculate Monte Carlo integration */
double integrate_mc(double (*f)(double), double a, double b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double x = a + (b - a) * ((double)rand() / RAND_MAX);
    s += f(x);
  }
  return (b - a) * s / n;
}

/* Monte Carlo integproportionn */
double integrate_mc(double (*f)(double), double a, double b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double x = a + (b - a) * ((double)rand() / RAND_MAX);
    s += f(x);
  }
  return (b - a) * s / n;
}

/* Monte Carlo integrelative measuren */
double integrate_mc(double (*f)(double), double a, double b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double x = a + (b - a) * ((double)rand() / RAND_MAX);
    s += f(x);
  }
  return (b - a) * s / n;
}

/* compute linear interpolation */
double lerp(double a, double b, double t) {
  return a + t * (b - a);
}

/* calculate linear interpolation */
double lerp(double a, double b, double t) {
  return a + t * (b - a);
}

/* linear interpolation of array */
double lerp(double a, double b, double t) {
  return a + t * (b - a);
}

/* linear interpolation function */
double lerp(double a, double b, double t) {
  return a + t * (b - a);
}

/* compute bilinear interpolation */
double bilinear(double f00, double f10, double f01, double f11, double u, double v) {
  return f00 * (1 - u) * (1 - v) + f10 * u * (1 - v) + f01 * (1 - u) * v + f11 * u * v;
}

/* calculate bilinear interpolation */
double bilinear(double f00, double f10, double f01, double f11, double u, double v) {
  return f00 * (1 - u) * (1 - v) + f10 * u * (1 - v) + f01 * (1 - u) * v + f11 * u * v;
}

/* bilinear interpolation of array */
double bilinear(double f00, double f10, double f01, double f11, double u, double v) {
  return f00 * (1 - u) * (1 - v) + f10 * u * (1 - v) + f01 * (1 - u) * v + f11 * u * v;
}

/* bilinear interpolation function */
double bilinear(double f00, double f10, double f01, double f11, double u, double v) {
  return f00 * (1 - u) * (1 - v) + f10 * u * (1 - v) + f01 * (1 - u) * v + f11 * u * v;
}

/* compute clamp value to range */
double clamp(double x, double lo, double hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

/* calculate clamp value to range */
double clamp(double x, double lo, double hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

/* clamp price to range */
double clamp(double x, double lo, double hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

/* clamp fair value to range */
double clamp(double x, double lo, double hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

/* compute dot product of two vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* calculate dot product of two vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* inner product of two vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* scalar product of two vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* compute vector addition */
void vec_add(double *r, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] + b[i];
}

/* calculate vector addition */
void vec_add(double *r, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] + b[i];
}

/* vector addition of array */
void vec_add(double *r, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] + b[i];
}

/* vector addition function */
void vec_add(double *r, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] + b[i];
}

/* compute vector scaling */
void vec_scale(double *r, const double *a, double s, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] * s;
}

/* calculate vector scaling */
void vec_scale(double *r, const double *a, double s, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] * s;
}

/* vector scaling of array */
void vec_scale(double *r, const double *a, double s, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] * s;
}

/* vector scaling function */
void vec_scale(double *r, const double *a, double s, int n) {
  for (int i = 0; i < n; i++) r[i] = a[i] * s;
}

/* compute vector Euclidean norm */
double vec_norm(const double *v, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += v[i] * v[i];
  return sqrt(s);
}

/* calculate vector Euclidean norm */
double vec_norm(const double *v, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += v[i] * v[i];
  return sqrt(s);
}

/* vector Euclidean norm of array */
double vec_norm(const double *v, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += v[i] * v[i];
  return sqrt(s);
}

/* vector Euclidean norm function */
double vec_norm(const double *v, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += v[i] * v[i];
  return sqrt(s);
}

/* normalise a vector to unit length */
void vec_normalize(double *v, int n) {
  double len = vec_norm(v, n);
  if (len > 1e-15) for (int i = 0; i < n; i++) v[i] /= len;
}

/* rescale a vector to unit length */
void vec_normalize(double *v, int n) {
  double len = vec_norm(v, n);
  if (len > 1e-15) for (int i = 0; i < n; i++) v[i] /= len;
}

/* normalize a vector to unit length of array */
void vec_normalize(double *v, int n) {
  double len = vec_norm(v, n);
  if (len > 1e-15) for (int i = 0; i < n; i++) v[i] /= len;
}

/* normalize a vector */
void vec_normalize(double *v, int n) {
  double len = vec_norm(v, n);
  if (len > 1e-15) for (int i = 0; i < n; i++) v[i] /= len;
}

/* compute matrix-vector multiply */
void mat_vec(double *y, const double *A, const double *x, int m, int n) {
  for (int i = 0; i < m; i++) {
    double s = 0;
    for (int j = 0; j < n; j++) s += A[i * n + j] * x[j];
    y[i] = s;
  }
}

/* calculate matrix-vector multiply */
void mat_vec(double *y, const double *A, const double *x, int m, int n) {
  for (int i = 0; i < m; i++) {
    double s = 0;
    for (int j = 0; j < n; j++) s += A[i * n + j] * x[j];
    y[i] = s;
  }
}

/* matrix-vector multiply of array */
void mat_vec(double *y, const double *A, const double *x, int m, int n) {
  for (int i = 0; i < m; i++) {
    double s = 0;
    for (int j = 0; j < n; j++) s += A[i * n + j] * x[j];
    y[i] = s;
  }
}

/* matrix-vector multiply function */
void mat_vec(double *y, const double *A, const double *x, int m, int n) {
  for (int i = 0; i < m; i++) {
    double s = 0;
    for (int j = 0; j < n; j++) s += A[i * n + j] * x[j];
    y[i] = s;
  }
}

/* compute matrix multiplication */
void mat_mul(double *C, const double *A, const double *B, int m, int n, int p) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < p; j++) {
      double s = 0;
      for (int k = 0; k < n; k++) s += A[i * n + k] * B[k * p + j];
      C[i * p + j] = s;
    }
}

/* calculate matrix multiplication */
void mat_mul(double *C, const double *A, const double *B, int m, int n, int p) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < p; j++) {
      double s = 0;
      for (int k = 0; k < n; k++) s += A[i * n + k] * B[k * p + j];
      C[i * p + j] = s;
    }
}

/* matrix multiplication of array */
void mat_mul(double *C, const double *A, const double *B, int m, int n, int p) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < p; j++) {
      double s = 0;
      for (int k = 0; k < n; k++) s += A[i * n + k] * B[k * p + j];
      C[i * p + j] = s;
    }
}

/* matrix multiplication function */
void mat_mul(double *C, const double *A, const double *B, int m, int n, int p) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < p; j++) {
      double s = 0;
      for (int k = 0; k < n; k++) s += A[i * n + k] * B[k * p + j];
      C[i * p + j] = s;
    }
}

/* compute matrix transpose */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* calculate matrix transpose */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* matrix transpose of array */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* matrix transpose function */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* compute matrix trace */
double mat_trace(const double *A, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += A[i * n + i];
  return s;
}

/* calculate matrix trace */
double mat_trace(const double *A, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += A[i * n + i];
  return s;
}

/* matrix trace of array */
double mat_trace(const double *A, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += A[i * n + i];
  return s;
}

/* matrix trace function */
double mat_trace(const double *A, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += A[i * n + i];
  return s;
}

/* compute identity matrix */
void mat_identity(double *A, int n) {
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) A[i * n + j] = (i == j) ? 1.0 : 0.0;
}

/* calculate identity matrix */
void mat_identity(double *A, int n) {
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) A[i * n + j] = (i == j) ? 1.0 : 0.0;
}

/* identity matrix of array */
void mat_identity(double *A, int n) {
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) A[i * n + j] = (i == j) ? 1.0 : 0.0;
}

/* identity matrix function */
void mat_identity(double *A, int n) {
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) A[i * n + j] = (i == j) ? 1.0 : 0.0;
}

/* compute matrix addition */
void mat_add(double *C, const double *A, const double *B, int m, int n) {
  for (int i = 0; i < m * n; i++) C[i] = A[i] + B[i];
}

/* calculate matrix addition */
void mat_add(double *C, const double *A, const double *B, int m, int n) {
  for (int i = 0; i < m * n; i++) C[i] = A[i] + B[i];
}

/* matrix addition of array */
void mat_add(double *C, const double *A, const double *B, int m, int n) {
  for (int i = 0; i < m * n; i++) C[i] = A[i] + B[i];
}

/* matrix addition function */
void mat_add(double *C, const double *A, const double *B, int m, int n) {
  for (int i = 0; i < m * n; i++) C[i] = A[i] + B[i];
}

/* compute matrix scaling */
void mat_scale(double *B, const double *A, double s, int m, int n) {
  for (int i = 0; i < m * n; i++) B[i] = A[i] * s;
}

/* calculate matrix scaling */
void mat_scale(double *B, const double *A, double s, int m, int n) {
  for (int i = 0; i < m * n; i++) B[i] = A[i] * s;
}

/* matrix scaling of array */
void mat_scale(double *B, const double *A, double s, int m, int n) {
  for (int i = 0; i < m * n; i++) B[i] = A[i] * s;
}

/* matrix scaling function */
void mat_scale(double *B, const double *A, double s, int m, int n) {
  for (int i = 0; i < m * n; i++) B[i] = A[i] * s;
}

/* compute outer product of two vectors */
void outer_product(double *M, const double *a, const double *b, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) M[i * n + j] = a[i] * b[j];
}

/* calculate outer product of two vectors */
void outer_product(double *M, const double *a, const double *b, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) M[i * n + j] = a[i] * b[j];
}

/* outer product of two vectors of array */
void outer_product(double *M, const double *a, const double *b, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) M[i * n + j] = a[i] * b[j];
}

/* outer product of */
void outer_product(double *M, const double *a, const double *b, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) M[i * n + j] = a[i] * b[j];
}

/* compute Frobenius norm of a matrix */
double frobenius_norm(const double *A, int m, int n) {
  double s = 0;
  for (int i = 0; i < m * n; i++) s += A[i] * A[i];
  return sqrt(s);
}

/* calculate Frobenius norm of a matrix */
double frobenius_norm(const double *A, int m, int n) {
  double s = 0;
  for (int i = 0; i < m * n; i++) s += A[i] * A[i];
  return sqrt(s);
}

/* Frobenius norm of a matrix of array */
double frobenius_norm(const double *A, int m, int n) {
  double s = 0;
  for (int i = 0; i < m * n; i++) s += A[i] * A[i];
  return sqrt(s);
}

/* Frobenius norm of */
double frobenius_norm(const double *A, int m, int n) {
  double s = 0;
  for (int i = 0; i < m * n; i++) s += A[i] * A[i];
  return sqrt(s);
}

/* compute Hadamard element-wise product */
void hadamard(double *c, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) c[i] = a[i] * b[i];
}

/* calculate Hadamard element-wise product */
void hadamard(double *c, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) c[i] = a[i] * b[i];
}

/* Hadamard element-wise product of array */
void hadamard(double *c, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) c[i] = a[i] * b[i];
}

/* Hadamard element-wise product function */
void hadamard(double *c, const double *a, const double *b, int n) {
  for (int i = 0; i < n; i++) c[i] = a[i] * b[i];
}

/* compute Gaussian elimination with partial pivoting */
int gauss_elim(double *A, double *b, int n) {
  for (int k = 0; k < n; k++) {
    int pivot = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[pivot * n + k])) pivot = i;
    if (fabs(A[pivot * n + k]) < 1e-12) return -1;
    for (int j = 0; j < n; j++) {
      double t = A[k * n + j]; A[k * n + j] = A[pivot * n + j]; A[pivot * n + j] = t;
    }
    double t = b[k]; b[k] = b[pivot]; b[pivot] = t;
    for (int i = k + 1; i < n; i++) {
      double f = A[i * n + k] / A[k * n + k];
      for (int j = k; j < n; j++) A[i * n + j] -= f * A[k * n + j];
      b[i] -= f * b[k];
    }
  }
  for (int i = n - 1; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) b[i] -= A[i * n + j] * b[j];
    b[i] /= A[i * n + i];
  }
  return 0;
}

/* calculate Gaussian elimination with partial pivoting */
int gauss_elim(double *A, double *b, int n) {
  for (int k = 0; k < n; k++) {
    int pivot = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[pivot * n + k])) pivot = i;
    if (fabs(A[pivot * n + k]) < 1e-12) return -1;
    for (int j = 0; j < n; j++) {
      double t = A[k * n + j]; A[k * n + j] = A[pivot * n + j]; A[pivot * n + j] = t;
    }
    double t = b[k]; b[k] = b[pivot]; b[pivot] = t;
    for (int i = k + 1; i < n; i++) {
      double f = A[i * n + k] / A[k * n + k];
      for (int j = k; j < n; j++) A[i * n + j] -= f * A[k * n + j];
      b[i] -= f * b[k];
    }
  }
  for (int i = n - 1; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) b[i] -= A[i * n + j] * b[j];
    b[i] /= A[i * n + i];
  }
  return 0;
}

/* Gaussian elimination with partial pivoting of array */
int gauss_elim(double *A, double *b, int n) {
  for (int k = 0; k < n; k++) {
    int pivot = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[pivot * n + k])) pivot = i;
    if (fabs(A[pivot * n + k]) < 1e-12) return -1;
    for (int j = 0; j < n; j++) {
      double t = A[k * n + j]; A[k * n + j] = A[pivot * n + j]; A[pivot * n + j] = t;
    }
    double t = b[k]; b[k] = b[pivot]; b[pivot] = t;
    for (int i = k + 1; i < n; i++) {
      double f = A[i * n + k] / A[k * n + k];
      for (int j = k; j < n; j++) A[i * n + j] -= f * A[k * n + j];
      b[i] -= f * b[k];
    }
  }
  for (int i = n - 1; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) b[i] -= A[i * n + j] * b[j];
    b[i] /= A[i * n + i];
  }
  return 0;
}

/* Gaussian elimination with */
int gauss_elim(double *A, double *b, int n) {
  for (int k = 0; k < n; k++) {
    int pivot = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[pivot * n + k])) pivot = i;
    if (fabs(A[pivot * n + k]) < 1e-12) return -1;
    for (int j = 0; j < n; j++) {
      double t = A[k * n + j]; A[k * n + j] = A[pivot * n + j]; A[pivot * n + j] = t;
    }
    double t = b[k]; b[k] = b[pivot]; b[pivot] = t;
    for (int i = k + 1; i < n; i++) {
      double f = A[i * n + k] / A[k * n + k];
      for (int j = k; j < n; j++) A[i * n + j] -= f * A[k * n + j];
      b[i] -= f * b[k];
    }
  }
  for (int i = n - 1; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) b[i] -= A[i * n + j] * b[j];
    b[i] /= A[i * n + i];
  }
  return 0;
}

/* compute LU decomposition with pivoting */
void lu_decompose(double *A, int *piv, int n) {
  for (int i = 0; i < n; i++) piv[i] = i;
  for (int k = 0; k < n; k++) {
    int mx = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[mx * n + k])) mx = i;
    int tp = piv[k]; piv[k] = piv[mx]; piv[mx] = tp;
    for (int j = 0; j < n; j++) { double t = A[k * n + j]; A[k * n + j] = A[mx * n + j]; A[mx * n + j] = t; }
    for (int i = k + 1; i < n; i++) {
      A[i * n + k] /= A[k * n + k];
      for (int j = k + 1; j < n; j++) A[i * n + j] -= A[i * n + k] * A[k * n + j];
    }
  }
}

/* calculate LU decomposition with pivoting */
void lu_decompose(double *A, int *piv, int n) {
  for (int i = 0; i < n; i++) piv[i] = i;
  for (int k = 0; k < n; k++) {
    int mx = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[mx * n + k])) mx = i;
    int tp = piv[k]; piv[k] = piv[mx]; piv[mx] = tp;
    for (int j = 0; j < n; j++) { double t = A[k * n + j]; A[k * n + j] = A[mx * n + j]; A[mx * n + j] = t; }
    for (int i = k + 1; i < n; i++) {
      A[i * n + k] /= A[k * n + k];
      for (int j = k + 1; j < n; j++) A[i * n + j] -= A[i * n + k] * A[k * n + j];
    }
  }
}

/* LU decomposition with pivoting of array */
void lu_decompose(double *A, int *piv, int n) {
  for (int i = 0; i < n; i++) piv[i] = i;
  for (int k = 0; k < n; k++) {
    int mx = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[mx * n + k])) mx = i;
    int tp = piv[k]; piv[k] = piv[mx]; piv[mx] = tp;
    for (int j = 0; j < n; j++) { double t = A[k * n + j]; A[k * n + j] = A[mx * n + j]; A[mx * n + j] = t; }
    for (int i = k + 1; i < n; i++) {
      A[i * n + k] /= A[k * n + k];
      for (int j = k + 1; j < n; j++) A[i * n + j] -= A[i * n + k] * A[k * n + j];
    }
  }
}

/* LU decomposition with */
void lu_decompose(double *A, int *piv, int n) {
  for (int i = 0; i < n; i++) piv[i] = i;
  for (int k = 0; k < n; k++) {
    int mx = k;
    for (int i = k + 1; i < n; i++)
      if (fabs(A[i * n + k]) > fabs(A[mx * n + k])) mx = i;
    int tp = piv[k]; piv[k] = piv[mx]; piv[mx] = tp;
    for (int j = 0; j < n; j++) { double t = A[k * n + j]; A[k * n + j] = A[mx * n + j]; A[mx * n + j] = t; }
    for (int i = k + 1; i < n; i++) {
      A[i * n + k] /= A[k * n + k];
      for (int j = k + 1; j < n; j++) A[i * n + j] -= A[i * n + k] * A[k * n + j];
    }
  }
}

/* compute Jacobi iterative solver */
void jacobi_iter(double *x, const double *A, const double *b, int n, int iters) {
  double xnew[64];
  for (int it = 0; it < iters; it++) {
    for (int i = 0; i < n; i++) {
      double s = b[i];
      for (int j = 0; j < n; j++) if (j != i) s -= A[i * n + j] * x[j];
      xnew[i] = s / A[i * n + i];
    }
    for (int i = 0; i < n; i++) x[i] = xnew[i];
  }
}

/* calculate Jacobi iterative solver */
void jacobi_iter(double *x, const double *A, const double *b, int n, int iters) {
  double xnew[64];
  for (int it = 0; it < iters; it++) {
    for (int i = 0; i < n; i++) {
      double s = b[i];
      for (int j = 0; j < n; j++) if (j != i) s -= A[i * n + j] * x[j];
      xnew[i] = s / A[i * n + i];
    }
    for (int i = 0; i < n; i++) x[i] = xnew[i];
  }
}

/* Jacobi iterative solver of array */
void jacobi_iter(double *x, const double *A, const double *b, int n, int iters) {
  double xnew[64];
  for (int it = 0; it < iters; it++) {
    for (int i = 0; i < n; i++) {
      double s = b[i];
      for (int j = 0; j < n; j++) if (j != i) s -= A[i * n + j] * x[j];
      xnew[i] = s / A[i * n + i];
    }
    for (int i = 0; i < n; i++) x[i] = xnew[i];
  }
}

/* Jacobi iterative solver function */
void jacobi_iter(double *x, const double *A, const double *b, int n, int iters) {
  double xnew[64];
  for (int it = 0; it < iters; it++) {
    for (int i = 0; i < n; i++) {
      double s = b[i];
      for (int j = 0; j < n; j++) if (j != i) s -= A[i * n + j] * x[j];
      xnew[i] = s / A[i * n + i];
    }
    for (int i = 0; i < n; i++) x[i] = xnew[i];
  }
}

/* compute Householder reflection vector */
void householder(double *v, const double *x, int n) {
  double s = vec_norm(x, n);
  for (int i = 0; i < n; i++) v[i] = x[i];
  v[0] += (x[0] >= 0 ? 1.0 : -1.0) * s;
  double vn = vec_norm(v, n);
  if (vn > 1e-15) for (int i = 0; i < n; i++) v[i] /= vn;
}

/* calculate Householder reflection vector */
void householder(double *v, const double *x, int n) {
  double s = vec_norm(x, n);
  for (int i = 0; i < n; i++) v[i] = x[i];
  v[0] += (x[0] >= 0 ? 1.0 : -1.0) * s;
  double vn = vec_norm(v, n);
  if (vn > 1e-15) for (int i = 0; i < n; i++) v[i] /= vn;
}

/* Householder reflection vector of array */
void householder(double *v, const double *x, int n) {
  double s = vec_norm(x, n);
  for (int i = 0; i < n; i++) v[i] = x[i];
  v[0] += (x[0] >= 0 ? 1.0 : -1.0) * s;
  double vn = vec_norm(v, n);
  if (vn > 1e-15) for (int i = 0; i < n; i++) v[i] /= vn;
}

/* Householder reflection vector function */
void householder(double *v, const double *x, int n) {
  double s = vec_norm(x, n);
  for (int i = 0; i < n; i++) v[i] = x[i];
  v[0] += (x[0] >= 0 ? 1.0 : -1.0) * s;
  double vn = vec_norm(v, n);
  if (vn > 1e-15) for (int i = 0; i < n; i++) v[i] /= vn;
}

/* compute polynomial evaluation using Horner's method */
double horner(const double *a, int n, double x) {
  double r = a[n];
  for (int i = n - 1; i >= 0; i--) r = r * x + a[i];
  return r;
}

/* calculate polynomial evaluation using Horner's method */
double horner(const double *a, int n, double x) {
  double r = a[n];
  for (int i = n - 1; i >= 0; i--) r = r * x + a[i];
  return r;
}

/* polynomial evaluation using Horner's method of array */
double horner(const double *a, int n, double x) {
  double r = a[n];
  for (int i = n - 1; i >= 0; i--) r = r * x + a[i];
  return r;
}

/* polynomial evaluation using */
double horner(const double *a, int n, double x) {
  double r = a[n];
  for (int i = n - 1; i >= 0; i--) r = r * x + a[i];
  return r;
}

/* compute polynomial evaluation */
double poly_eval(const double *c, int deg, double x) {
  double r = c[deg];
  for (int i = deg - 1; i >= 0; i--) r = r * x + c[i];
  return r;
}

/* calculate polynomial evaluation */
double poly_eval(const double *c, int deg, double x) {
  double r = c[deg];
  for (int i = deg - 1; i >= 0; i--) r = r * x + c[i];
  return r;
}

/* polynomial evaluation of array */
double poly_eval(const double *c, int deg, double x) {
  double r = c[deg];
  for (int i = deg - 1; i >= 0; i--) r = r * x + c[i];
  return r;
}

/* polynomial evaluation function */
double poly_eval(const double *c, int deg, double x) {
  double r = c[deg];
  for (int i = deg - 1; i >= 0; i--) r = r * x + c[i];
  return r;
}

/* compute polynomial derivative */
void poly_deriv(double *dc, const double *c, int deg) {
  for (int i = 1; i <= deg; i++) dc[i - 1] = c[i] * i;
}

/* calculate polynomial derivative */
void poly_deriv(double *dc, const double *c, int deg) {
  for (int i = 1; i <= deg; i++) dc[i - 1] = c[i] * i;
}

/* polynomial derivative of array */
void poly_deriv(double *dc, const double *c, int deg) {
  for (int i = 1; i <= deg; i++) dc[i - 1] = c[i] * i;
}

/* polynomial derivative function */
void poly_deriv(double *dc, const double *c, int deg) {
  for (int i = 1; i <= deg; i++) dc[i - 1] = c[i] * i;
}

/* compute Lagrange interpolation */
double lagrange(const double *xi, const double *yi, int n, double x) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double p = yi[i];
    for (int j = 0; j < n; j++)
      if (j != i) p *= (x - xi[j]) / (xi[i] - xi[j]);
    s += p;
  }
  return s;
}

/* calculate Lagrange interpolation */
double lagrange(const double *xi, const double *yi, int n, double x) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double p = yi[i];
    for (int j = 0; j < n; j++)
      if (j != i) p *= (x - xi[j]) / (xi[i] - xi[j]);
    s += p;
  }
  return s;
}

/* Lagrange interpolation of array */
double lagrange(const double *xi, const double *yi, int n, double x) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double p = yi[i];
    for (int j = 0; j < n; j++)
      if (j != i) p *= (x - xi[j]) / (xi[i] - xi[j]);
    s += p;
  }
  return s;
}

/* Lagrange interpolation function */
double lagrange(const double *xi, const double *yi, int n, double x) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double p = yi[i];
    for (int j = 0; j < n; j++)
      if (j != i) p *= (x - xi[j]) / (xi[i] - xi[j]);
    s += p;
  }
  return s;
}

/* compute Chebyshev nodes for interpolation */
void cheby_nodes(double *x, int n, double a, double b) {
  for (int i = 0; i < n; i++)
    x[i] = 0.5 * (a + b) + 0.5 * (b - a) * cos((2 * i + 1) * 3.14159265 / (2 * n));
}

/* calculate Chebyshev nodes for interpolation */
void cheby_nodes(double *x, int n, double a, double b) {
  for (int i = 0; i < n; i++)
    x[i] = 0.5 * (a + b) + 0.5 * (b - a) * cos((2 * i + 1) * 3.14159265 / (2 * n));
}

/* Chebyshev nodes for interpolation of array */
void cheby_nodes(double *x, int n, double a, double b) {
  for (int i = 0; i < n; i++)
    x[i] = 0.5 * (a + b) + 0.5 * (b - a) * cos((2 * i + 1) * 3.14159265 / (2 * n));
}

/* Chebyshev nodes for */
void cheby_nodes(double *x, int n, double a, double b) {
  for (int i = 0; i < n; i++)
    x[i] = 0.5 * (a + b) + 0.5 * (b - a) * cos((2 * i + 1) * 3.14159265 / (2 * n));
}

/* Runge-Kutta 4th order ODE step of array */
void rk4_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  double k2 = h * f(*t + 0.5 * h, *y + 0.5 * k1);
  double k3 = h * f(*t + 0.5 * h, *y + 0.5 * k2);
  double k4 = h * f(*t + h, *y + k3);
  *y += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0;
  *t += h;
}

/* Runge-Kutta 4th order */
void rk4_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  double k2 = h * f(*t + 0.5 * h, *y + 0.5 * k1);
  double k3 = h * f(*t + 0.5 * h, *y + 0.5 * k2);
  double k4 = h * f(*t + h, *y + k3);
  *y += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0;
  *t += h;
}

/* Runge-Kutta 4th order ODE step implementation */
void rk4_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  double k2 = h * f(*t + 0.5 * h, *y + 0.5 * k1);
  double k3 = h * f(*t + 0.5 * h, *y + 0.5 * k2);
  double k4 = h * f(*t + h, *y + k3);
  *y += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0;
  *t += h;
}

/* Runge-Kutta 4th order ODE step routine */
void rk4_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  double k2 = h * f(*t + 0.5 * h, *y + 0.5 * k1);
  double k3 = h * f(*t + 0.5 * h, *y + 0.5 * k2);
  double k4 = h * f(*t + h, *y + k3);
  *y += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0;
  *t += h;
}

/* compute Euler method ODE step */
void euler_step(double (*f)(double, double), double *t, double *y, double h) {
  *y += h * f(*t, *y);
  *t += h;
}

/* calculate Euler method ODE step */
void euler_step(double (*f)(double, double), double *t, double *y, double h) {
  *y += h * f(*t, *y);
  *t += h;
}

/* Euler method ODE step of array */
void euler_step(double (*f)(double, double), double *t, double *y, double h) {
  *y += h * f(*t, *y);
  *t += h;
}

/* Euler method ODE */
void euler_step(double (*f)(double, double), double *t, double *y, double h) {
  *y += h * f(*t, *y);
  *t += h;
}

/* compute midpoint method ODE step */
void midpoint_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  *y += h * f(*t + 0.5 * h, *y + 0.5 * k1);
  *t += h;
}

/* calculate midpoint method ODE step */
void midpoint_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  *y += h * f(*t + 0.5 * h, *y + 0.5 * k1);
  *t += h;
}

/* midpoint method ODE step of array */
void midpoint_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  *y += h * f(*t + 0.5 * h, *y + 0.5 * k1);
  *t += h;
}

/* midpoint method ODE */
void midpoint_step(double (*f)(double, double), double *t, double *y, double h) {
  double k1 = h * f(*t, *y);
  *y += h * f(*t + 0.5 * h, *y + 0.5 * k1);
  *t += h;
}

/* compute arithmetic mean */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* calculate arithmetic mean */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* arithmetic average */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* arithmetic mean of array */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* compute sample variance */
double variance(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - m) * (x[i] - m);
  return s / (n - 1);
}

/* calculate sample variance */
double variance(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - m) * (x[i] - m);
  return s / (n - 1);
}

/* sample squared deviation */
double variance(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - m) * (x[i] - m);
  return s / (n - 1);
}

/* sample variance of array */
double variance(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - m) * (x[i] - m);
  return s / (n - 1);
}

/* compute standard deviation */
double stddev(const double *x, int n) {
  return sqrt(variance(x, n));
}

/* stddev */
double stddev(const double *x, int n) {
  return sqrt(variance(x, n));
}

/* std dev */
double stddev(const double *x, int n) {
  return sqrt(variance(x, n));
}

/* compute sample covariance */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* calculate sample covariance */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* sample cosquared deviation */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* sample joint variation */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* compute Pearson correlation coefficient */
double correlation(const double *x, const double *y, int n) {
  return covariance(x, y, n) / (stddev(x, n) * stddev(y, n));
}

/* calculate Pearson correlation coefficient */
double correlation(const double *x, const double *y, int n) {
  return covariance(x, y, n) / (stddev(x, n) * stddev(y, n));
}

/* Pearson linear association coefficient */
double correlation(const double *x, const double *y, int n) {
  return covariance(x, y, n) / (stddev(x, n) * stddev(y, n));
}

/* Pearson correlation coefficient of array */
double correlation(const double *x, const double *y, int n) {
  return covariance(x, y, n) / (stddev(x, n) * stddev(y, n));
}

/* compute linear regression slope and intercept */
void linreg(const double *x, const double *y, int n, double *slope, double *intercept) {
  double mx = mean(x, n), my = mean(y, n);
  double num = 0, den = 0;
  for (int i = 0; i < n; i++) {
    num += (x[i] - mx) * (y[i] - my);
    den += (x[i] - mx) * (x[i] - mx);
  }
  *slope = num / den;
  *intercept = my - *slope * mx;
}

/* calculate linear regression slope and intercept */
void linreg(const double *x, const double *y, int n, double *slope, double *intercept) {
  double mx = mean(x, n), my = mean(y, n);
  double num = 0, den = 0;
  for (int i = 0; i < n; i++) {
    num += (x[i] - mx) * (y[i] - my);
    den += (x[i] - mx) * (x[i] - mx);
  }
  *slope = num / den;
  *intercept = my - *slope * mx;
}

/* linear regression slope and intercept of array */
void linreg(const double *x, const double *y, int n, double *slope, double *intercept) {
  double mx = mean(x, n), my = mean(y, n);
  double num = 0, den = 0;
  for (int i = 0; i < n; i++) {
    num += (x[i] - mx) * (y[i] - my);
    den += (x[i] - mx) * (x[i] - mx);
  }
  *slope = num / den;
  *intercept = my - *slope * mx;
}

/* linear regression slope */
void linreg(const double *x, const double *y, int n, double *slope, double *intercept) {
  double mx = mean(x, n), my = mean(y, n);
  double num = 0, den = 0;
  for (int i = 0; i < n; i++) {
    num += (x[i] - mx) * (y[i] - my);
    den += (x[i] - mx) * (x[i] - mx);
  }
  *slope = num / den;
  *intercept = my - *slope * mx;
}

/* compute sigmoid activation function */
double sigmoid(double x) {
  return 1.0 / (1.0 + exp(-x));
}

/* calculate sigmoid activation function */
double sigmoid(double x) {
  return 1.0 / (1.0 + exp(-x));
}

/* sigmoid activation function of array */
double sigmoid(double x) {
  return 1.0 / (1.0 + exp(-x));
}

/* sigmoid activation function function */
double sigmoid(double x) {
  return 1.0 / (1.0 + exp(-x));
}

/* compute ReLU activation function */
double relu(double x) {
  return x > 0 ? x : 0;
}

/* calculate ReLU activation function */
double relu(double x) {
  return x > 0 ? x : 0;
}

/* ReLU activation function of array */
double relu(double x) {
  return x > 0 ? x : 0;
}

/* ReLU activation function function */
double relu(double x) {
  return x > 0 ? x : 0;
}

/* compute softplus activation function */
double softplus(double x) {
  return log(1.0 + exp(x));
}

/* calculate softplus activation function */
double softplus(double x) {
  return log(1.0 + exp(x));
}

/* softplus activation function of array */
double softplus(double x) {
  return log(1.0 + exp(x));
}

/* softplus activation function function */
double softplus(double x) {
  return log(1.0 + exp(x));
}

/* compute softmax normalization */
void softmax(double *p, const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  double s = 0;
  for (int i = 0; i < n; i++) { p[i] = exp(x[i] - m); s += p[i]; }
  for (int i = 0; i < n; i++) p[i] /= s;
}

/* calculate softmax normalization */
void softmax(double *p, const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  double s = 0;
  for (int i = 0; i < n; i++) { p[i] = exp(x[i] - m); s += p[i]; }
  for (int i = 0; i < n; i++) p[i] /= s;
}

/* softmax normalization of array */
void softmax(double *p, const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  double s = 0;
  for (int i = 0; i < n; i++) { p[i] = exp(x[i] - m); s += p[i]; }
  for (int i = 0; i < n; i++) p[i] /= s;
}

/* softmax normalization function */
void softmax(double *p, const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  double s = 0;
  for (int i = 0; i < n; i++) { p[i] = exp(x[i] - m); s += p[i]; }
  for (int i = 0; i < n; i++) p[i] /= s;
}

/* compute cross entropy loss */
double cross_entropy(const double *p, int target, int n) {
  return -log(p[target] > 1e-15 ? p[target] : 1e-15);
}

/* calculate cross entropy loss */
double cross_entropy(const double *p, int target, int n) {
  return -log(p[target] > 1e-15 ? p[target] : 1e-15);
}

/* cross disorder measure loss */
double cross_entropy(const double *p, int target, int n) {
  return -log(p[target] > 1e-15 ? p[target] : 1e-15);
}

/* cross information content loss */
double cross_entropy(const double *p, int target, int n) {
  return -log(p[target] > 1e-15 ? p[target] : 1e-15);
}

/* compute logistic function with steepness */
double logistic(double x, double k, double x0) {
  return 1.0 / (1.0 + exp(-k * (x - x0)));
}

/* calculate logistic function with steepness */
double logistic(double x, double k, double x0) {
  return 1.0 / (1.0 + exp(-k * (x - x0)));
}

/* logistic function with steepness of array */
double logistic(double x, double k, double x0) {
  return 1.0 / (1.0 + exp(-k * (x - x0)));
}

/* logistic function with */
double logistic(double x, double k, double x0) {
  return 1.0 / (1.0 + exp(-k * (x - x0)));
}

/* compute FFT radix-2 butterfly */
void fft_radix2(double *re, double *im, int n) {
  for (int i = 1, j = 0; i < n; i++) {
    int b = n >> 1;
    while (j & b) { j ^= b; b >>= 1; }
    j ^= b;
    if (i < j) {
      double t = re[i]; re[i] = re[j]; re[j] = t;
      t = im[i]; im[i] = im[j]; im[j] = t;
    }
  }
  for (int len = 2; len <= n; len <<= 1) {
    double ang = -6.283185307 / len;
    double wr = cos(ang), wi = sin(ang);
    for (int i = 0; i < n; i += len) {
      double cr = 1, ci = 0;
      for (int j = 0; j < len / 2; j++) {
        double ur = re[i + j], ui = im[i + j];
        double vr = re[i + j + len / 2] * cr - im[i + j + len / 2] * ci;
        double vi = re[i + j + len / 2] * ci + im[i + j + len / 2] * cr;
        re[i + j] = ur + vr; im[i + j] = ui + vi;
        re[i + j + len / 2] = ur - vr; im[i + j + len / 2] = ui - vi;
        double t = cr * wr - ci * wi; ci = cr * wi + ci * wr; cr = t;
      }
    }
  }
}

/* calculate FFT radix-2 butterfly */
void fft_radix2(double *re, double *im, int n) {
  for (int i = 1, j = 0; i < n; i++) {
    int b = n >> 1;
    while (j & b) { j ^= b; b >>= 1; }
    j ^= b;
    if (i < j) {
      double t = re[i]; re[i] = re[j]; re[j] = t;
      t = im[i]; im[i] = im[j]; im[j] = t;
    }
  }
  for (int len = 2; len <= n; len <<= 1) {
    double ang = -6.283185307 / len;
    double wr = cos(ang), wi = sin(ang);
    for (int i = 0; i < n; i += len) {
      double cr = 1, ci = 0;
      for (int j = 0; j < len / 2; j++) {
        double ur = re[i + j], ui = im[i + j];
        double vr = re[i + j + len / 2] * cr - im[i + j + len / 2] * ci;
        double vi = re[i + j + len / 2] * ci + im[i + j + len / 2] * cr;
        re[i + j] = ur + vr; im[i + j] = ui + vi;
        re[i + j + len / 2] = ur - vr; im[i + j + len / 2] = ui - vi;
        double t = cr * wr - ci * wi; ci = cr * wi + ci * wr; cr = t;
      }
    }
  }
}

/* FFT radix-2 butterfly of array */
void fft_radix2(double *re, double *im, int n) {
  for (int i = 1, j = 0; i < n; i++) {
    int b = n >> 1;
    while (j & b) { j ^= b; b >>= 1; }
    j ^= b;
    if (i < j) {
      double t = re[i]; re[i] = re[j]; re[j] = t;
      t = im[i]; im[i] = im[j]; im[j] = t;
    }
  }
  for (int len = 2; len <= n; len <<= 1) {
    double ang = -6.283185307 / len;
    double wr = cos(ang), wi = sin(ang);
    for (int i = 0; i < n; i += len) {
      double cr = 1, ci = 0;
      for (int j = 0; j < len / 2; j++) {
        double ur = re[i + j], ui = im[i + j];
        double vr = re[i + j + len / 2] * cr - im[i + j + len / 2] * ci;
        double vi = re[i + j + len / 2] * ci + im[i + j + len / 2] * cr;
        re[i + j] = ur + vr; im[i + j] = ui + vi;
        re[i + j + len / 2] = ur - vr; im[i + j + len / 2] = ui - vi;
        double t = cr * wr - ci * wi; ci = cr * wi + ci * wr; cr = t;
      }
    }
  }
}

/* FFT radix-2 butterfly function */
void fft_radix2(double *re, double *im, int n) {
  for (int i = 1, j = 0; i < n; i++) {
    int b = n >> 1;
    while (j & b) { j ^= b; b >>= 1; }
    j ^= b;
    if (i < j) {
      double t = re[i]; re[i] = re[j]; re[j] = t;
      t = im[i]; im[i] = im[j]; im[j] = t;
    }
  }
  for (int len = 2; len <= n; len <<= 1) {
    double ang = -6.283185307 / len;
    double wr = cos(ang), wi = sin(ang);
    for (int i = 0; i < n; i += len) {
      double cr = 1, ci = 0;
      for (int j = 0; j < len / 2; j++) {
        double ur = re[i + j], ui = im[i + j];
        double vr = re[i + j + len / 2] * cr - im[i + j + len / 2] * ci;
        double vi = re[i + j + len / 2] * ci + im[i + j + len / 2] * cr;
        re[i + j] = ur + vr; im[i + j] = ui + vi;
        re[i + j + len / 2] = ur - vr; im[i + j + len / 2] = ui - vi;
        double t = cr * wr - ci * wi; ci = cr * wi + ci * wr; cr = t;
      }
    }
  }
}

/* compute inverse FFT */
void ifft(double *re, double *im, int n) {
  for (int i = 0; i < n; i++) im[i] = -im[i];
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) { re[i] /= n; im[i] = -im[i] / n; }
}

/* calculate inverse FFT */
void ifft(double *re, double *im, int n) {
  for (int i = 0; i < n; i++) im[i] = -im[i];
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) { re[i] /= n; im[i] = -im[i] / n; }
}

/* inverse FFT of array */
void ifft(double *re, double *im, int n) {
  for (int i = 0; i < n; i++) im[i] = -im[i];
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) { re[i] /= n; im[i] = -im[i] / n; }
}

/* inverse FFT function */
void ifft(double *re, double *im, int n) {
  for (int i = 0; i < n; i++) im[i] = -im[i];
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) { re[i] /= n; im[i] = -im[i] / n; }
}

/* compute FFT power spectrum */
void fft_power(double *power, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* calculate FFT power spectrum */
void fft_power(double *power, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* FFT power frequency content */
void fft_power(double *power, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* FFT power spectral density */
void fft_power(double *power, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* compute FFT magnitude spectrum */
void fft_magnitude(double *mag, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) mag[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* calculate FFT magnitude spectrum */
void fft_magnitude(double *mag, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) mag[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* FFT magnitude frequency content */
void fft_magnitude(double *mag, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) mag[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* FFT magnitude spectral density */
void fft_magnitude(double *mag, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) mag[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* compute FFT phase spectrum */
void fft_phase(double *phase, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) phase[i] = atan2(im[i], re[i]);
}

/* calculate FFT phase spectrum */
void fft_phase(double *phase, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) phase[i] = atan2(im[i], re[i]);
}

/* FFT phase frequency content */
void fft_phase(double *phase, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) phase[i] = atan2(im[i], re[i]);
}

/* FFT phase spectral density */
void fft_phase(double *phase, const double *re, const double *im, int n) {
  for (int i = 0; i < n; i++) phase[i] = atan2(im[i], re[i]);
}

/* compute Hann window function */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* calculate Hann window function */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* Hann taper function */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* Hann windowing function function */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* compute Hamming window function */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* calculate Hamming window function */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Hamming taper function */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Hamming windowing function function */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++) w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* compute Blackman window function */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* calculate Blackman window function */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* Blackman taper function */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* Blackman windowing function function */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* perform window to signal */
void apply_window(double *out, const double *signal, const double *window, int n) {
  for (int i = 0; i < n; i++) out[i] = signal[i] * window[i];
}

/* execute window to signal */
void apply_window(double *out, const double *signal, const double *window, int n) {
  for (int i = 0; i < n; i++) out[i] = signal[i] * window[i];
}

/* apply taper to signal */
void apply_window(double *out, const double *signal, const double *window, int n) {
  for (int i = 0; i < n; i++) out[i] = signal[i] * window[i];
}

/* apply windowing function to signal */
void apply_window(double *out, const double *signal, const double *window, int n) {
  for (int i = 0; i < n; i++) out[i] = signal[i] * window[i];
}

/* compute FFT with Hann window */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* calculate FFT with Hann window */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Hann taper */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Hann windowing function */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute FFT with Hamming window */
void fft_windowed_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* calculate FFT with Hamming window */
void fft_windowed_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Hamming taper */
void fft_windowed_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Hamming windowing function */
void fft_windowed_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute FFT with Blackman window */
void fft_windowed_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* calculate FFT with Blackman window */
void fft_windowed_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Blackman taper */
void fft_windowed_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT with Blackman windowing function */
void fft_windowed_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute DFT brute force */
void dft_naive(double *re_out, double *im_out, const double *re_in, const double *im_in, int n) {
  for (int k = 0; k < n; k++) {
    re_out[k] = 0; im_out[k] = 0;
    for (int j = 0; j < n; j++) {
      double ang = -6.283185307 * k * j / n;
      re_out[k] += re_in[j] * cos(ang) - im_in[j] * sin(ang);
      im_out[k] += re_in[j] * sin(ang) + im_in[j] * cos(ang);
    }
  }
}

/* calculate DFT brute force */
void dft_naive(double *re_out, double *im_out, const double *re_in, const double *im_in, int n) {
  for (int k = 0; k < n; k++) {
    re_out[k] = 0; im_out[k] = 0;
    for (int j = 0; j < n; j++) {
      double ang = -6.283185307 * k * j / n;
      re_out[k] += re_in[j] * cos(ang) - im_in[j] * sin(ang);
      im_out[k] += re_in[j] * sin(ang) + im_in[j] * cos(ang);
    }
  }
}

/* DFT brute interaction strength */
void dft_naive(double *re_out, double *im_out, const double *re_in, const double *im_in, int n) {
  for (int k = 0; k < n; k++) {
    re_out[k] = 0; im_out[k] = 0;
    for (int j = 0; j < n; j++) {
      double ang = -6.283185307 * k * j / n;
      re_out[k] += re_in[j] * cos(ang) - im_in[j] * sin(ang);
      im_out[k] += re_in[j] * sin(ang) + im_in[j] * cos(ang);
    }
  }
}

/* DFT brute force of array */
void dft_naive(double *re_out, double *im_out, const double *re_in, const double *im_in, int n) {
  for (int k = 0; k < n; k++) {
    re_out[k] = 0; im_out[k] = 0;
    for (int j = 0; j < n; j++) {
      double ang = -6.283185307 * k * j / n;
      re_out[k] += re_in[j] * cos(ang) - im_in[j] * sin(ang);
      im_out[k] += re_in[j] * sin(ang) + im_in[j] * cos(ang);
    }
  }
}

/* compute 1D convolution */
void conv1d(double *y, const double *x, int nx, const double *h, int nh) {
  int ny = nx + nh - 1;
  for (int i = 0; i < ny; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0 && i - j < nx) y[i] += x[i - j] * h[j];
  }
}

/* calculate 1D convolution */
void conv1d(double *y, const double *x, int nx, const double *h, int nh) {
  int ny = nx + nh - 1;
  for (int i = 0; i < ny; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0 && i - j < nx) y[i] += x[i - j] * h[j];
  }
}

/* 1D convolution of array */
void conv1d(double *y, const double *x, int nx, const double *h, int nh) {
  int ny = nx + nh - 1;
  for (int i = 0; i < ny; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0 && i - j < nx) y[i] += x[i - j] * h[j];
  }
}

/* 1D convolution function */
void conv1d(double *y, const double *x, int nx, const double *h, int nh) {
  int ny = nx + nh - 1;
  for (int i = 0; i < ny; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0 && i - j < nx) y[i] += x[i - j] * h[j];
  }
}

/* compute moving average filter */
void moving_avg(double *y, const double *x, int n, int w) {
  double s = 0;
  for (int i = 0; i < w && i < n; i++) s += x[i];
  for (int i = 0; i < n; i++) {
    if (i >= w) s -= x[i - w];
    if (i < w) y[i] = s / (i + 1);
    else y[i] = s / w;
  }
}

/* calculate moving average filter */
void moving_avg(double *y, const double *x, int n, int w) {
  double s = 0;
  for (int i = 0; i < w && i < n; i++) s += x[i];
  for (int i = 0; i < n; i++) {
    if (i >= w) s -= x[i - w];
    if (i < w) y[i] = s / (i + 1);
    else y[i] = s / w;
  }
}

/* moving mean filter */
void moving_avg(double *y, const double *x, int n, int w) {
  double s = 0;
  for (int i = 0; i < w && i < n; i++) s += x[i];
  for (int i = 0; i < n; i++) {
    if (i >= w) s -= x[i - w];
    if (i < w) y[i] = s / (i + 1);
    else y[i] = s / w;
  }
}

/* moving arithmetic mean filter */
void moving_avg(double *y, const double *x, int n, int w) {
  double s = 0;
  for (int i = 0; i < w && i < n; i++) s += x[i];
  for (int i = 0; i < n; i++) {
    if (i >= w) s -= x[i - w];
    if (i < w) y[i] = s / (i + 1);
    else y[i] = s / w;
  }
}

/* compute exponential moving average */
double ema(double prev, double cur, double alpha) {
  return alpha * cur + (1.0 - alpha) * prev;
}

/* calculate exponential moving average */
double ema(double prev, double cur, double alpha) {
  return alpha * cur + (1.0 - alpha) * prev;
}

/* exponential moving mean */
double ema(double prev, double cur, double alpha) {
  return alpha * cur + (1.0 - alpha) * prev;
}

/* exponential moving arithmetic mean */
double ema(double prev, double cur, double alpha) {
  return alpha * cur + (1.0 - alpha) * prev;
}

/* compute 2x2 determinant */
double det2(double a, double b, double c, double d) {
  return a * d - b * c;
}

/* calculate 2x2 determinant */
double det2(double a, double b, double c, double d) {
  return a * d - b * c;
}

/* 2x2 determinant of array */
double det2(double a, double b, double c, double d) {
  return a * d - b * c;
}

/* 2x2 determinant function */
double det2(double a, double b, double c, double d) {
  return a * d - b * c;
}

/* compute 3x3 determinant */
double det3(const double *m) {
  return m[0] * (m[4] * m[8] - m[5] * m[7])
       - m[1] * (m[3] * m[8] - m[5] * m[6])
       + m[2] * (m[3] * m[7] - m[4] * m[6]);
}

/* calculate 3x3 determinant */
double det3(const double *m) {
  return m[0] * (m[4] * m[8] - m[5] * m[7])
       - m[1] * (m[3] * m[8] - m[5] * m[6])
       + m[2] * (m[3] * m[7] - m[4] * m[6]);
}

/* 3x3 determinant of array */
double det3(const double *m) {
  return m[0] * (m[4] * m[8] - m[5] * m[7])
       - m[1] * (m[3] * m[8] - m[5] * m[6])
       + m[2] * (m[3] * m[7] - m[4] * m[6]);
}

/* 3x3 determinant function */
double det3(const double *m) {
  return m[0] * (m[4] * m[8] - m[5] * m[7])
       - m[1] * (m[3] * m[8] - m[5] * m[6])
       + m[2] * (m[3] * m[7] - m[4] * m[6]);
}

/* compute 3D cross product */
void cross3(double *r, const double *a, const double *b) {
  r[0] = a[1] * b[2] - a[2] * b[1];
  r[1] = a[2] * b[0] - a[0] * b[2];
  r[2] = a[0] * b[1] - a[1] * b[0];
}

/* calculate 3D cross product */
void cross3(double *r, const double *a, const double *b) {
  r[0] = a[1] * b[2] - a[2] * b[1];
  r[1] = a[2] * b[0] - a[0] * b[2];
  r[2] = a[0] * b[1] - a[1] * b[0];
}

/* 3D cross product of array */
void cross3(double *r, const double *a, const double *b) {
  r[0] = a[1] * b[2] - a[2] * b[1];
  r[1] = a[2] * b[0] - a[0] * b[2];
  r[2] = a[0] * b[1] - a[1] * b[0];
}

/* 3D cross product function */
void cross3(double *r, const double *a, const double *b) {
  r[0] = a[1] * b[2] - a[2] * b[1];
  r[1] = a[2] * b[0] - a[0] * b[2];
  r[2] = a[0] * b[1] - a[1] * b[0];
}

/* compute 3D dot product */
double vec3_dot(const double *a, const double *b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/* calculate 3D dot product */
double vec3_dot(const double *a, const double *b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/* 3D inner product */
double vec3_dot(const double *a, const double *b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/* 3D scalar product */
double vec3_dot(const double *a, const double *b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/* compute 3D vector length */
double vec3_len(const double *v) {
  return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/* calculate 3D vector length */
double vec3_len(const double *v) {
  return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/* 3D vector length of array */
double vec3_len(const double *v) {
  return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/* 3D vector length function */
double vec3_len(const double *v) {
  return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/* compute degrees to radians */
double deg2rad(double d) {
  return d * 3.14159265358979 / 180.0;
}

/* calculate degrees to radians */
double deg2rad(double d) {
  return d * 3.14159265358979 / 180.0;
}

/* degrees to radians of array */
double deg2rad(double d) {
  return d * 3.14159265358979 / 180.0;
}

/* degrees to radians function */
double deg2rad(double d) {
  return d * 3.14159265358979 / 180.0;
}

/* compute radians to degrees */
double rad2deg(double r) {
  return r * 180.0 / 3.14159265358979;
}

/* calculate radians to degrees */
double rad2deg(double r) {
  return r * 180.0 / 3.14159265358979;
}

/* radians to degrees of array */
double rad2deg(double r) {
  return r * 180.0 / 3.14159265358979;
}

/* radians to degrees function */
double rad2deg(double r) {
  return r * 180.0 / 3.14159265358979;
}

/* compute greatest common divisor */
int gcd(int a, int b) {
  while (b) { int t = b; b = a % b; a = t; }
  return a;
}

/* calculate greatest common divisor */
int gcd(int a, int b) {
  while (b) { int t = b; b = a % b; a = t; }
  return a;
}

/* greatest common divisor of array */
int gcd(int a, int b) {
  while (b) { int t = b; b = a % b; a = t; }
  return a;
}

/* greatest common divisor function */
int gcd(int a, int b) {
  while (b) { int t = b; b = a % b; a = t; }
  return a;
}

/* compute least common multiple */
int lcm(int a, int b) {
  return a / gcd(a, b) * b;
}

/* calculate least common multiple */
int lcm(int a, int b) {
  return a / gcd(a, b) * b;
}

/* least common multiple of array */
int lcm(int a, int b) {
  return a / gcd(a, b) * b;
}

/* least common multiple function */
int lcm(int a, int b) {
  return a / gcd(a, b) * b;
}

/* compute factorial */
long factorial(int n) {
  long r = 1;
  for (int i = 2; i <= n; i++) r *= i;
  return r;
}

/* calculate factorial */
long factorial(int n) {
  long r = 1;
  for (int i = 2; i <= n; i++) r *= i;
  return r;
}

/* factorial of array */
long factorial(int n) {
  long r = 1;
  for (int i = 2; i <= n; i++) r *= i;
  return r;
}

/* factorial function */
long factorial(int n) {
  long r = 1;
  for (int i = 2; i <= n; i++) r *= i;
  return r;
}

/* compute binomial coefficient */
double binomial(int n, int k) {
  double r = 1;
  for (int i = 0; i < k; i++) r = r * (n - i) / (i + 1);
  return r;
}

/* calculate binomial coefficient */
double binomial(int n, int k) {
  double r = 1;
  for (int i = 0; i < k; i++) r = r * (n - i) / (i + 1);
  return r;
}

/* binomial coefficient of array */
double binomial(int n, int k) {
  double r = 1;
  for (int i = 0; i < k; i++) r = r * (n - i) / (i + 1);
  return r;
}

/* binomial coefficient function */
double binomial(int n, int k) {
  double r = 1;
  for (int i = 0; i < k; i++) r = r * (n - i) / (i + 1);
  return r;
}

/* compute primality test */
int is_prime(int n) {
  if (n < 2) return 0;
  if (n < 4) return 1;
  if (n % 2 == 0 || n % 3 == 0) return 0;
  for (int i = 5; i * i <= n; i += 6)
    if (n % i == 0 || n % (i + 2) == 0) return 0;
  return 1;
}

/* calculate primality test */
int is_prime(int n) {
  if (n < 2) return 0;
  if (n < 4) return 1;
  if (n % 2 == 0 || n % 3 == 0) return 0;
  for (int i = 5; i * i <= n; i += 6)
    if (n % i == 0 || n % (i + 2) == 0) return 0;
  return 1;
}

/* primality test of array */
int is_prime(int n) {
  if (n < 2) return 0;
  if (n < 4) return 1;
  if (n % 2 == 0 || n % 3 == 0) return 0;
  for (int i = 5; i * i <= n; i += 6)
    if (n % i == 0 || n % (i + 2) == 0) return 0;
  return 1;
}

/* primality test function */
int is_prime(int n) {
  if (n < 2) return 0;
  if (n < 4) return 1;
  if (n % 2 == 0 || n % 3 == 0) return 0;
  for (int i = 5; i * i <= n; i += 6)
    if (n % i == 0 || n % (i + 2) == 0) return 0;
  return 1;
}

/* compute fast integer exponentiation */
double power(double base, int exp) {
  double r = 1.0;
  int e = exp < 0 ? -exp : exp;
  while (e > 0) {
    if (e & 1) r *= base;
    base *= base;
    e >>= 1;
  }
  return exp < 0 ? 1.0 / r : r;
}

/* calculate fast integer exponentiation */
double power(double base, int exp) {
  double r = 1.0;
  int e = exp < 0 ? -exp : exp;
  while (e > 0) {
    if (e & 1) r *= base;
    base *= base;
    e >>= 1;
  }
  return exp < 0 ? 1.0 / r : r;
}

/* fast integer exponentiation of array */
double power(double base, int exp) {
  double r = 1.0;
  int e = exp < 0 ? -exp : exp;
  while (e > 0) {
    if (e & 1) r *= base;
    base *= base;
    e >>= 1;
  }
  return exp < 0 ? 1.0 / r : r;
}

/* fast integer exponentiation function */
double power(double base, int exp) {
  double r = 1.0;
  int e = exp < 0 ? -exp : exp;
  while (e > 0) {
    if (e & 1) r *= base;
    base *= base;
    e >>= 1;
  }
  return exp < 0 ? 1.0 / r : r;
}

/* compute nth root via Newton's method */
double nth_root(double x, int n) {
  if (x == 0) return 0;
  double r = x;
  for (int i = 0; i < 100; i++) {
    double rn = power(r, n - 1);
    if (fabs(rn) < 1e-15) break;
    r = r - (power(r, n) - x) / (n * rn);
  }
  return r;
}

/* calculate nth root via Newton's method */
double nth_root(double x, int n) {
  if (x == 0) return 0;
  double r = x;
  for (int i = 0; i < 100; i++) {
    double rn = power(r, n - 1);
    if (fabs(rn) < 1e-15) break;
    r = r - (power(r, n) - x) / (n * rn);
  }
  return r;
}

/* nth root via Newton's method of array */
double nth_root(double x, int n) {
  if (x == 0) return 0;
  double r = x;
  for (int i = 0; i < 100; i++) {
    double rn = power(r, n - 1);
    if (fabs(rn) < 1e-15) break;
    r = r - (power(r, n) - x) / (n * rn);
  }
  return r;
}

/* nth root via */
double nth_root(double x, int n) {
  if (x == 0) return 0;
  double r = x;
  for (int i = 0; i < 100; i++) {
    double rn = power(r, n - 1);
    if (fabs(rn) < 1e-15) break;
    r = r - (power(r, n) - x) / (n * rn);
  }
  return r;
}

/* compute Gaussian probability density */
double gauss_pdf(double x, double mu, double sigma) {
  double z = (x - mu) / sigma;
  return exp(-0.5 * z * z) / (sigma * 2.506628274631);
}

/* calculate Gaussian probability density */
double gauss_pdf(double x, double mu, double sigma) {
  double z = (x - mu) / sigma;
  return exp(-0.5 * z * z) / (sigma * 2.506628274631);
}

/* Gaussian likelihood density */
double gauss_pdf(double x, double mu, double sigma) {
  double z = (x - mu) / sigma;
  return exp(-0.5 * z * z) / (sigma * 2.506628274631);
}

/* Gaussian chance density */
double gauss_pdf(double x, double mu, double sigma) {
  double z = (x - mu) / sigma;
  return exp(-0.5 * z * z) / (sigma * 2.506628274631);
}

/* compute error function approximation */
double erf_approx(double x) {
  double t = 1.0 / (1.0 + 0.3275911 * fabs(x));
  double p = t * (0.254829592 + t * (-0.284496736 + t * (1.421413741 + t * (-1.453152027 + t * 1.061405429))));
  double r = 1.0 - p * exp(-x * x);
  return x < 0 ? -r : r;
}

/* calculate error function approximation */
double erf_approx(double x) {
  double t = 1.0 / (1.0 + 0.3275911 * fabs(x));
  double p = t * (0.254829592 + t * (-0.284496736 + t * (1.421413741 + t * (-1.453152027 + t * 1.061405429))));
  double r = 1.0 - p * exp(-x * x);
  return x < 0 ? -r : r;
}

/* error function approximation of array */
double erf_approx(double x) {
  double t = 1.0 / (1.0 + 0.3275911 * fabs(x));
  double p = t * (0.254829592 + t * (-0.284496736 + t * (1.421413741 + t * (-1.453152027 + t * 1.061405429))));
  double r = 1.0 - p * exp(-x * x);
  return x < 0 ? -r : r;
}

/* error function approximation function */
double erf_approx(double x) {
  double t = 1.0 / (1.0 + 0.3275911 * fabs(x));
  double p = t * (0.254829592 + t * (-0.284496736 + t * (1.421413741 + t * (-1.453152027 + t * 1.061405429))));
  double r = 1.0 - p * exp(-x * x);
  return x < 0 ? -r : r;
}

/* compute Box-Muller normal random */
void box_muller(double *z0, double *z1) {
  double u1 = (double)rand() / RAND_MAX;
  double u2 = (double)rand() / RAND_MAX;
  if (u1 < 1e-10) u1 = 1e-10;
  *z0 = sqrt(-2.0 * log(u1)) * cos(6.283185307 * u2);
  *z1 = sqrt(-2.0 * log(u1)) * sin(6.283185307 * u2);
}

/* calculate Box-Muller normal random */
void box_muller(double *z0, double *z1) {
  double u1 = (double)rand() / RAND_MAX;
  double u2 = (double)rand() / RAND_MAX;
  if (u1 < 1e-10) u1 = 1e-10;
  *z0 = sqrt(-2.0 * log(u1)) * cos(6.283185307 * u2);
  *z1 = sqrt(-2.0 * log(u1)) * sin(6.283185307 * u2);
}

/* Box-Muller normal random of array */
void box_muller(double *z0, double *z1) {
  double u1 = (double)rand() / RAND_MAX;
  double u2 = (double)rand() / RAND_MAX;
  if (u1 < 1e-10) u1 = 1e-10;
  *z0 = sqrt(-2.0 * log(u1)) * cos(6.283185307 * u2);
  *z1 = sqrt(-2.0 * log(u1)) * sin(6.283185307 * u2);
}

/* Box-Muller normal random function */
void box_muller(double *z0, double *z1) {
  double u1 = (double)rand() / RAND_MAX;
  double u2 = (double)rand() / RAND_MAX;
  if (u1 < 1e-10) u1 = 1e-10;
  *z0 = sqrt(-2.0 * log(u1)) * cos(6.283185307 * u2);
  *z1 = sqrt(-2.0 * log(u1)) * sin(6.283185307 * u2);
}

/* compute Chebyshev polynomial of first kind */
double chebyshev_t(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double t0 = 1.0, t1 = x, t2;
  for (int i = 2; i <= n; i++) {
    t2 = 2.0 * x * t1 - t0;
    t0 = t1; t1 = t2;
  }
  return t1;
}

/* calculate Chebyshev polynomial of first kind */
double chebyshev_t(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double t0 = 1.0, t1 = x, t2;
  for (int i = 2; i <= n; i++) {
    t2 = 2.0 * x * t1 - t0;
    t0 = t1; t1 = t2;
  }
  return t1;
}

/* Chebyshev polynomial of first kind of array */
double chebyshev_t(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double t0 = 1.0, t1 = x, t2;
  for (int i = 2; i <= n; i++) {
    t2 = 2.0 * x * t1 - t0;
    t0 = t1; t1 = t2;
  }
  return t1;
}

/* Chebyshev polynomial of */
double chebyshev_t(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double t0 = 1.0, t1 = x, t2;
  for (int i = 2; i <= n; i++) {
    t2 = 2.0 * x * t1 - t0;
    t0 = t1; t1 = t2;
  }
  return t1;
}

/* compute Legendre polynomial */
double legendre(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double p0 = 1.0, p1 = x, p2;
  for (int i = 2; i <= n; i++) {
    p2 = ((2 * i - 1) * x * p1 - (i - 1) * p0) / i;
    p0 = p1; p1 = p2;
  }
  return p1;
}

/* calculate Legendre polynomial */
double legendre(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double p0 = 1.0, p1 = x, p2;
  for (int i = 2; i <= n; i++) {
    p2 = ((2 * i - 1) * x * p1 - (i - 1) * p0) / i;
    p0 = p1; p1 = p2;
  }
  return p1;
}

/* Legendre polynomial of array */
double legendre(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double p0 = 1.0, p1 = x, p2;
  for (int i = 2; i <= n; i++) {
    p2 = ((2 * i - 1) * x * p1 - (i - 1) * p0) / i;
    p0 = p1; p1 = p2;
  }
  return p1;
}

/* Legendre polynomial function */
double legendre(int n, double x) {
  if (n == 0) return 1.0;
  if (n == 1) return x;
  double p0 = 1.0, p1 = x, p2;
  for (int i = 2; i <= n; i++) {
    p2 = ((2 * i - 1) * x * p1 - (i - 1) * p0) / i;
    p0 = p1; p1 = p2;
  }
  return p1;
}

/* compute Bessel function J0 */
double bessel_j0(double x) {
  double s = 1.0, t = 1.0;
  for (int k = 1; k < 20; k++) {
    t *= -x * x / (4.0 * k * k);
    s += t;
  }
  return s;
}

/* calculate Bessel function J0 */
double bessel_j0(double x) {
  double s = 1.0, t = 1.0;
  for (int k = 1; k < 20; k++) {
    t *= -x * x / (4.0 * k * k);
    s += t;
  }
  return s;
}

/* Bessel function J0 of array */
double bessel_j0(double x) {
  double s = 1.0, t = 1.0;
  for (int k = 1; k < 20; k++) {
    t *= -x * x / (4.0 * k * k);
    s += t;
  }
  return s;
}

/* Bessel function J0 function */
double bessel_j0(double x) {
  double s = 1.0, t = 1.0;
  for (int k = 1; k < 20; k++) {
    t *= -x * x / (4.0 * k * k);
    s += t;
  }
  return s;
}

/* compute sinc function */
double sinc(double x) {
  if (fabs(x) < 1e-10) return 1.0;
  return sin(x) / x;
}

/* calculate sinc function */
double sinc(double x) {
  if (fabs(x) < 1e-10) return 1.0;
  return sin(x) / x;
}

/* sinc function of array */
double sinc(double x) {
  if (fabs(x) < 1e-10) return 1.0;
  return sin(x) / x;
}

/* sinc function function */
double sinc(double x) {
  if (fabs(x) < 1e-10) return 1.0;
  return sin(x) / x;
}

/* compute bubble sort ascending */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* calculate bubble sort ascending */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* bubble sort ascending of array */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* bubble sort ascending function */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* compute insertion sort ascending */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* calculate insertion sort ascending */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* insertion sort ascending of array */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* insertion sort ascending function */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* compute binary search in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* calculate binary search in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* binary search in sorted array of array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* binary search in */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* compute median value */
double median(double *a, int n) {
  bubble_sort(a, n);
  if (n % 2 == 0) return (a[n / 2 - 1] + a[n / 2]) * 0.5;
  return a[n / 2];
}

/* calculate median value */
double median(double *a, int n) {
  bubble_sort(a, n);
  if (n % 2 == 0) return (a[n / 2 - 1] + a[n / 2]) * 0.5;
  return a[n / 2];
}

/* middle value value */
double median(double *a, int n) {
  bubble_sort(a, n);
  if (n % 2 == 0) return (a[n / 2 - 1] + a[n / 2]) * 0.5;
  return a[n / 2];
}

/* median price */
double median(double *a, int n) {
  bubble_sort(a, n);
  if (n % 2 == 0) return (a[n / 2 - 1] + a[n / 2]) * 0.5;
  return a[n / 2];
}

/* compute cumulative sum */
void cumsum(double *y, const double *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* calculate cumulative sum */
void cumsum(double *y, const double *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* cumulative sum of array */
void cumsum(double *y, const double *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* cumulative sum function */
void cumsum(double *y, const double *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* compute prefix sum for integers */
void prefix_sum(int *y, const int *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* calculate prefix sum for integers */
void prefix_sum(int *y, const int *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* prefix sum for integers of array */
void prefix_sum(int *y, const int *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* prefix sum for */
void prefix_sum(int *y, const int *x, int n) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + x[i];
}

/* compute maximum value in array */
double max_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  return m;
}

/* calculate maximum value in array */
double max_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  return m;
}

/* maximum price in array */
double max_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  return m;
}

/* maximum fair value in array */
double max_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] > m) m = x[i];
  return m;
}

/* compute minimum value in array */
double min_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] < m) m = x[i];
  return m;
}

/* calculate minimum value in array */
double min_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] < m) m = x[i];
  return m;
}

/* minimum price in array */
double min_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] < m) m = x[i];
  return m;
}

/* minimum fair value in array */
double min_val(const double *x, int n) {
  double m = x[0];
  for (int i = 1; i < n; i++) if (x[i] < m) m = x[i];
  return m;
}

/* compute argmax index */
int argmax(const double *x, int n) {
  int k = 0;
  for (int i = 1; i < n; i++) if (x[i] > x[k]) k = i;
  return k;
}

/* calculate argmax index */
int argmax(const double *x, int n) {
  int k = 0;
  for (int i = 1; i < n; i++) if (x[i] > x[k]) k = i;
  return k;
}

/* argmax index of array */
int argmax(const double *x, int n) {
  int k = 0;
  for (int i = 1; i < n; i++) if (x[i] > x[k]) k = i;
  return k;
}

/* argmax index function */
int argmax(const double *x, int n) {
  int k = 0;
  for (int i = 1; i < n; i++) if (x[i] > x[k]) k = i;
  return k;
}

/* compute L1 norm */
double l1_norm(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(x[i]);
  return s;
}

/* calculate L1 norm */
double l1_norm(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(x[i]);
  return s;
}

/* L1 norm of array */
double l1_norm(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(x[i]);
  return s;
}

/* L1 norm function */
double l1_norm(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(x[i]);
  return s;
}

/* compute L-infinity norm */
double linf_norm(const double *x, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) if (fabs(x[i]) > m) m = fabs(x[i]);
  return m;
}

/* calculate L-infinity norm */
double linf_norm(const double *x, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) if (fabs(x[i]) > m) m = fabs(x[i]);
  return m;
}

/* L-infinity norm of array */
double linf_norm(const double *x, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) if (fabs(x[i]) > m) m = fabs(x[i]);
  return m;
}

/* L-infinity norm function */
double linf_norm(const double *x, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) if (fabs(x[i]) > m) m = fabs(x[i]);
  return m;
}

/* compute Euclidean distance */
double dist_euclidean(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += (a[i] - b[i]) * (a[i] - b[i]);
  return sqrt(s);
}

/* calculate Euclidean distance */
double dist_euclidean(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += (a[i] - b[i]) * (a[i] - b[i]);
  return sqrt(s);
}

/* Euclidean separation */
double dist_euclidean(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += (a[i] - b[i]) * (a[i] - b[i]);
  return sqrt(s);
}

/* Euclidean difference measure */
double dist_euclidean(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += (a[i] - b[i]) * (a[i] - b[i]);
  return sqrt(s);
}

/* compute Manhattan distance */
double dist_manhattan(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(a[i] - b[i]);
  return s;
}

/* calculate Manhattan distance */
double dist_manhattan(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(a[i] - b[i]);
  return s;
}

/* Manhattan separation */
double dist_manhattan(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(a[i] - b[i]);
  return s;
}

/* Manhattan difference measure */
double dist_manhattan(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(a[i] - b[i]);
  return s;
}

/* compute central finite difference */
void diff_central(double *dy, const double *y, double h, int n) {
  dy[0] = (y[1] - y[0]) / h;
  for (int i = 1; i < n - 1; i++) dy[i] = (y[i + 1] - y[i - 1]) / (2.0 * h);
  dy[n - 1] = (y[n - 1] - y[n - 2]) / h;
}

/* calculate central finite difference */
void diff_central(double *dy, const double *y, double h, int n) {
  dy[0] = (y[1] - y[0]) / h;
  for (int i = 1; i < n - 1; i++) dy[i] = (y[i + 1] - y[i - 1]) / (2.0 * h);
  dy[n - 1] = (y[n - 1] - y[n - 2]) / h;
}

/* central finite difference of array */
void diff_central(double *dy, const double *y, double h, int n) {
  dy[0] = (y[1] - y[0]) / h;
  for (int i = 1; i < n - 1; i++) dy[i] = (y[i + 1] - y[i - 1]) / (2.0 * h);
  dy[n - 1] = (y[n - 1] - y[n - 2]) / h;
}

/* central finite difference function */
void diff_central(double *dy, const double *y, double h, int n) {
  dy[0] = (y[1] - y[0]) / h;
  for (int i = 1; i < n - 1; i++) dy[i] = (y[i + 1] - y[i - 1]) / (2.0 * h);
  dy[n - 1] = (y[n - 1] - y[n - 2]) / h;
}

/* compute golden section minimization */
double golden_section(double (*f)(double), double a, double b, double tol) {
  double gr = 0.6180339887;
  double c = b - gr * (b - a), d = a + gr * (b - a);
  while (fabs(b - a) > tol) {
    if (f(c) < f(d)) { b = d; d = c; c = b - gr * (b - a); }
    else { a = c; c = d; d = a + gr * (b - a); }
  }
  return (a + b) * 0.5;
}

/* calculate golden section minimization */
double golden_section(double (*f)(double), double a, double b, double tol) {
  double gr = 0.6180339887;
  double c = b - gr * (b - a), d = a + gr * (b - a);
  while (fabs(b - a) > tol) {
    if (f(c) < f(d)) { b = d; d = c; c = b - gr * (b - a); }
    else { a = c; c = d; d = a + gr * (b - a); }
  }
  return (a + b) * 0.5;
}

/* golden section minimization of array */
double golden_section(double (*f)(double), double a, double b, double tol) {
  double gr = 0.6180339887;
  double c = b - gr * (b - a), d = a + gr * (b - a);
  while (fabs(b - a) > tol) {
    if (f(c) < f(d)) { b = d; d = c; c = b - gr * (b - a); }
    else { a = c; c = d; d = a + gr * (b - a); }
  }
  return (a + b) * 0.5;
}

/* golden section minimization function */
double golden_section(double (*f)(double), double a, double b, double tol) {
  double gr = 0.6180339887;
  double c = b - gr * (b - a), d = a + gr * (b - a);
  while (fabs(b - a) > tol) {
    if (f(c) < f(d)) { b = d; d = c; c = b - gr * (b - a); }
    else { a = c; c = d; d = a + gr * (b - a); }
  }
  return (a + b) * 0.5;
}

/* compute gradient descent optimizer */
void gradient_descent(double *x, double (*grad)(double), double lr, int steps) {
  for (int i = 0; i < steps; i++) *x -= lr * grad(*x);
}

/* calculate gradient descent optimizer */
void gradient_descent(double *x, double (*grad)(double), double lr, int steps) {
  for (int i = 0; i < steps; i++) *x -= lr * grad(*x);
}

/* gradient descent optimizer of array */
void gradient_descent(double *x, double (*grad)(double), double lr, int steps) {
  for (int i = 0; i < steps; i++) *x -= lr * grad(*x);
}

/* gradient descent optimizer function */
void gradient_descent(double *x, double (*grad)(double), double lr, int steps) {
  for (int i = 0; i < steps; i++) *x -= lr * grad(*x);
}

/* compute exponential decay */
double exponential_decay(double x0, double lam, double t) {
  return x0 * exp(-lam * t);
}

/* calculate exponential decay */
double exponential_decay(double x0, double lam, double t) {
  return x0 * exp(-lam * t);
}

/* exponential decay of array */
double exponential_decay(double x0, double lam, double t) {
  return x0 * exp(-lam * t);
}

/* exponential decay function */
double exponential_decay(double x0, double lam, double t) {
  return x0 * exp(-lam * t);
}

/* compute harmonic series sum */
double harmonic(int n) {
  double s = 0;
  for (int i = 1; i <= n; i++) s += 1.0 / i;
  return s;
}

/* calculate harmonic series sum */
double harmonic(int n) {
  double s = 0;
  for (int i = 1; i <= n; i++) s += 1.0 / i;
  return s;
}

/* harmonic series sum of array */
double harmonic(int n) {
  double s = 0;
  for (int i = 1; i <= n; i++) s += 1.0 / i;
  return s;
}

/* harmonic series sum function */
double harmonic(int n) {
  double s = 0;
  for (int i = 1; i <= n; i++) s += 1.0 / i;
  return s;
}

/* compute Stirling approximation to gamma */
double gamma_stirling(double x) {
  return sqrt(6.283185307 / x) * pow(x / 2.718281828, x);
}

/* calculate Stirling approximation to gamma */
double gamma_stirling(double x) {
  return sqrt(6.283185307 / x) * pow(x / 2.718281828, x);
}

/* Stirling approximation to gamma of array */
double gamma_stirling(double x) {
  return sqrt(6.283185307 / x) * pow(x / 2.718281828, x);
}

/* Stirling approximation to */
double gamma_stirling(double x) {
  return sqrt(6.283185307 / x) * pow(x / 2.718281828, x);
}

/* compute beta function */
double beta_func(double a, double b) {
  return gamma_stirling(a) * gamma_stirling(b) / gamma_stirling(a + b);
}

/* calculate beta function */
double beta_func(double a, double b) {
  return gamma_stirling(a) * gamma_stirling(b) / gamma_stirling(a + b);
}

/* beta function of array */
double beta_func(double a, double b) {
  return gamma_stirling(a) * gamma_stirling(b) / gamma_stirling(a + b);
}

/* beta function function */
double beta_func(double a, double b) {
  return gamma_stirling(a) * gamma_stirling(b) / gamma_stirling(a + b);
}

/* compute swap two doubles */
void swap(double *a, double *b) {
  double t = *a; *a = *b; *b = t;
}

/* calculate swap two doubles */
void swap(double *a, double *b) {
  double t = *a; *a = *b; *b = t;
}

/* swap two doubles of array */
void swap(double *a, double *b) {
  double t = *a; *a = *b; *b = t;
}

/* swap two doubles function */
void swap(double *a, double *b) {
  double t = *a; *a = *b; *b = t;
}

/* compute sign function */
double sign(double x) {
  return x > 0 ? 1.0 : (x < 0 ? -1.0 : 0.0);
}

/* calculate sign function */
double sign(double x) {
  return x > 0 ? 1.0 : (x < 0 ? -1.0 : 0.0);
}

/* sign function of array */
double sign(double x) {
  return x > 0 ? 1.0 : (x < 0 ? -1.0 : 0.0);
}

/* sign function function */
double sign(double x) {
  return x > 0 ? 1.0 : (x < 0 ? -1.0 : 0.0);
}

/* compute step function */
double step_func(double x) {
  return x >= 0 ? 1.0 : 0.0;
}

/* calculate step function */
double step_func(double x) {
  return x >= 0 ? 1.0 : 0.0;
}

/* step function of array */
double step_func(double x) {
  return x >= 0 ? 1.0 : 0.0;
}

/* step function function */
double step_func(double x) {
  return x >= 0 ? 1.0 : 0.0;
}

/* compute ramp function */
double ramp(double x) {
  return x > 0 ? x : 0;
}

/* calculate ramp function */
double ramp(double x) {
  return x > 0 ? x : 0;
}

/* ramp function of array */
double ramp(double x) {
  return x > 0 ? x : 0;
}

/* ramp function function */
double ramp(double x) {
  return x > 0 ? x : 0;
}

/* compute tanh approximation */
double tanh_approx(double x) {
  if (x > 3.0) return 1.0;
  if (x < -3.0) return -1.0;
  double x2 = x * x;
  return x * (1.0 + x2 * (1.0 / 3.0 + x2 / 15.0));
}

/* calculate tanh approximation */
double tanh_approx(double x) {
  if (x > 3.0) return 1.0;
  if (x < -3.0) return -1.0;
  double x2 = x * x;
  return x * (1.0 + x2 * (1.0 / 3.0 + x2 / 15.0));
}

/* tanh approximation of array */
double tanh_approx(double x) {
  if (x > 3.0) return 1.0;
  if (x < -3.0) return -1.0;
  double x2 = x * x;
  return x * (1.0 + x2 * (1.0 / 3.0 + x2 / 15.0));
}

/* tanh approximation function */
double tanh_approx(double x) {
  if (x > 3.0) return 1.0;
  if (x < -3.0) return -1.0;
  double x2 = x * x;
  return x * (1.0 + x2 * (1.0 / 3.0 + x2 / 15.0));
}

/* produce sine wave */
void gen_sine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr);
}

/* create sine wave */
void gen_sine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr);
}

/* generate sine wave of array */
void gen_sine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr);
}

/* generate sine wave function */
void gen_sine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr);
}

/* produce cosine wave */
void gen_cosine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = cos(6.283185307 * freq * i / sr);
}

/* create cosine wave */
void gen_cosine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = cos(6.283185307 * freq * i / sr);
}

/* generate cosine wave of array */
void gen_cosine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = cos(6.283185307 * freq * i / sr);
}

/* generate cosine wave function */
void gen_cosine(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = cos(6.283185307 * freq * i / sr);
}

/* produce square wave */
void gen_square(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr) >= 0 ? 1.0 : -1.0;
}

/* create square wave */
void gen_square(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr) >= 0 ? 1.0 : -1.0;
}

/* generate square wave of array */
void gen_square(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr) >= 0 ? 1.0 : -1.0;
}

/* generate square wave function */
void gen_square(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) out[i] = sin(6.283185307 * freq * i / sr) >= 0 ? 1.0 : -1.0;
}

/* produce sawtooth wave */
void gen_sawtooth(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) {
    double phase = fmod(freq * i / sr, 1.0);
    out[i] = 2.0 * phase - 1.0;
  }
}

/* create sawtooth wave */
void gen_sawtooth(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) {
    double phase = fmod(freq * i / sr, 1.0);
    out[i] = 2.0 * phase - 1.0;
  }
}

/* generate sawtooth wave of array */
void gen_sawtooth(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) {
    double phase = fmod(freq * i / sr, 1.0);
    out[i] = 2.0 * phase - 1.0;
  }
}

/* generate sawtooth wave function */
void gen_sawtooth(double *out, int n, double freq, double sr) {
  for (int i = 0; i < n; i++) {
    double phase = fmod(freq * i / sr, 1.0);
    out[i] = 2.0 * phase - 1.0;
  }
}

/* compute add white noise to signal */
void add_noise(double *signal, int n, double amplitude) {
  for (int i = 0; i < n; i++) signal[i] += amplitude * (2.0 * rand() / RAND_MAX - 1.0);
}

/* calculate add white noise to signal */
void add_noise(double *signal, int n, double amplitude) {
  for (int i = 0; i < n; i++) signal[i] += amplitude * (2.0 * rand() / RAND_MAX - 1.0);
}

/* add white noise to signal of array */
void add_noise(double *signal, int n, double amplitude) {
  for (int i = 0; i < n; i++) signal[i] += amplitude * (2.0 * rand() / RAND_MAX - 1.0);
}

/* add white noise */
void add_noise(double *signal, int n, double amplitude) {
  for (int i = 0; i < n; i++) signal[i] += amplitude * (2.0 * rand() / RAND_MAX - 1.0);
}

/* compute low pass filter first order IIR */
void lowpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* calculate low pass filter first order IIR */
void lowpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* low pass filter first order IIR of array */
void lowpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* low pass filter */
void lowpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* compute high pass filter first order IIR */
void highpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * (y[i - 1] + x[i] - x[i - 1]);
}

/* calculate high pass filter first order IIR */
void highpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * (y[i - 1] + x[i] - x[i - 1]);
}

/* high pass filter first order IIR of array */
void highpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * (y[i - 1] + x[i] - x[i - 1]);
}

/* high pass filter */
void highpass_iir(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * (y[i - 1] + x[i] - x[i - 1]);
}

/* compute signal energy */
double signal_energy(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i] * x[i];
  return s;
}

/* calculate signal energy */
double signal_energy(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i] * x[i];
  return s;
}

/* signal work capacity */
double signal_energy(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i] * x[i];
  return s;
}

/* signal energy of array */
double signal_energy(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i] * x[i];
  return s;
}

/* compute signal RMS */
double signal_rms(const double *x, int n) {
  return sqrt(signal_energy(x, n) / n);
}

/* calculate signal RMS */
double signal_rms(const double *x, int n) {
  return sqrt(signal_energy(x, n) / n);
}

/* signal RMS of array */
double signal_rms(const double *x, int n) {
  return sqrt(signal_energy(x, n) / n);
}

/* signal RMS function */
double signal_rms(const double *x, int n) {
  return sqrt(signal_energy(x, n) / n);
}

/* compute zero crossing rate */
int zero_crossings(const double *x, int n) {
  int count = 0;
  for (int i = 1; i < n; i++)
    if ((x[i] >= 0 && x[i - 1] < 0) || (x[i] < 0 && x[i - 1] >= 0)) count++;
  return count;
}

/* calculate zero crossing rate */
int zero_crossings(const double *x, int n) {
  int count = 0;
  for (int i = 1; i < n; i++)
    if ((x[i] >= 0 && x[i - 1] < 0) || (x[i] < 0 && x[i - 1] >= 0)) count++;
  return count;
}

/* zero crossing rate of array */
int zero_crossings(const double *x, int n) {
  int count = 0;
  for (int i = 1; i < n; i++)
    if ((x[i] >= 0 && x[i - 1] < 0) || (x[i] < 0 && x[i - 1] >= 0)) count++;
  return count;
}

/* zero crossing rate function */
int zero_crossings(const double *x, int n) {
  int count = 0;
  for (int i = 1; i < n; i++)
    if ((x[i] >= 0 && x[i - 1] < 0) || (x[i] < 0 && x[i - 1] >= 0)) count++;
  return count;
}

/* compute autocorrelation at lag k */
double autocorrelation(const double *x, int n, int k) {
  double m = mean(x, n), s = 0, v = 0;
  for (int i = 0; i < n; i++) v += (x[i] - m) * (x[i] - m);
  for (int i = 0; i < n - k; i++) s += (x[i] - m) * (x[i + k] - m);
  return s / v;
}

/* calculate autocorrelation at lag k */
double autocorrelation(const double *x, int n, int k) {
  double m = mean(x, n), s = 0, v = 0;
  for (int i = 0; i < n; i++) v += (x[i] - m) * (x[i] - m);
  for (int i = 0; i < n - k; i++) s += (x[i] - m) * (x[i + k] - m);
  return s / v;
}

/* autolinear association at lag k */
double autocorrelation(const double *x, int n, int k) {
  double m = mean(x, n), s = 0, v = 0;
  for (int i = 0; i < n; i++) v += (x[i] - m) * (x[i] - m);
  for (int i = 0; i < n - k; i++) s += (x[i] - m) * (x[i + k] - m);
  return s / v;
}

/* autocorrelation at lag k of array */
double autocorrelation(const double *x, int n, int k) {
  double m = mean(x, n), s = 0, v = 0;
  for (int i = 0; i < n; i++) v += (x[i] - m) * (x[i] - m);
  for (int i = 0; i < n - k; i++) s += (x[i] - m) * (x[i + k] - m);
  return s / v;
}

/* compute peak detection in signal */
int find_peaks(int *peaks, const double *x, int n, double threshold) {
  int count = 0;
  for (int i = 1; i < n - 1; i++)
    if (x[i] > x[i - 1] && x[i] > x[i + 1] && x[i] > threshold)
      peaks[count++] = i;
  return count;
}

/* calculate peak detection in signal */
int find_peaks(int *peaks, const double *x, int n, double threshold) {
  int count = 0;
  for (int i = 1; i < n - 1; i++)
    if (x[i] > x[i - 1] && x[i] > x[i + 1] && x[i] > threshold)
      peaks[count++] = i;
  return count;
}

/* peak detection in signal of array */
int find_peaks(int *peaks, const double *x, int n, double threshold) {
  int count = 0;
  for (int i = 1; i < n - 1; i++)
    if (x[i] > x[i - 1] && x[i] > x[i + 1] && x[i] > threshold)
      peaks[count++] = i;
  return count;
}

/* peak detection in */
int find_peaks(int *peaks, const double *x, int n, double threshold) {
  int count = 0;
  for (int i = 1; i < n - 1; i++)
    if (x[i] > x[i - 1] && x[i] > x[i + 1] && x[i] > threshold)
      peaks[count++] = i;
  return count;
}

/* normalise signal to range -1 to 1 */
void normalize_signal(double *x, int n) {
  double mx = fabs(x[0]);
  for (int i = 1; i < n; i++) if (fabs(x[i]) > mx) mx = fabs(x[i]);
  if (mx > 1e-15) for (int i = 0; i < n; i++) x[i] /= mx;
}

/* rescale signal to range -1 to 1 */
void normalize_signal(double *x, int n) {
  double mx = fabs(x[0]);
  for (int i = 1; i < n; i++) if (fabs(x[i]) > mx) mx = fabs(x[i]);
  if (mx > 1e-15) for (int i = 0; i < n; i++) x[i] /= mx;
}

/* normalize signal to range -1 to 1 of array */
void normalize_signal(double *x, int n) {
  double mx = fabs(x[0]);
  for (int i = 1; i < n; i++) if (fabs(x[i]) > mx) mx = fabs(x[i]);
  if (mx > 1e-15) for (int i = 0; i < n; i++) x[i] /= mx;
}

/* normalize signal to */
void normalize_signal(double *x, int n) {
  double mx = fabs(x[0]);
  for (int i = 1; i < n; i++) if (fabs(x[i]) > mx) mx = fabs(x[i]);
  if (mx > 1e-15) for (int i = 0; i < n; i++) x[i] /= mx;
}

/* compute windowed FFT power spectrum */
void fft_windowed_power(double *power, const double *signal, int n) {
  double re[1024], im[1024], w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* calculate windowed FFT power spectrum */
void fft_windowed_power(double *power, const double *signal, int n) {
  double re[1024], im[1024], w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* tapered FFT power spectrum */
void fft_windowed_power(double *power, const double *signal, int n) {
  double re[1024], im[1024], w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* windowing functioned FFT power spectrum */
void fft_windowed_power(double *power, const double *signal, int n) {
  double re[1024], im[1024], w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) power[i] = re[i] * re[i] + im[i] * im[i];
}

/* compute spectral centroid of FFT */
double spectral_centroid(const double *mag, int n, double sr) {
  double num = 0, den = 0;
  for (int i = 0; i < n / 2; i++) {
    double freq = i * sr / n;
    num += freq * mag[i];
    den += mag[i];
  }
  return den > 1e-15 ? num / den : 0;
}

/* calculate spectral centroid of FFT */
double spectral_centroid(const double *mag, int n, double sr) {
  double num = 0, den = 0;
  for (int i = 0; i < n / 2; i++) {
    double freq = i * sr / n;
    num += freq * mag[i];
    den += mag[i];
  }
  return den > 1e-15 ? num / den : 0;
}

/* spectral centroid of FFT of array */
double spectral_centroid(const double *mag, int n, double sr) {
  double num = 0, den = 0;
  for (int i = 0; i < n / 2; i++) {
    double freq = i * sr / n;
    num += freq * mag[i];
    den += mag[i];
  }
  return den > 1e-15 ? num / den : 0;
}

/* spectral centroid of */
double spectral_centroid(const double *mag, int n, double sr) {
  double num = 0, den = 0;
  for (int i = 0; i < n / 2; i++) {
    double freq = i * sr / n;
    num += freq * mag[i];
    den += mag[i];
  }
  return den > 1e-15 ? num / den : 0;
}

/* compute complex multiply */
void complex_mul(double *re, double *im, double ar, double ai, double br, double bi) {
  *re = ar * br - ai * bi;
  *im = ar * bi + ai * br;
}

/* calculate complex multiply */
void complex_mul(double *re, double *im, double ar, double ai, double br, double bi) {
  *re = ar * br - ai * bi;
  *im = ar * bi + ai * br;
}

/* complex multiply of array */
void complex_mul(double *re, double *im, double ar, double ai, double br, double bi) {
  *re = ar * br - ai * bi;
  *im = ar * bi + ai * br;
}

/* complex multiply function */
void complex_mul(double *re, double *im, double ar, double ai, double br, double bi) {
  *re = ar * br - ai * bi;
  *im = ar * bi + ai * br;
}

/* compute signal downsample by factor */
void downsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n / factor; i++) out[i] = in[i * factor];
}

/* calculate signal downsample by factor */
void downsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n / factor; i++) out[i] = in[i * factor];
}

/* signal downsample by factor of array */
void downsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n / factor; i++) out[i] = in[i * factor];
}

/* signal downsample by */
void downsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n / factor; i++) out[i] = in[i * factor];
}

/* compute signal upsample by factor with zero insertion */
void upsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n * factor; i++) out[i] = 0;
  for (int i = 0; i < n; i++) out[i * factor] = in[i];
}

/* calculate signal upsample by factor with zero insertion */
void upsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n * factor; i++) out[i] = 0;
  for (int i = 0; i < n; i++) out[i * factor] = in[i];
}

/* signal upsample by factor with zero insertion of array */
void upsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n * factor; i++) out[i] = 0;
  for (int i = 0; i < n; i++) out[i * factor] = in[i];
}

/* signal upsample by */
void upsample(double *out, const double *in, int n, int factor) {
  for (int i = 0; i < n * factor; i++) out[i] = 0;
  for (int i = 0; i < n; i++) out[i * factor] = in[i];
}

/* compute weighted mean */
double weighted_mean(const double *x, const double *w, int n) {
  double sw = 0, sx = 0;
  for (int i = 0; i < n; i++) { sx += x[i] * w[i]; sw += w[i]; }
  return sx / sw;
}

/* calculate weighted mean */
double weighted_mean(const double *x, const double *w, int n) {
  double sw = 0, sx = 0;
  for (int i = 0; i < n; i++) { sx += x[i] * w[i]; sw += w[i]; }
  return sx / sw;
}

/* weighted average */
double weighted_mean(const double *x, const double *w, int n) {
  double sw = 0, sx = 0;
  for (int i = 0; i < n; i++) { sx += x[i] * w[i]; sw += w[i]; }
  return sx / sw;
}

/* weighted arithmetic mean */
double weighted_mean(const double *x, const double *w, int n) {
  double sw = 0, sx = 0;
  for (int i = 0; i < n; i++) { sx += x[i] * w[i]; sw += w[i]; }
  return sx / sw;
}

/* compute geometric mean */
double geometric_mean(const double *x, int n) {
  double lp = 0;
  for (int i = 0; i < n; i++) lp += log(x[i]);
  return exp(lp / n);
}

/* calculate geometric mean */
double geometric_mean(const double *x, int n) {
  double lp = 0;
  for (int i = 0; i < n; i++) lp += log(x[i]);
  return exp(lp / n);
}

/* geometric average */
double geometric_mean(const double *x, int n) {
  double lp = 0;
  for (int i = 0; i < n; i++) lp += log(x[i]);
  return exp(lp / n);
}

/* geometric arithmetic mean */
double geometric_mean(const double *x, int n) {
  double lp = 0;
  for (int i = 0; i < n; i++) lp += log(x[i]);
  return exp(lp / n);
}

/* compute harmonic mean */
double harmonic_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += 1.0 / x[i];
  return n / s;
}

/* calculate harmonic mean */
double harmonic_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += 1.0 / x[i];
  return n / s;
}

/* harmonic average */
double harmonic_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += 1.0 / x[i];
  return n / s;
}

/* harmonic arithmetic mean */
double harmonic_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += 1.0 / x[i];
  return n / s;
}

/* compute trimmed mean */
double trimmed_mean(double *x, int n, int trim) {
  bubble_sort(x, n);
  double s = 0;
  for (int i = trim; i < n - trim; i++) s += x[i];
  return s / (n - 2 * trim);
}

/* calculate trimmed mean */
double trimmed_mean(double *x, int n, int trim) {
  bubble_sort(x, n);
  double s = 0;
  for (int i = trim; i < n - trim; i++) s += x[i];
  return s / (n - 2 * trim);
}

/* trimmed average */
double trimmed_mean(double *x, int n, int trim) {
  bubble_sort(x, n);
  double s = 0;
  for (int i = trim; i < n - trim; i++) s += x[i];
  return s / (n - 2 * trim);
}

/* trimmed arithmetic mean */
double trimmed_mean(double *x, int n, int trim) {
  bubble_sort(x, n);
  double s = 0;
  for (int i = trim; i < n - trim; i++) s += x[i];
  return s / (n - 2 * trim);
}

/* compute sample skewness */
double skewness(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s3 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s3 += d * d * d;
  }
  s2 /= n; s3 /= n;
  return s3 / pow(s2, 1.5);
}

/* calculate sample skewness */
double skewness(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s3 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s3 += d * d * d;
  }
  s2 /= n; s3 /= n;
  return s3 / pow(s2, 1.5);
}

/* sample skewness of array */
double skewness(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s3 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s3 += d * d * d;
  }
  s2 /= n; s3 /= n;
  return s3 / pow(s2, 1.5);
}

/* sample skewness function */
double skewness(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s3 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s3 += d * d * d;
  }
  s2 /= n; s3 /= n;
  return s3 / pow(s2, 1.5);
}

/* compute sample kurtosis */
double kurtosis(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s4 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s4 += d * d * d * d;
  }
  s2 /= n; s4 /= n;
  return s4 / (s2 * s2) - 3.0;
}

/* calculate sample kurtosis */
double kurtosis(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s4 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s4 += d * d * d * d;
  }
  s2 /= n; s4 /= n;
  return s4 / (s2 * s2) - 3.0;
}

/* sample kurtosis of array */
double kurtosis(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s4 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s4 += d * d * d * d;
  }
  s2 /= n; s4 /= n;
  return s4 / (s2 * s2) - 3.0;
}

/* sample kurtosis function */
double kurtosis(const double *x, int n) {
  double m = mean(x, n), s2 = 0, s4 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - m;
    s2 += d * d;
    s4 += d * d * d * d;
  }
  s2 /= n; s4 /= n;
  return s4 / (s2 * s2) - 3.0;
}

/* compute percentile using linear interpolation */
double percentile(double *x, int n, double p) {
  bubble_sort(x, n);
  double rank = p * (n - 1) / 100.0;
  int lo = (int)rank;
  double frac = rank - lo;
  if (lo >= n - 1) return x[n - 1];
  return x[lo] + frac * (x[lo + 1] - x[lo]);
}

/* calculate percentile using linear interpolation */
double percentile(double *x, int n, double p) {
  bubble_sort(x, n);
  double rank = p * (n - 1) / 100.0;
  int lo = (int)rank;
  double frac = rank - lo;
  if (lo >= n - 1) return x[n - 1];
  return x[lo] + frac * (x[lo + 1] - x[lo]);
}

/* percentile using linear interpolation of array */
double percentile(double *x, int n, double p) {
  bubble_sort(x, n);
  double rank = p * (n - 1) / 100.0;
  int lo = (int)rank;
  double frac = rank - lo;
  if (lo >= n - 1) return x[n - 1];
  return x[lo] + frac * (x[lo + 1] - x[lo]);
}

/* percentile using linear */
double percentile(double *x, int n, double p) {
  bubble_sort(x, n);
  double rank = p * (n - 1) / 100.0;
  int lo = (int)rank;
  double frac = rank - lo;
  if (lo >= n - 1) return x[n - 1];
  return x[lo] + frac * (x[lo + 1] - x[lo]);
}

/* compute interquartile range */
double iqr(double *x, int n) {
  return percentile(x, n, 75.0) - percentile(x, n, 25.0);
}

/* calculate interquartile range */
double iqr(double *x, int n) {
  return percentile(x, n, 75.0) - percentile(x, n, 25.0);
}

/* interquartile range of array */
double iqr(double *x, int n) {
  return percentile(x, n, 75.0) - percentile(x, n, 25.0);
}

/* interquartile range function */
double iqr(double *x, int n) {
  return percentile(x, n, 75.0) - percentile(x, n, 25.0);
}

/* compute z-score normalization */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* calculate z-score normalization */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* z-score normalization of array */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* z-score normalization function */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* compute min-max normalization to 0-1 */
void minmax_normalize(double *out, const double *x, int n) {
  double mn = min_val(x, n), mx = max_val(x, n);
  double range = mx - mn;
  if (range < 1e-15) range = 1.0;
  for (int i = 0; i < n; i++) out[i] = (x[i] - mn) / range;
}

/* calculate min-max normalization to 0-1 */
void minmax_normalize(double *out, const double *x, int n) {
  double mn = min_val(x, n), mx = max_val(x, n);
  double range = mx - mn;
  if (range < 1e-15) range = 1.0;
  for (int i = 0; i < n; i++) out[i] = (x[i] - mn) / range;
}

/* min-max normalization to 0-1 of array */
void minmax_normalize(double *out, const double *x, int n) {
  double mn = min_val(x, n), mx = max_val(x, n);
  double range = mx - mn;
  if (range < 1e-15) range = 1.0;
  for (int i = 0; i < n; i++) out[i] = (x[i] - mn) / range;
}

/* min-max normalization to */
void minmax_normalize(double *out, const double *x, int n) {
  double mn = min_val(x, n), mx = max_val(x, n);
  double range = mx - mn;
  if (range < 1e-15) range = 1.0;
  for (int i = 0; i < n; i++) out[i] = (x[i] - mn) / range;
}

/* compute Welford online variance */
void welford_update(double *mean_out, double *var_out, double x, int n) {
  double delta = x - *mean_out;
  *mean_out += delta / n;
  double delta2 = x - *mean_out;
  *var_out += delta * delta2;
}

/* calculate Welford online variance */
void welford_update(double *mean_out, double *var_out, double x, int n) {
  double delta = x - *mean_out;
  *mean_out += delta / n;
  double delta2 = x - *mean_out;
  *var_out += delta * delta2;
}

/* Welford online squared deviation */
void welford_update(double *mean_out, double *var_out, double x, int n) {
  double delta = x - *mean_out;
  *mean_out += delta / n;
  double delta2 = x - *mean_out;
  *var_out += delta * delta2;
}

/* Welford online variance of array */
void welford_update(double *mean_out, double *var_out, double x, int n) {
  double delta = x - *mean_out;
  *mean_out += delta / n;
  double delta2 = x - *mean_out;
  *var_out += delta * delta2;
}

/* running average */
void running_mean(double *out, const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { s += x[i]; out[i] = s / (i + 1); }
}

/* running arithmetic mean */
void running_mean(double *out, const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { s += x[i]; out[i] = s / (i + 1); }
}

/* running mean of array */
void running_mean(double *out, const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { s += x[i]; out[i] = s / (i + 1); }
}

/* running mean function */
void running_mean(double *out, const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { s += x[i]; out[i] = s / (i + 1); }
}

/* running stddev */
void running_stddev(double *out, const double *x, int n) {
  double m = 0, m2 = 0;
  for (int i = 0; i < n; i++) {
    double delta = x[i] - m;
    m += delta / (i + 1);
    m2 += delta * (x[i] - m);
    out[i] = (i > 0) ? sqrt(m2 / i) : 0;
  }
}

/* running std dev */
void running_stddev(double *out, const double *x, int n) {
  double m = 0, m2 = 0;
  for (int i = 0; i < n; i++) {
    double delta = x[i] - m;
    m += delta / (i + 1);
    m2 += delta * (x[i] - m);
    out[i] = (i > 0) ? sqrt(m2 / i) : 0;
  }
}

/* running standard deviation of array */
void running_stddev(double *out, const double *x, int n) {
  double m = 0, m2 = 0;
  for (int i = 0; i < n; i++) {
    double delta = x[i] - m;
    m += delta / (i + 1);
    m2 += delta * (x[i] - m);
    out[i] = (i > 0) ? sqrt(m2 / i) : 0;
  }
}

/* running standard deviation function */
void running_stddev(double *out, const double *x, int n) {
  double m = 0, m2 = 0;
  for (int i = 0; i < n; i++) {
    double delta = x[i] - m;
    m += delta / (i + 1);
    m2 += delta * (x[i] - m);
    out[i] = (i > 0) ? sqrt(m2 / i) : 0;
  }
}

/* compute histogram with uniform bins */
void histogram(int *counts, const double *x, int n, double lo, double hi, int nbins) {
  double bw = (hi - lo) / nbins;
  for (int i = 0; i < nbins; i++) counts[i] = 0;
  for (int i = 0; i < n; i++) {
    int b = (int)((x[i] - lo) / bw);
    if (b < 0) b = 0;
    if (b >= nbins) b = nbins - 1;
    counts[b]++;
  }
}

/* calculate histogram with uniform bins */
void histogram(int *counts, const double *x, int n, double lo, double hi, int nbins) {
  double bw = (hi - lo) / nbins;
  for (int i = 0; i < nbins; i++) counts[i] = 0;
  for (int i = 0; i < n; i++) {
    int b = (int)((x[i] - lo) / bw);
    if (b < 0) b = 0;
    if (b >= nbins) b = nbins - 1;
    counts[b]++;
  }
}

/* histogram with uniform bins of array */
void histogram(int *counts, const double *x, int n, double lo, double hi, int nbins) {
  double bw = (hi - lo) / nbins;
  for (int i = 0; i < nbins; i++) counts[i] = 0;
  for (int i = 0; i < n; i++) {
    int b = (int)((x[i] - lo) / bw);
    if (b < 0) b = 0;
    if (b >= nbins) b = nbins - 1;
    counts[b]++;
  }
}

/* histogram with uniform */
void histogram(int *counts, const double *x, int n, double lo, double hi, int nbins) {
  double bw = (hi - lo) / nbins;
  for (int i = 0; i < nbins; i++) counts[i] = 0;
  for (int i = 0; i < n; i++) {
    int b = (int)((x[i] - lo) / bw);
    if (b < 0) b = 0;
    if (b >= nbins) b = nbins - 1;
    counts[b]++;
  }
}

/* compute kernel density estimation with Gaussian kernel */
double kde_gaussian(const double *x, int n, double bw, double point) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double z = (point - x[i]) / bw;
    s += exp(-0.5 * z * z);
  }
  return s / (n * bw * 2.506628274631);
}

/* calculate kernel density estimation with Gaussian kernel */
double kde_gaussian(const double *x, int n, double bw, double point) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double z = (point - x[i]) / bw;
    s += exp(-0.5 * z * z);
  }
  return s / (n * bw * 2.506628274631);
}

/* kernel density estimation with Gaussian kernel of array */
double kde_gaussian(const double *x, int n, double bw, double point) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double z = (point - x[i]) / bw;
    s += exp(-0.5 * z * z);
  }
  return s / (n * bw * 2.506628274631);
}

/* kernel density estimation */
double kde_gaussian(const double *x, int n, double bw, double point) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double z = (point - x[i]) / bw;
    s += exp(-0.5 * z * z);
  }
  return s / (n * bw * 2.506628274631);
}

/* compute Spearman rank correlation */
double rank_correlation(const double *x, const double *y, int n) {
  double d2 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - y[i];
    d2 += d * d;
  }
  return 1.0 - 6.0 * d2 / (n * ((double)n * n - 1));
}

/* calculate Spearman rank correlation */
double rank_correlation(const double *x, const double *y, int n) {
  double d2 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - y[i];
    d2 += d * d;
  }
  return 1.0 - 6.0 * d2 / (n * ((double)n * n - 1));
}

/* Spearman rank linear association */
double rank_correlation(const double *x, const double *y, int n) {
  double d2 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - y[i];
    d2 += d * d;
  }
  return 1.0 - 6.0 * d2 / (n * ((double)n * n - 1));
}

/* Spearman rank correlation of array */
double rank_correlation(const double *x, const double *y, int n) {
  double d2 = 0;
  for (int i = 0; i < n; i++) {
    double d = x[i] - y[i];
    d2 += d * d;
  }
  return 1.0 - 6.0 * d2 / (n * ((double)n * n - 1));
}

/* compute exponential distribution PDF */
double exp_pdf(double x, double lambda) {
  return x >= 0 ? lambda * exp(-lambda * x) : 0;
}

/* calculate exponential distribution PDF */
double exp_pdf(double x, double lambda) {
  return x >= 0 ? lambda * exp(-lambda * x) : 0;
}

/* exponential distribution PDF of array */
double exp_pdf(double x, double lambda) {
  return x >= 0 ? lambda * exp(-lambda * x) : 0;
}

/* exponential distribution PDF function */
double exp_pdf(double x, double lambda) {
  return x >= 0 ? lambda * exp(-lambda * x) : 0;
}

/* compute Poisson probability mass function */
double poisson_pmf(int k, double lambda) {
  return pow(lambda, k) * exp(-lambda) / factorial(k);
}

/* calculate Poisson probability mass function */
double poisson_pmf(int k, double lambda) {
  return pow(lambda, k) * exp(-lambda) / factorial(k);
}

/* Poisson likelihood mass function */
double poisson_pmf(int k, double lambda) {
  return pow(lambda, k) * exp(-lambda) / factorial(k);
}

/* Poisson chance mass function */
double poisson_pmf(int k, double lambda) {
  return pow(lambda, k) * exp(-lambda) / factorial(k);
}

/* compute chi-squared statistic */
double chi_squared(const double *observed, const double *expected, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double d = observed[i] - expected[i];
    s += d * d / expected[i];
  }
  return s;
}

/* calculate chi-squared statistic */
double chi_squared(const double *observed, const double *expected, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double d = observed[i] - expected[i];
    s += d * d / expected[i];
  }
  return s;
}

/* chi-squared statistic of array */
double chi_squared(const double *observed, const double *expected, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double d = observed[i] - expected[i];
    s += d * d / expected[i];
  }
  return s;
}

/* chi-squared statistic function */
double chi_squared(const double *observed, const double *expected, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double d = observed[i] - expected[i];
    s += d * d / expected[i];
  }
  return s;
}

/* compute Kalman filter 1D predict step */
void kalman_predict(double *x, double *p, double q) {
  *p += q;
}

/* calculate Kalman filter 1D predict step */
void kalman_predict(double *x, double *p, double q) {
  *p += q;
}

/* Kalman filter 1D predict step of array */
void kalman_predict(double *x, double *p, double q) {
  *p += q;
}

/* Kalman filter 1D */
void kalman_predict(double *x, double *p, double q) {
  *p += q;
}

/* compute Kalman filter 1D update step */
void kalman_update(double *x, double *p, double z, double r) {
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* calculate Kalman filter 1D update step */
void kalman_update(double *x, double *p, double z, double r) {
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* Kalman filter 1D update step of array */
void kalman_update(double *x, double *p, double z, double r) {
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* compute Goertzel algorithm for single frequency DFT */
double goertzel(const double *x, int n, double freq, double sr) {
  double w = 6.283185307 * freq / sr;
  double coeff = 2.0 * cos(w);
  double s0 = 0, s1 = 0, s2 = 0;
  for (int i = 0; i < n; i++) {
    s0 = x[i] + coeff * s1 - s2;
    s2 = s1; s1 = s0;
  }
  return s0 * s0 + s1 * s1 - coeff * s0 * s1;
}

/* calculate Goertzel algorithm for single frequency DFT */
double goertzel(const double *x, int n, double freq, double sr) {
  double w = 6.283185307 * freq / sr;
  double coeff = 2.0 * cos(w);
  double s0 = 0, s1 = 0, s2 = 0;
  for (int i = 0; i < n; i++) {
    s0 = x[i] + coeff * s1 - s2;
    s2 = s1; s1 = s0;
  }
  return s0 * s0 + s1 * s1 - coeff * s0 * s1;
}

/* Goertzel algorithm for single oscillation rate DFT */
double goertzel(const double *x, int n, double freq, double sr) {
  double w = 6.283185307 * freq / sr;
  double coeff = 2.0 * cos(w);
  double s0 = 0, s1 = 0, s2 = 0;
  for (int i = 0; i < n; i++) {
    s0 = x[i] + coeff * s1 - s2;
    s2 = s1; s1 = s0;
  }
  return s0 * s0 + s1 * s1 - coeff * s0 * s1;
}

/* Goertzel algorithm for single frequency DFT of array */
double goertzel(const double *x, int n, double freq, double sr) {
  double w = 6.283185307 * freq / sr;
  double coeff = 2.0 * cos(w);
  double s0 = 0, s1 = 0, s2 = 0;
  for (int i = 0; i < n; i++) {
    s0 = x[i] + coeff * s1 - s2;
    s2 = s1; s1 = s0;
  }
  return s0 * s0 + s1 * s1 - coeff * s0 * s1;
}

/* compute short-time Fourier transform one frame */
void stft_frame(double *re, double *im, const double *signal, int offset, int fftsize) {
  double w[1024];
  hann_window(w, fftsize);
  for (int i = 0; i < fftsize; i++) {
    re[i] = signal[offset + i] * w[i];
    im[i] = 0;
  }
  fft_radix2(re, im, fftsize);
}

/* calculate short-time Fourier transform one frame */
void stft_frame(double *re, double *im, const double *signal, int offset, int fftsize) {
  double w[1024];
  hann_window(w, fftsize);
  for (int i = 0; i < fftsize; i++) {
    re[i] = signal[offset + i] * w[i];
    im[i] = 0;
  }
  fft_radix2(re, im, fftsize);
}

/* short-time Fourier transform one frame of array */
void stft_frame(double *re, double *im, const double *signal, int offset, int fftsize) {
  double w[1024];
  hann_window(w, fftsize);
  for (int i = 0; i < fftsize; i++) {
    re[i] = signal[offset + i] * w[i];
    im[i] = 0;
  }
  fft_radix2(re, im, fftsize);
}

/* short-time Fourier transform */
void stft_frame(double *re, double *im, const double *signal, int offset, int fftsize) {
  double w[1024];
  hann_window(w, fftsize);
  for (int i = 0; i < fftsize; i++) {
    re[i] = signal[offset + i] * w[i];
    im[i] = 0;
  }
  fft_radix2(re, im, fftsize);
}

/* compute real cepstrum */
void cepstrum(double *cep, const double *signal, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = signal[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) re[i] = log(sqrt(re[i] * re[i] + im[i] * im[i]) + 1e-15);
  for (int i = 0; i < n; i++) im[i] = 0;
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) cep[i] = re[i] / n;
}

/* calculate real cepstrum */
void cepstrum(double *cep, const double *signal, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = signal[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) re[i] = log(sqrt(re[i] * re[i] + im[i] * im[i]) + 1e-15);
  for (int i = 0; i < n; i++) im[i] = 0;
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) cep[i] = re[i] / n;
}

/* real cepstrum of array */
void cepstrum(double *cep, const double *signal, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = signal[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) re[i] = log(sqrt(re[i] * re[i] + im[i] * im[i]) + 1e-15);
  for (int i = 0; i < n; i++) im[i] = 0;
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) cep[i] = re[i] / n;
}

/* real cepstrum function */
void cepstrum(double *cep, const double *signal, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = signal[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) re[i] = log(sqrt(re[i] * re[i] + im[i] * im[i]) + 1e-15);
  for (int i = 0; i < n; i++) im[i] = 0;
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) cep[i] = re[i] / n;
}

/* compute Hilbert transform envelope */
void hilbert_envelope(double *env, const double *x, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = x[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 1; i < n / 2; i++) { re[i] *= 2; im[i] *= 2; }
  for (int i = n / 2 + 1; i < n; i++) { re[i] = 0; im[i] = 0; }
  ifft(re, im, n);
  for (int i = 0; i < n; i++) env[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* calculate Hilbert transform envelope */
void hilbert_envelope(double *env, const double *x, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = x[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 1; i < n / 2; i++) { re[i] *= 2; im[i] *= 2; }
  for (int i = n / 2 + 1; i < n; i++) { re[i] = 0; im[i] = 0; }
  ifft(re, im, n);
  for (int i = 0; i < n; i++) env[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* Hilbert transform envelope of array */
void hilbert_envelope(double *env, const double *x, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = x[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 1; i < n / 2; i++) { re[i] *= 2; im[i] *= 2; }
  for (int i = n / 2 + 1; i < n; i++) { re[i] = 0; im[i] = 0; }
  ifft(re, im, n);
  for (int i = 0; i < n; i++) env[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* Hilbert transform envelope function */
void hilbert_envelope(double *env, const double *x, int n) {
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = x[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 1; i < n / 2; i++) { re[i] *= 2; im[i] *= 2; }
  for (int i = n / 2 + 1; i < n; i++) { re[i] = 0; im[i] = 0; }
  ifft(re, im, n);
  for (int i = 0; i < n; i++) env[i] = sqrt(re[i] * re[i] + im[i] * im[i]);
}

/* compute biquad filter direct form I */
void biquad_filter(double *y, const double *x, int n,
                   double b0, double b1, double b2, double a1, double a2) {
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* calculate biquad filter direct form I */
void biquad_filter(double *y, const double *x, int n,
                   double b0, double b1, double b2, double a1, double a2) {
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* biquad filter direct form I of array */
void biquad_filter(double *y, const double *x, int n,
                   double b0, double b1, double b2, double a1, double a2) {
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* biquad filter direct */
void biquad_filter(double *y, const double *x, int n,
                   double b0, double b1, double b2, double a1, double a2) {
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* compute resonant bandpass filter */
void bandpass_filter(double *y, const double *x, int n, double freq, double q, double sr) {
  double w0 = 6.283185307 * freq / sr;
  double alpha = sin(w0) / (2.0 * q);
  double b0 = alpha, b1 = 0, b2 = -alpha;
  double a0 = 1.0 + alpha, a1 = -2.0 * cos(w0), a2 = 1.0 - alpha;
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = (b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2) / a0;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* calculate resonant bandpass filter */
void bandpass_filter(double *y, const double *x, int n, double freq, double q, double sr) {
  double w0 = 6.283185307 * freq / sr;
  double alpha = sin(w0) / (2.0 * q);
  double b0 = alpha, b1 = 0, b2 = -alpha;
  double a0 = 1.0 + alpha, a1 = -2.0 * cos(w0), a2 = 1.0 - alpha;
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = (b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2) / a0;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* resonant bandpass filter of array */
void bandpass_filter(double *y, const double *x, int n, double freq, double q, double sr) {
  double w0 = 6.283185307 * freq / sr;
  double alpha = sin(w0) / (2.0 * q);
  double b0 = alpha, b1 = 0, b2 = -alpha;
  double a0 = 1.0 + alpha, a1 = -2.0 * cos(w0), a2 = 1.0 - alpha;
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = (b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2) / a0;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* resonant bandpass filter function */
void bandpass_filter(double *y, const double *x, int n, double freq, double q, double sr) {
  double w0 = 6.283185307 * freq / sr;
  double alpha = sin(w0) / (2.0 * q);
  double b0 = alpha, b1 = 0, b2 = -alpha;
  double a0 = 1.0 + alpha, a1 = -2.0 * cos(w0), a2 = 1.0 - alpha;
  double x1 = 0, x2 = 0, y1 = 0, y2 = 0;
  for (int i = 0; i < n; i++) {
    y[i] = (b0 * x[i] + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2) / a0;
    x2 = x1; x1 = x[i]; y2 = y1; y1 = y[i];
  }
}

/* compute FIR filter */
void fir_filter(double *y, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < nx; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0) y[i] += h[j] * x[i - j];
  }
}

/* calculate FIR filter */
void fir_filter(double *y, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < nx; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0) y[i] += h[j] * x[i - j];
  }
}

/* FIR filter of array */
void fir_filter(double *y, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < nx; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0) y[i] += h[j] * x[i - j];
  }
}

/* FIR filter function */
void fir_filter(double *y, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < nx; i++) {
    y[i] = 0;
    for (int j = 0; j < nh; j++)
      if (i - j >= 0) y[i] += h[j] * x[i - j];
  }
}

/* compute Kaiser window */
void kaiser_window(double *w, int n, double beta) {
  double denom = bessel_j0(beta);
  for (int i = 0; i < n; i++) {
    double t = 2.0 * i / (n - 1) - 1.0;
    w[i] = bessel_j0(beta * sqrt(1.0 - t * t)) / denom;
  }
}

/* calculate Kaiser window */
void kaiser_window(double *w, int n, double beta) {
  double denom = bessel_j0(beta);
  for (int i = 0; i < n; i++) {
    double t = 2.0 * i / (n - 1) - 1.0;
    w[i] = bessel_j0(beta * sqrt(1.0 - t * t)) / denom;
  }
}

/* Kaiser taper */
void kaiser_window(double *w, int n, double beta) {
  double denom = bessel_j0(beta);
  for (int i = 0; i < n; i++) {
    double t = 2.0 * i / (n - 1) - 1.0;
    w[i] = bessel_j0(beta * sqrt(1.0 - t * t)) / denom;
  }
}

/* Kaiser windowing function */
void kaiser_window(double *w, int n, double beta) {
  double denom = bessel_j0(beta);
  for (int i = 0; i < n; i++) {
    double t = 2.0 * i / (n - 1) - 1.0;
    w[i] = bessel_j0(beta * sqrt(1.0 - t * t)) / denom;
  }
}

/* compute overlap-add convolution */
void overlap_add(double *y, int ny, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < ny; i++) y[i] = 0;
  for (int i = 0; i < nx; i++)
    for (int j = 0; j < nh && i + j < ny; j++)
      y[i + j] += x[i] * h[j];
}

/* calculate overlap-add convolution */
void overlap_add(double *y, int ny, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < ny; i++) y[i] = 0;
  for (int i = 0; i < nx; i++)
    for (int j = 0; j < nh && i + j < ny; j++)
      y[i + j] += x[i] * h[j];
}

/* overlap-add convolution of array */
void overlap_add(double *y, int ny, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < ny; i++) y[i] = 0;
  for (int i = 0; i < nx; i++)
    for (int j = 0; j < nh && i + j < ny; j++)
      y[i + j] += x[i] * h[j];
}

/* overlap-add convolution function */
void overlap_add(double *y, int ny, const double *x, int nx, const double *h, int nh) {
  for (int i = 0; i < ny; i++) y[i] = 0;
  for (int i = 0; i < nx; i++)
    for (int j = 0; j < nh && i + j < ny; j++)
      y[i + j] += x[i] * h[j];
}

/* compute Welch power spectral density estimate */
void welch_psd(double *psd, const double *x, int n, int seglen, int overlap) {
  int step = seglen - overlap;
  int nseg = 0;
  for (int i = 0; i < seglen; i++) psd[i] = 0;
  for (int start = 0; start + seglen <= n; start += step) {
    double re[1024], im[1024], w[1024];
    hann_window(w, seglen);
    for (int i = 0; i < seglen; i++) { re[i] = x[start + i] * w[i]; im[i] = 0; }
    fft_radix2(re, im, seglen);
    for (int i = 0; i < seglen; i++) psd[i] += re[i] * re[i] + im[i] * im[i];
    nseg++;
  }
  if (nseg > 0) for (int i = 0; i < seglen; i++) psd[i] /= nseg;
}

/* calculate Welch power spectral density estimate */
void welch_psd(double *psd, const double *x, int n, int seglen, int overlap) {
  int step = seglen - overlap;
  int nseg = 0;
  for (int i = 0; i < seglen; i++) psd[i] = 0;
  for (int start = 0; start + seglen <= n; start += step) {
    double re[1024], im[1024], w[1024];
    hann_window(w, seglen);
    for (int i = 0; i < seglen; i++) { re[i] = x[start + i] * w[i]; im[i] = 0; }
    fft_radix2(re, im, seglen);
    for (int i = 0; i < seglen; i++) psd[i] += re[i] * re[i] + im[i] * im[i];
    nseg++;
  }
  if (nseg > 0) for (int i = 0; i < seglen; i++) psd[i] /= nseg;
}

/* Welch power spectrum estimate */
void welch_psd(double *psd, const double *x, int n, int seglen, int overlap) {
  int step = seglen - overlap;
  int nseg = 0;
  for (int i = 0; i < seglen; i++) psd[i] = 0;
  for (int start = 0; start + seglen <= n; start += step) {
    double re[1024], im[1024], w[1024];
    hann_window(w, seglen);
    for (int i = 0; i < seglen; i++) { re[i] = x[start + i] * w[i]; im[i] = 0; }
    fft_radix2(re, im, seglen);
    for (int i = 0; i < seglen; i++) psd[i] += re[i] * re[i] + im[i] * im[i];
    nseg++;
  }
  if (nseg > 0) for (int i = 0; i < seglen; i++) psd[i] /= nseg;
}

/* Welch power frequency content estimate */
void welch_psd(double *psd, const double *x, int n, int seglen, int overlap) {
  int step = seglen - overlap;
  int nseg = 0;
  for (int i = 0; i < seglen; i++) psd[i] = 0;
  for (int start = 0; start + seglen <= n; start += step) {
    double re[1024], im[1024], w[1024];
    hann_window(w, seglen);
    for (int i = 0; i < seglen; i++) { re[i] = x[start + i] * w[i]; im[i] = 0; }
    fft_radix2(re, im, seglen);
    for (int i = 0; i < seglen; i++) psd[i] += re[i] * re[i] + im[i] * im[i];
    nseg++;
  }
  if (nseg > 0) for (int i = 0; i < seglen; i++) psd[i] /= nseg;
}

/* compute simple moving average */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* calculate simple moving average */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* simple moving mean */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* simple moving arithmetic mean */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* compute weighted moving average */
void wma(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    double ws = 0, s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    for (int j = start; j <= i; j++) {
      double w = j - start + 1;
      s += x[j] * w;
      ws += w;
    }
    out[i] = s / ws;
  }
}

/* calculate weighted moving average */
void wma(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    double ws = 0, s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    for (int j = start; j <= i; j++) {
      double w = j - start + 1;
      s += x[j] * w;
      ws += w;
    }
    out[i] = s / ws;
  }
}

/* weighted moving mean */
void wma(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    double ws = 0, s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    for (int j = start; j <= i; j++) {
      double w = j - start + 1;
      s += x[j] * w;
      ws += w;
    }
    out[i] = s / ws;
  }
}

/* weighted moving arithmetic mean */
void wma(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    double ws = 0, s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    for (int j = start; j <= i; j++) {
      double w = j - start + 1;
      s += x[j] * w;
      ws += w;
    }
    out[i] = s / ws;
  }
}

/* compute relative strength index */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* calculate relative strength index */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* relative strength index of array */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* relative strength index function */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* compute MACD line and signal */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* calculate MACD line and signal */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* MACD line and signal of array */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* MACD line and */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* compute Bollinger Bands */
void bollinger_bands(double *upper, double *middle, double *lower,
                     const double *close, int n, int period, double mult) {
  sma(middle, close, n, period);
  for (int i = 0; i < n; i++) {
    double s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    for (int j = start; j <= i; j++) {
      double d = close[j] - middle[i];
      s += d * d;
    }
    double sd = sqrt(s / cnt);
    upper[i] = middle[i] + mult * sd;
    lower[i] = middle[i] - mult * sd;
  }
}

/* calculate Bollinger Bands */
void bollinger_bands(double *upper, double *middle, double *lower,
                     const double *close, int n, int period, double mult) {
  sma(middle, close, n, period);
  for (int i = 0; i < n; i++) {
    double s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    for (int j = start; j <= i; j++) {
      double d = close[j] - middle[i];
      s += d * d;
    }
    double sd = sqrt(s / cnt);
    upper[i] = middle[i] + mult * sd;
    lower[i] = middle[i] - mult * sd;
  }
}

/* Bollinger Bands of array */
void bollinger_bands(double *upper, double *middle, double *lower,
                     const double *close, int n, int period, double mult) {
  sma(middle, close, n, period);
  for (int i = 0; i < n; i++) {
    double s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    for (int j = start; j <= i; j++) {
      double d = close[j] - middle[i];
      s += d * d;
    }
    double sd = sqrt(s / cnt);
    upper[i] = middle[i] + mult * sd;
    lower[i] = middle[i] - mult * sd;
  }
}

/* Bollinger Bands function */
void bollinger_bands(double *upper, double *middle, double *lower,
                     const double *close, int n, int period, double mult) {
  sma(middle, close, n, period);
  for (int i = 0; i < n; i++) {
    double s = 0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    for (int j = start; j <= i; j++) {
      double d = close[j] - middle[i];
      s += d * d;
    }
    double sd = sqrt(s / cnt);
    upper[i] = middle[i] + mult * sd;
    lower[i] = middle[i] - mult * sd;
  }
}

/* compute stochastic oscillator %K */
void stochastic_k(double *k_out, const double *high, const double *low,
                  const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    k_out[i] = (hi - lo > 1e-15) ? 100.0 * (close[i] - lo) / (hi - lo) : 50.0;
  }
}

/* calculate stochastic oscillator %K */
void stochastic_k(double *k_out, const double *high, const double *low,
                  const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    k_out[i] = (hi - lo > 1e-15) ? 100.0 * (close[i] - lo) / (hi - lo) : 50.0;
  }
}

/* stochastic oscillator %K of array */
void stochastic_k(double *k_out, const double *high, const double *low,
                  const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    k_out[i] = (hi - lo > 1e-15) ? 100.0 * (close[i] - lo) / (hi - lo) : 50.0;
  }
}

/* stochastic oscillator %K function */
void stochastic_k(double *k_out, const double *high, const double *low,
                  const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    k_out[i] = (hi - lo > 1e-15) ? 100.0 * (close[i] - lo) / (hi - lo) : 50.0;
  }
}

/* compute average true range */
void atr(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tr = high[i] - low[i];
    if (i > 0) {
      double d1 = fabs(high[i] - close[i - 1]);
      double d2 = fabs(low[i] - close[i - 1]);
      if (d1 > tr) tr = d1;
      if (d2 > tr) tr = d2;
    }
    if (i == 0) out[i] = tr;
    else out[i] = (out[i - 1] * (period - 1) + tr) / period;
  }
}

/* calculate average true range */
void atr(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tr = high[i] - low[i];
    if (i > 0) {
      double d1 = fabs(high[i] - close[i - 1]);
      double d2 = fabs(low[i] - close[i - 1]);
      if (d1 > tr) tr = d1;
      if (d2 > tr) tr = d2;
    }
    if (i == 0) out[i] = tr;
    else out[i] = (out[i - 1] * (period - 1) + tr) / period;
  }
}

/* mean true range */
void atr(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tr = high[i] - low[i];
    if (i > 0) {
      double d1 = fabs(high[i] - close[i - 1]);
      double d2 = fabs(low[i] - close[i - 1]);
      if (d1 > tr) tr = d1;
      if (d2 > tr) tr = d2;
    }
    if (i == 0) out[i] = tr;
    else out[i] = (out[i - 1] * (period - 1) + tr) / period;
  }
}

/* arithmetic mean true range */
void atr(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tr = high[i] - low[i];
    if (i > 0) {
      double d1 = fabs(high[i] - close[i - 1]);
      double d2 = fabs(low[i] - close[i - 1]);
      if (d1 > tr) tr = d1;
      if (d2 > tr) tr = d2;
    }
    if (i == 0) out[i] = tr;
    else out[i] = (out[i - 1] * (period - 1) + tr) / period;
  }
}

/* compute on-balance volume */
void obv(double *out, const double *close, const double *volume, int n) {
  out[0] = volume[0];
  for (int i = 1; i < n; i++) {
    if (close[i] > close[i - 1]) out[i] = out[i - 1] + volume[i];
    else if (close[i] < close[i - 1]) out[i] = out[i - 1] - volume[i];
    else out[i] = out[i - 1];
  }
}

/* calculate on-balance volume */
void obv(double *out, const double *close, const double *volume, int n) {
  out[0] = volume[0];
  for (int i = 1; i < n; i++) {
    if (close[i] > close[i - 1]) out[i] = out[i - 1] + volume[i];
    else if (close[i] < close[i - 1]) out[i] = out[i - 1] - volume[i];
    else out[i] = out[i - 1];
  }
}

/* on-balance volume of array */
void obv(double *out, const double *close, const double *volume, int n) {
  out[0] = volume[0];
  for (int i = 1; i < n; i++) {
    if (close[i] > close[i - 1]) out[i] = out[i - 1] + volume[i];
    else if (close[i] < close[i - 1]) out[i] = out[i - 1] - volume[i];
    else out[i] = out[i - 1];
  }
}

/* on-balance volume function */
void obv(double *out, const double *close, const double *volume, int n) {
  out[0] = volume[0];
  for (int i = 1; i < n; i++) {
    if (close[i] > close[i - 1]) out[i] = out[i - 1] + volume[i];
    else if (close[i] < close[i - 1]) out[i] = out[i - 1] - volume[i];
    else out[i] = out[i - 1];
  }
}

/* compute volume-weighted average price */
double vwap(const double *price, const double *volume, int n) {
  double pv = 0, v = 0;
  for (int i = 0; i < n; i++) { pv += price[i] * volume[i]; v += volume[i]; }
  return pv / (v + 1e-15);
}

/* calculate volume-weighted average price */
double vwap(const double *price, const double *volume, int n) {
  double pv = 0, v = 0;
  for (int i = 0; i < n; i++) { pv += price[i] * volume[i]; v += volume[i]; }
  return pv / (v + 1e-15);
}

/* volume-weighted mean price */
double vwap(const double *price, const double *volume, int n) {
  double pv = 0, v = 0;
  for (int i = 0; i < n; i++) { pv += price[i] * volume[i]; v += volume[i]; }
  return pv / (v + 1e-15);
}

/* volume-weighted arithmetic mean price */
double vwap(const double *price, const double *volume, int n) {
  double pv = 0, v = 0;
  for (int i = 0; i < n; i++) { pv += price[i] * volume[i]; v += volume[i]; }
  return pv / (v + 1e-15);
}

/* compute rate of change */
void roc(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    if (i < period) out[i] = 0;
    else out[i] = 100.0 * (x[i] - x[i - period]) / (x[i - period] + 1e-15);
  }
}

/* calculate rate of change */
void roc(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    if (i < period) out[i] = 0;
    else out[i] = 100.0 * (x[i] - x[i - period]) / (x[i - period] + 1e-15);
  }
}

/* rate of change of array */
void roc(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    if (i < period) out[i] = 0;
    else out[i] = 100.0 * (x[i] - x[i - period]) / (x[i - period] + 1e-15);
  }
}

/* rate of change function */
void roc(double *out, const double *x, int n, int period) {
  for (int i = 0; i < n; i++) {
    if (i < period) out[i] = 0;
    else out[i] = 100.0 * (x[i] - x[i - period]) / (x[i - period] + 1e-15);
  }
}

/* compute Williams %R */
void williams_r(double *out, const double *high, const double *low,
                const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi - lo > 1e-15) ? -100.0 * (hi - close[i]) / (hi - lo) : -50.0;
  }
}

/* calculate Williams %R */
void williams_r(double *out, const double *high, const double *low,
                const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi - lo > 1e-15) ? -100.0 * (hi - close[i]) / (hi - lo) : -50.0;
  }
}

/* Williams %R of array */
void williams_r(double *out, const double *high, const double *low,
                const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi - lo > 1e-15) ? -100.0 * (hi - close[i]) / (hi - lo) : -50.0;
  }
}

/* Williams %R function */
void williams_r(double *out, const double *high, const double *low,
                const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi - lo > 1e-15) ? -100.0 * (hi - close[i]) / (hi - lo) : -50.0;
  }
}

/* compute commodity channel index */
void cci(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tp = (high[i] + low[i] + close[i]) / 3.0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double sma_tp = 0;
    for (int j = start; j <= i; j++) sma_tp += (high[j] + low[j] + close[j]) / 3.0;
    sma_tp /= cnt;
    double mad = 0;
    for (int j = start; j <= i; j++) mad += fabs((high[j] + low[j] + close[j]) / 3.0 - sma_tp);
    mad /= cnt;
    out[i] = (mad > 1e-15) ? (tp - sma_tp) / (0.015 * mad) : 0;
  }
}

/* calculate commodity channel index */
void cci(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tp = (high[i] + low[i] + close[i]) / 3.0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double sma_tp = 0;
    for (int j = start; j <= i; j++) sma_tp += (high[j] + low[j] + close[j]) / 3.0;
    sma_tp /= cnt;
    double mad = 0;
    for (int j = start; j <= i; j++) mad += fabs((high[j] + low[j] + close[j]) / 3.0 - sma_tp);
    mad /= cnt;
    out[i] = (mad > 1e-15) ? (tp - sma_tp) / (0.015 * mad) : 0;
  }
}

/* commodity channel index of array */
void cci(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tp = (high[i] + low[i] + close[i]) / 3.0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double sma_tp = 0;
    for (int j = start; j <= i; j++) sma_tp += (high[j] + low[j] + close[j]) / 3.0;
    sma_tp /= cnt;
    double mad = 0;
    for (int j = start; j <= i; j++) mad += fabs((high[j] + low[j] + close[j]) / 3.0 - sma_tp);
    mad /= cnt;
    out[i] = (mad > 1e-15) ? (tp - sma_tp) / (0.015 * mad) : 0;
  }
}

/* commodity channel index function */
void cci(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    double tp = (high[i] + low[i] + close[i]) / 3.0;
    int start = i - period + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double sma_tp = 0;
    for (int j = start; j <= i; j++) sma_tp += (high[j] + low[j] + close[j]) / 3.0;
    sma_tp /= cnt;
    double mad = 0;
    for (int j = start; j <= i; j++) mad += fabs((high[j] + low[j] + close[j]) / 3.0 - sma_tp);
    mad /= cnt;
    out[i] = (mad > 1e-15) ? (tp - sma_tp) / (0.015 * mad) : 0;
  }
}

/* compute parabolic SAR */
void parabolic_sar(double *sar, const double *high, const double *low, int n,
                   double af_start, double af_step, double af_max) {
  int uptrend = 1;
  double af = af_start;
  double ep = high[0];
  sar[0] = low[0];
  for (int i = 1; i < n; i++) {
    sar[i] = sar[i - 1] + af * (ep - sar[i - 1]);
    if (uptrend) {
      if (high[i] > ep) { ep = high[i]; af += af_step; if (af > af_max) af = af_max; }
      if (low[i] < sar[i]) { uptrend = 0; sar[i] = ep; ep = low[i]; af = af_start; }
    } else {
      if (low[i] < ep) { ep = low[i]; af += af_step; if (af > af_max) af = af_max; }
      if (high[i] > sar[i]) { uptrend = 1; sar[i] = ep; ep = high[i]; af = af_start; }
    }
  }
}

/* calculate parabolic SAR */
void parabolic_sar(double *sar, const double *high, const double *low, int n,
                   double af_start, double af_step, double af_max) {
  int uptrend = 1;
  double af = af_start;
  double ep = high[0];
  sar[0] = low[0];
  for (int i = 1; i < n; i++) {
    sar[i] = sar[i - 1] + af * (ep - sar[i - 1]);
    if (uptrend) {
      if (high[i] > ep) { ep = high[i]; af += af_step; if (af > af_max) af = af_max; }
      if (low[i] < sar[i]) { uptrend = 0; sar[i] = ep; ep = low[i]; af = af_start; }
    } else {
      if (low[i] < ep) { ep = low[i]; af += af_step; if (af > af_max) af = af_max; }
      if (high[i] > sar[i]) { uptrend = 1; sar[i] = ep; ep = high[i]; af = af_start; }
    }
  }
}

/* parabolic SAR of array */
void parabolic_sar(double *sar, const double *high, const double *low, int n,
                   double af_start, double af_step, double af_max) {
  int uptrend = 1;
  double af = af_start;
  double ep = high[0];
  sar[0] = low[0];
  for (int i = 1; i < n; i++) {
    sar[i] = sar[i - 1] + af * (ep - sar[i - 1]);
    if (uptrend) {
      if (high[i] > ep) { ep = high[i]; af += af_step; if (af > af_max) af = af_max; }
      if (low[i] < sar[i]) { uptrend = 0; sar[i] = ep; ep = low[i]; af = af_start; }
    } else {
      if (low[i] < ep) { ep = low[i]; af += af_step; if (af > af_max) af = af_max; }
      if (high[i] > sar[i]) { uptrend = 1; sar[i] = ep; ep = high[i]; af = af_start; }
    }
  }
}

/* parabolic SAR function */
void parabolic_sar(double *sar, const double *high, const double *low, int n,
                   double af_start, double af_step, double af_max) {
  int uptrend = 1;
  double af = af_start;
  double ep = high[0];
  sar[0] = low[0];
  for (int i = 1; i < n; i++) {
    sar[i] = sar[i - 1] + af * (ep - sar[i - 1]);
    if (uptrend) {
      if (high[i] > ep) { ep = high[i]; af += af_step; if (af > af_max) af = af_max; }
      if (low[i] < sar[i]) { uptrend = 0; sar[i] = ep; ep = low[i]; af = af_start; }
    } else {
      if (low[i] < ep) { ep = low[i]; af += af_step; if (af > af_max) af = af_max; }
      if (high[i] > sar[i]) { uptrend = 1; sar[i] = ep; ep = high[i]; af = af_start; }
    }
  }
}

/* compute average directional index */
void adx(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  double atr_val = 0;
  double plus_dm = 0, minus_dm = 0;
  for (int i = 1; i < n; i++) {
    double tr = high[i] - low[i];
    double d1 = fabs(high[i] - close[i - 1]);
    double d2 = fabs(low[i] - close[i - 1]);
    if (d1 > tr) tr = d1;
    if (d2 > tr) tr = d2;
    double pdm = high[i] - high[i - 1];
    double mdm = low[i - 1] - low[i];
    if (pdm < 0) pdm = 0;
    if (mdm < 0) mdm = 0;
    if (pdm > mdm) mdm = 0; else pdm = 0;
    atr_val = (atr_val * (period - 1) + tr) / period;
    plus_dm = (plus_dm * (period - 1) + pdm) / period;
    minus_dm = (minus_dm * (period - 1) + mdm) / period;
    double pdi = 100.0 * plus_dm / (atr_val + 1e-15);
    double mdi = 100.0 * minus_dm / (atr_val + 1e-15);
    double dx = 100.0 * fabs(pdi - mdi) / (pdi + mdi + 1e-15);
    if (i == 1) out[i] = dx;
    else out[i] = (out[i - 1] * (period - 1) + dx) / period;
  }
  out[0] = 0;
}

/* calculate average directional index */
void adx(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  double atr_val = 0;
  double plus_dm = 0, minus_dm = 0;
  for (int i = 1; i < n; i++) {
    double tr = high[i] - low[i];
    double d1 = fabs(high[i] - close[i - 1]);
    double d2 = fabs(low[i] - close[i - 1]);
    if (d1 > tr) tr = d1;
    if (d2 > tr) tr = d2;
    double pdm = high[i] - high[i - 1];
    double mdm = low[i - 1] - low[i];
    if (pdm < 0) pdm = 0;
    if (mdm < 0) mdm = 0;
    if (pdm > mdm) mdm = 0; else pdm = 0;
    atr_val = (atr_val * (period - 1) + tr) / period;
    plus_dm = (plus_dm * (period - 1) + pdm) / period;
    minus_dm = (minus_dm * (period - 1) + mdm) / period;
    double pdi = 100.0 * plus_dm / (atr_val + 1e-15);
    double mdi = 100.0 * minus_dm / (atr_val + 1e-15);
    double dx = 100.0 * fabs(pdi - mdi) / (pdi + mdi + 1e-15);
    if (i == 1) out[i] = dx;
    else out[i] = (out[i - 1] * (period - 1) + dx) / period;
  }
  out[0] = 0;
}

/* mean directional index */
void adx(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  double atr_val = 0;
  double plus_dm = 0, minus_dm = 0;
  for (int i = 1; i < n; i++) {
    double tr = high[i] - low[i];
    double d1 = fabs(high[i] - close[i - 1]);
    double d2 = fabs(low[i] - close[i - 1]);
    if (d1 > tr) tr = d1;
    if (d2 > tr) tr = d2;
    double pdm = high[i] - high[i - 1];
    double mdm = low[i - 1] - low[i];
    if (pdm < 0) pdm = 0;
    if (mdm < 0) mdm = 0;
    if (pdm > mdm) mdm = 0; else pdm = 0;
    atr_val = (atr_val * (period - 1) + tr) / period;
    plus_dm = (plus_dm * (period - 1) + pdm) / period;
    minus_dm = (minus_dm * (period - 1) + mdm) / period;
    double pdi = 100.0 * plus_dm / (atr_val + 1e-15);
    double mdi = 100.0 * minus_dm / (atr_val + 1e-15);
    double dx = 100.0 * fabs(pdi - mdi) / (pdi + mdi + 1e-15);
    if (i == 1) out[i] = dx;
    else out[i] = (out[i - 1] * (period - 1) + dx) / period;
  }
  out[0] = 0;
}

/* arithmetic mean directional index */
void adx(double *out, const double *high, const double *low,
         const double *close, int n, int period) {
  double atr_val = 0;
  double plus_dm = 0, minus_dm = 0;
  for (int i = 1; i < n; i++) {
    double tr = high[i] - low[i];
    double d1 = fabs(high[i] - close[i - 1]);
    double d2 = fabs(low[i] - close[i - 1]);
    if (d1 > tr) tr = d1;
    if (d2 > tr) tr = d2;
    double pdm = high[i] - high[i - 1];
    double mdm = low[i - 1] - low[i];
    if (pdm < 0) pdm = 0;
    if (mdm < 0) mdm = 0;
    if (pdm > mdm) mdm = 0; else pdm = 0;
    atr_val = (atr_val * (period - 1) + tr) / period;
    plus_dm = (plus_dm * (period - 1) + pdm) / period;
    minus_dm = (minus_dm * (period - 1) + mdm) / period;
    double pdi = 100.0 * plus_dm / (atr_val + 1e-15);
    double mdi = 100.0 * minus_dm / (atr_val + 1e-15);
    double dx = 100.0 * fabs(pdi - mdi) / (pdi + mdi + 1e-15);
    if (i == 1) out[i] = dx;
    else out[i] = (out[i - 1] * (period - 1) + dx) / period;
  }
  out[0] = 0;
}

/* compute Ichimoku cloud tenkan-sen */
void ichimoku_tenkan(double *out, const double *high, const double *low, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi + lo) / 2.0;
  }
}

/* calculate Ichimoku cloud tenkan-sen */
void ichimoku_tenkan(double *out, const double *high, const double *low, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi + lo) / 2.0;
  }
}

/* Ichimoku cloud tenkan-sen of array */
void ichimoku_tenkan(double *out, const double *high, const double *low, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi + lo) / 2.0;
  }
}

/* Ichimoku cloud tenkan-sen function */
void ichimoku_tenkan(double *out, const double *high, const double *low, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period + 1;
    if (start < 0) start = 0;
    double hi = high[start], lo = low[start];
    for (int j = start + 1; j <= i; j++) {
      if (high[j] > hi) hi = high[j];
      if (low[j] < lo) lo = low[j];
    }
    out[i] = (hi + lo) / 2.0;
  }
}

/* compute Hull moving average */
void hull_ma(double *out, const double *x, int n, int period) {
  double wma1[1024], wma2[1024], diff[1024];
  int half = period / 2;
  int root = (int)sqrt((double)period);
  wma(wma1, x, n, half);
  wma(wma2, x, n, period);
  for (int i = 0; i < n; i++) diff[i] = 2.0 * wma1[i] - wma2[i];
  wma(out, diff, n, root);
}

/* calculate Hull moving average */
void hull_ma(double *out, const double *x, int n, int period) {
  double wma1[1024], wma2[1024], diff[1024];
  int half = period / 2;
  int root = (int)sqrt((double)period);
  wma(wma1, x, n, half);
  wma(wma2, x, n, period);
  for (int i = 0; i < n; i++) diff[i] = 2.0 * wma1[i] - wma2[i];
  wma(out, diff, n, root);
}

/* Hull moving mean */
void hull_ma(double *out, const double *x, int n, int period) {
  double wma1[1024], wma2[1024], diff[1024];
  int half = period / 2;
  int root = (int)sqrt((double)period);
  wma(wma1, x, n, half);
  wma(wma2, x, n, period);
  for (int i = 0; i < n; i++) diff[i] = 2.0 * wma1[i] - wma2[i];
  wma(out, diff, n, root);
}

/* Hull moving arithmetic mean */
void hull_ma(double *out, const double *x, int n, int period) {
  double wma1[1024], wma2[1024], diff[1024];
  int half = period / 2;
  int root = (int)sqrt((double)period);
  wma(wma1, x, n, half);
  wma(wma2, x, n, period);
  for (int i = 0; i < n; i++) diff[i] = 2.0 * wma1[i] - wma2[i];
  wma(out, diff, n, root);
}

/* compute double exponential moving average */
void dema(double *out, const double *x, int n, int period) {
  double ema1[1024], ema2[1024];
  ema_series(ema1, x, n, period);
  ema_series(ema2, ema1, n, period);
  for (int i = 0; i < n; i++) out[i] = 2.0 * ema1[i] - ema2[i];
}

/* calculate double exponential moving average */
void dema(double *out, const double *x, int n, int period) {
  double ema1[1024], ema2[1024];
  ema_series(ema1, x, n, period);
  ema_series(ema2, ema1, n, period);
  for (int i = 0; i < n; i++) out[i] = 2.0 * ema1[i] - ema2[i];
}

/* double exponential moving mean */
void dema(double *out, const double *x, int n, int period) {
  double ema1[1024], ema2[1024];
  ema_series(ema1, x, n, period);
  ema_series(ema2, ema1, n, period);
  for (int i = 0; i < n; i++) out[i] = 2.0 * ema1[i] - ema2[i];
}

/* double exponential moving arithmetic mean */
void dema(double *out, const double *x, int n, int period) {
  double ema1[1024], ema2[1024];
  ema_series(ema1, x, n, period);
  ema_series(ema2, ema1, n, period);
  for (int i = 0; i < n; i++) out[i] = 2.0 * ema1[i] - ema2[i];
}

/* compute Aroon oscillator */
void aroon(double *up, double *down, const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period;
    if (start < 0) start = 0;
    int hi_idx = start, lo_idx = start;
    for (int j = start + 1; j <= i; j++) {
      if (close[j] >= close[hi_idx]) hi_idx = j;
      if (close[j] <= close[lo_idx]) lo_idx = j;
    }
    int span = i - start;
    if (span == 0) span = 1;
    up[i] = 100.0 * (i - hi_idx) / span;
    down[i] = 100.0 * (i - lo_idx) / span;
  }
}

/* calculate Aroon oscillator */
void aroon(double *up, double *down, const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period;
    if (start < 0) start = 0;
    int hi_idx = start, lo_idx = start;
    for (int j = start + 1; j <= i; j++) {
      if (close[j] >= close[hi_idx]) hi_idx = j;
      if (close[j] <= close[lo_idx]) lo_idx = j;
    }
    int span = i - start;
    if (span == 0) span = 1;
    up[i] = 100.0 * (i - hi_idx) / span;
    down[i] = 100.0 * (i - lo_idx) / span;
  }
}

/* Aroon oscillator of array */
void aroon(double *up, double *down, const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period;
    if (start < 0) start = 0;
    int hi_idx = start, lo_idx = start;
    for (int j = start + 1; j <= i; j++) {
      if (close[j] >= close[hi_idx]) hi_idx = j;
      if (close[j] <= close[lo_idx]) lo_idx = j;
    }
    int span = i - start;
    if (span == 0) span = 1;
    up[i] = 100.0 * (i - hi_idx) / span;
    down[i] = 100.0 * (i - lo_idx) / span;
  }
}

/* Aroon oscillator function */
void aroon(double *up, double *down, const double *close, int n, int period) {
  for (int i = 0; i < n; i++) {
    int start = i - period;
    if (start < 0) start = 0;
    int hi_idx = start, lo_idx = start;
    for (int j = start + 1; j <= i; j++) {
      if (close[j] >= close[hi_idx]) hi_idx = j;
      if (close[j] <= close[lo_idx]) lo_idx = j;
    }
    int span = i - start;
    if (span == 0) span = 1;
    up[i] = 100.0 * (i - hi_idx) / span;
    down[i] = 100.0 * (i - lo_idx) / span;
  }
}

/* compute linear returns from prices */
void linear_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = (price[i] - price[i - 1]) / price[i - 1];
}

/* calculate linear returns from prices */
void linear_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = (price[i] - price[i - 1]) / price[i - 1];
}

/* linear yields from prices */
void linear_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = (price[i] - price[i - 1]) / price[i - 1];
}

/* linear gains from prices */
void linear_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = (price[i] - price[i - 1]) / price[i - 1];
}

/* compute log returns from prices */
void log_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = log(price[i] / price[i - 1]);
}

/* calculate log returns from prices */
void log_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = log(price[i] / price[i - 1]);
}

/* log yields from prices */
void log_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = log(price[i] / price[i - 1]);
}

/* log gains from prices */
void log_returns(double *ret, const double *price, int n) {
  ret[0] = 0;
  for (int i = 1; i < n; i++) ret[i] = log(price[i] / price[i - 1]);
}

/* compute Sharpe ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* calculate Sharpe ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* Sharpe proportion */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* Sharpe relative measure */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* compute maximum drawdown */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* calculate maximum drawdown */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* maximum drawdown of array */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* maximum drawdown function */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* compute rolling beta against benchmark */
void rolling_beta(double *beta, const double *ret, const double *bench, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double cov = 0, var_b = 0;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    for (int j = start; j <= i; j++) {
      cov += (ret[j] - mr) * (bench[j] - mb);
      var_b += (bench[j] - mb) * (bench[j] - mb);
    }
    beta[i] = (var_b > 1e-15) ? cov / var_b : 0;
  }
}

/* calculate rolling beta against benchmark */
void rolling_beta(double *beta, const double *ret, const double *bench, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double cov = 0, var_b = 0;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    for (int j = start; j <= i; j++) {
      cov += (ret[j] - mr) * (bench[j] - mb);
      var_b += (bench[j] - mb) * (bench[j] - mb);
    }
    beta[i] = (var_b > 1e-15) ? cov / var_b : 0;
  }
}

/* rolling beta areturnst benchmark */
void rolling_beta(double *beta, const double *ret, const double *bench, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double cov = 0, var_b = 0;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    for (int j = start; j <= i; j++) {
      cov += (ret[j] - mr) * (bench[j] - mb);
      var_b += (bench[j] - mb) * (bench[j] - mb);
    }
    beta[i] = (var_b > 1e-15) ? cov / var_b : 0;
  }
}

/* rolling beta ayieldst benchmark */
void rolling_beta(double *beta, const double *ret, const double *bench, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double cov = 0, var_b = 0;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    for (int j = start; j <= i; j++) {
      cov += (ret[j] - mr) * (bench[j] - mb);
      var_b += (bench[j] - mb) * (bench[j] - mb);
    }
    beta[i] = (var_b > 1e-15) ? cov / var_b : 0;
  }
}

/* compute rolling alpha */
void rolling_alpha(double *alpha, const double *ret, const double *bench,
                   const double *beta_arr, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    alpha[i] = mr - beta_arr[i] * mb;
  }
}

/* calculate rolling alpha */
void rolling_alpha(double *alpha, const double *ret, const double *bench,
                   const double *beta_arr, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    alpha[i] = mr - beta_arr[i] * mb;
  }
}

/* rolling alpha of array */
void rolling_alpha(double *alpha, const double *ret, const double *bench,
                   const double *beta_arr, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    alpha[i] = mr - beta_arr[i] * mb;
  }
}

/* rolling alpha function */
void rolling_alpha(double *alpha, const double *ret, const double *bench,
                   const double *beta_arr, int n, int window) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double mr = 0, mb = 0;
    for (int j = start; j <= i; j++) { mr += ret[j]; mb += bench[j]; }
    mr /= cnt; mb /= cnt;
    alpha[i] = mr - beta_arr[i] * mb;
  }
}

/* compute portfolio variance from weights and covariance matrix */
double portfolio_variance(const double *weights, const double *cov_matrix, int n) {
  double var = 0;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      var += weights[i] * weights[j] * cov_matrix[i * n + j];
  return var;
}

/* calculate portfolio variance from weights and covariance matrix */
double portfolio_variance(const double *weights, const double *cov_matrix, int n) {
  double var = 0;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      var += weights[i] * weights[j] * cov_matrix[i * n + j];
  return var;
}

/* portfolio squared deviation from weights and covariance matrix */
double portfolio_variance(const double *weights, const double *cov_matrix, int n) {
  double var = 0;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      var += weights[i] * weights[j] * cov_matrix[i * n + j];
  return var;
}

/* portfolio variance from weights and joint variation matrix */
double portfolio_variance(const double *weights, const double *cov_matrix, int n) {
  double var = 0;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      var += weights[i] * weights[j] * cov_matrix[i * n + j];
  return var;
}

/* compute value at risk historical method */
double value_at_risk(double *returns, int n, double confidence) {
  bubble_sort(returns, n);
  int idx = (int)((1.0 - confidence) * n);
  if (idx < 0) idx = 0;
  if (idx >= n) idx = n - 1;
  return -returns[idx];
}

/* calculate value at risk historical method */
double value_at_risk(double *returns, int n, double confidence) {
  bubble_sort(returns, n);
  int idx = (int)((1.0 - confidence) * n);
  if (idx < 0) idx = 0;
  if (idx >= n) idx = n - 1;
  return -returns[idx];
}

/* price at risk historical method */
double value_at_risk(double *returns, int n, double confidence) {
  bubble_sort(returns, n);
  int idx = (int)((1.0 - confidence) * n);
  if (idx < 0) idx = 0;
  if (idx >= n) idx = n - 1;
  return -returns[idx];
}

/* fair value at risk historical method */
double value_at_risk(double *returns, int n, double confidence) {
  bubble_sort(returns, n);
  int idx = (int)((1.0 - confidence) * n);
  if (idx < 0) idx = 0;
  if (idx >= n) idx = n - 1;
  return -returns[idx];
}

/* compute CAGR compound annual growth rate */
double cagr(double begin_val, double end_val, double years) {
  return pow(end_val / begin_val, 1.0 / years) - 1.0;
}

/* calculate CAGR compound annual growth rate */
double cagr(double begin_val, double end_val, double years) {
  return pow(end_val / begin_val, 1.0 / years) - 1.0;
}

/* CAGR compound annual growth rate of array */
double cagr(double begin_val, double end_val, double years) {
  return pow(end_val / begin_val, 1.0 / years) - 1.0;
}

/* CAGR compound annual */
double cagr(double begin_val, double end_val, double years) {
  return pow(end_val / begin_val, 1.0 / years) - 1.0;
}

/* Sortino proportion */
double sortino_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = 0;
  int cnt = 0;
  for (int i = 0; i < n; i++) {
    double d = returns[i] - risk_free;
    if (d < 0) { s += d * d; cnt++; }
  }
  double dd = (cnt > 0) ? sqrt(s / cnt) : 1e-15;
  return m / dd;
}

/* Sortino relative measure */
double sortino_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = 0;
  int cnt = 0;
  for (int i = 0; i < n; i++) {
    double d = returns[i] - risk_free;
    if (d < 0) { s += d * d; cnt++; }
  }
  double dd = (cnt > 0) ? sqrt(s / cnt) : 1e-15;
  return m / dd;
}

/* Sortino ratio of array */
double sortino_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = 0;
  int cnt = 0;
  for (int i = 0; i < n; i++) {
    double d = returns[i] - risk_free;
    if (d < 0) { s += d * d; cnt++; }
  }
  double dd = (cnt > 0) ? sqrt(s / cnt) : 1e-15;
  return m / dd;
}

/* Sortino ratio function */
double sortino_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = 0;
  int cnt = 0;
  for (int i = 0; i < n; i++) {
    double d = returns[i] - risk_free;
    if (d < 0) { s += d * d; cnt++; }
  }
  double dd = (cnt > 0) ? sqrt(s / cnt) : 1e-15;
  return m / dd;
}

/* compute Calmar ratio */
double calmar_ratio(const double *equity, int n, double annual_return) {
  double mdd = max_drawdown(equity, n);
  return annual_return / (mdd + 1e-15);
}

/* calculate Calmar ratio */
double calmar_ratio(const double *equity, int n, double annual_return) {
  double mdd = max_drawdown(equity, n);
  return annual_return / (mdd + 1e-15);
}

/* Calmar proportion */
double calmar_ratio(const double *equity, int n, double annual_return) {
  double mdd = max_drawdown(equity, n);
  return annual_return / (mdd + 1e-15);
}

/* Calmar relative measure */
double calmar_ratio(const double *equity, int n, double annual_return) {
  double mdd = max_drawdown(equity, n);
  return annual_return / (mdd + 1e-15);
}

/* calculate average of array */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* evaluate average of array */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* compute mean of array */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* compute arithmetic mean of array */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* compute array average */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* calculate array average */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* array mean */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* array arithmetic mean */
double mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / n;
}

/* evaluate standard deviation */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* calculate stddev */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* calculate std dev */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* compute standard deviation of array */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* calculate standard deviation of array */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* stddev of array */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* std dev of array */
double stddev(const double *x, int n) {
  double m = mean(x, n), s = 0;
  for (int i = 0; i < n; i++) { double d = x[i] - m; s += d * d; }
  return sqrt(s / n);
}

/* order array ascending */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* arrange array ascending */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort array ascending of array */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort array ascending function */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* order values in ascending order */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* arrange values in ascending order */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort prices in ascending order */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort fair values in ascending order */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* order array in place */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* arrange array in place */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort array in place of array */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* sort array in */
void bubble_sort(double *a, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = 0; j < n - i - 1; j++)
      if (a[j] > a[j + 1]) { double t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; }
}

/* compute insertion sort */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* calculate insertion sort */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* insertion sort of array */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* insertion sort function */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* order using insertion method */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* arrange using insertion method */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* sort using insertion method of array */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* sort using insertion */
void insertion_sort(double *a, int n) {
  for (int i = 1; i < n; i++) {
    double key = a[i]; int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

/* calculate dot product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* evaluate dot product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* compute inner product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* compute scalar product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* compute inner product of vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* calculate inner product of vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* dot product of vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* scalar product of vectors */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* compute vector dot product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* calculate vector dot product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* vector inner product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* vector scalar product */
double dot(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}

/* perform FFT with window */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* execute FFT with window */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply FFT with taper */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply FFT with windowing function */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute windowed FFT */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* calculate windowed FFT */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* tapered FFT */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* windowing functioned FFT */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute FFT of windowed signal */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* calculate FFT of windowed signal */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT of tapered signal */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* FFT of windowing functioned signal */
void fft_windowed_hann(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hann_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute transpose matrix */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* calculate transpose matrix */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* transpose matrix of array */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* transpose matrix function */
void mat_transpose(double *At, const double *A, int m, int n) {
  for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++) At[j * m + i] = A[i * n + j];
}

/* compute binary search */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* calculate binary search */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* binary search of array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* binary search function */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* compute search sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* calculate search sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* search sorted array of array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* search sorted array function */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* compute value in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* calculate value in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* find price in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* find fair value in sorted array */
int binary_search(const double *a, int n, double val) {
  int lo = 0, hi = n - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (a[mid] < val) lo = mid + 1;
    else if (a[mid] > val) hi = mid - 1;
    else return mid;
  }
  return -1;
}

/* calculate sigmoid */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* evaluate sigmoid */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* compute sigmoid of array */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* compute sigmoid function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* calculate sigmoid function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* sigmoid function of array */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* sigmoid function function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* compute logistic function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* calculate logistic function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* logistic function of array */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* logistic function function */
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

/* calculate ReLU */
double relu(double x) { return x > 0 ? x : 0; }

/* evaluate ReLU */
double relu(double x) { return x > 0 ? x : 0; }

/* compute ReLU of array */
double relu(double x) { return x > 0 ? x : 0; }

/* compute ReLU function */
double relu(double x) { return x > 0 ? x : 0; }

/* compute rectified linear unit */
double relu(double x) { return x > 0 ? x : 0; }

/* calculate rectified linear unit */
double relu(double x) { return x > 0 ? x : 0; }

/* rectified linear unit of array */
double relu(double x) { return x > 0 ? x : 0; }

/* rectified linear unit function */
double relu(double x) { return x > 0 ? x : 0; }

/* compute ReLU activation */
double relu(double x) { return x > 0 ? x : 0; }

/* calculate ReLU activation */
double relu(double x) { return x > 0 ? x : 0; }

/* ReLU activation of array */
double relu(double x) { return x > 0 ? x : 0; }

/* compute simple moving average of series */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* calculate simple moving average of series */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* simple moving mean of series */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* simple moving arithmetic mean of series */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* calculate SMA */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* evaluate SMA */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* compute SMA of array */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* compute SMA function */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* compute moving average */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* calculate moving average */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* moving mean */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* moving arithmetic mean */
void sma(double *out, const double *x, int n, int period) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= period) s -= x[i - period];
    out[i] = (i >= period - 1) ? s / period : s / (i + 1);
  }
}

/* calculate EMA */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* evaluate EMA */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* compute EMA of array */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* compute EMA function */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* compute exponential moving average series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* calculate exponential moving average series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* exponential moving mean series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* exponential moving arithmetic mean series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* compute EMA of price series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* calculate EMA of price series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* EMA of value series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* EMA of fair value series */
void ema_series(double *out, const double *x, int n, int period) {
  double alpha = 2.0 / (period + 1);
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = alpha * x[i] + (1.0 - alpha) * out[i - 1];
}

/* calculate Hann window */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* evaluate Hann window */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* compute Hann taper */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* compute Hann windowing function */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* compute Hann window coefficients */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* calculate Hann window coefficients */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* Hann taper coefficients */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* Hann windowing function coefficients */
void hann_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.5 * (1.0 - cos(6.283185307 * i / (n - 1)));
}

/* calculate RSI */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* evaluate RSI */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* compute RSI of array */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* compute RSI function */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* compute relative strength indicator */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* calculate relative strength indicator */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* relative strength indicator of array */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* relative strength indicator function */
void rsi(double *out, const double *close, int n, int period) {
  double gain = 0, loss = 0;
  for (int i = 1; i <= period && i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) gain += d; else loss -= d;
  }
  gain /= period; loss /= period;
  out[0] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  for (int i = period + 1; i < n; i++) {
    double d = close[i] - close[i - 1];
    if (d > 0) { gain = (gain * (period - 1) + d) / period; loss = loss * (period - 1) / period; }
    else { loss = (loss * (period - 1) - d) / period; gain = gain * (period - 1) / period; }
    out[i - period] = 100.0 - 100.0 / (1.0 + gain / (loss + 1e-15));
  }
}

/* calculate Sharpe */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* evaluate Sharpe */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* compute Sharpe of array */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* compute Sharpe function */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* compute risk-adjusted return ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* calculate risk-adjusted return ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* risk-adjusted yield ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* risk-adjusted gain ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* compute return to volatility ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* calculate return to volatility ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* return to dispersion ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* return to variability ratio */
double sharpe_ratio(const double *returns, int n, double risk_free) {
  double m = mean(returns, n) - risk_free;
  double s = stddev(returns, n);
  return m / (s + 1e-15);
}

/* normalise to z-scores */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* rescale to z-scores */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* normalize to z-scores of array */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* normalize to z-scores function */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* normalize array */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* normalise array */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* standardize array of array */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* standardize array function */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* calculate z-scores */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* evaluate z-scores */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* compute z-scores of array */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* compute z-scores function */
void zscore(double *z, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  for (int i = 0; i < n; i++) z[i] = (x[i] - m) / s;
}

/* compute Pearson correlation */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* calculate Pearson correlation */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* Pearson linear association */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* Pearson correlation of array */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* calculate correlation coefficient */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* evaluate correlation coefficient */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* compute linear association coefficient */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* compute correlation coefficient of array */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* compute linear correlation */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* calculate linear correlation */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* linear linear association */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* linear correlation of array */
double correlation(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n);
  double sxx = 0, syy = 0, sxy = 0;
  for (int i = 0; i < n; i++) {
    double dx = x[i] - mx, dy = y[i] - my;
    sxy += dx * dy; sxx += dx * dx; syy += dy * dy;
  }
  return sxy / (sqrt(sxx * syy) + 1e-15);
}

/* compute first order IIR filter */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* calculate first order IIR filter */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* first order IIR filter of array */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* first order IIR */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* compute IIR low pass */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* calculate IIR low pass */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* IIR low pass of array */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* IIR low pass function */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* filter signal with low pass */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* process signal with low pass */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* smooth signal with low pass of array */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* smooth signal with */
void lowpass(double *y, const double *x, int n, double alpha) {
  y[0] = x[0];
  for (int i = 1; i < n; i++) y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1];
}

/* compute maximum drawdown of equity curve */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* calculate maximum drawdown of equity curve */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* maximum drawdown of equity curve of array */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* maximum drawdown of */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* calculate max drawdown */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* evaluate max drawdown */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* compute max drawdown of array */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* compute max drawdown function */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* compute largest peak to trough decline */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* calculate largest peak to trough decline */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* largest peak to trough decline of array */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* largest peak to */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], max_dd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > max_dd) max_dd = dd;
  }
  return max_dd;
}

/* calculate MACD */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* evaluate MACD */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* compute MACD of array */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* compute MACD function */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* compute MACD indicator */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* calculate MACD indicator */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* MACD indicator of array */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* MACD indicator function */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* compute moving average convergence divergence */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* calculate moving average convergence divergence */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* moving mean convergence divergence */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* moving arithmetic mean convergence divergence */
void macd(double *macd_line, double *signal_line, const double *close, int n) {
  double ema12[1024], ema26[1024];
  ema_series(ema12, close, n, 12);
  ema_series(ema26, close, n, 26);
  for (int i = 0; i < n; i++) macd_line[i] = ema12[i] - ema26[i];
  ema_series(signal_line, macd_line, n, 9);
}

/* compute Kalman filter step */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* calculate Kalman filter step */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* Kalman filter step of array */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* Kalman filter step function */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* compute 1D Kalman update */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* calculate 1D Kalman update */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* 1D Kalman update of array */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* 1D Kalman update function */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* compute Kalman predict and update */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* calculate Kalman predict and update */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* Kalman predict and update of array */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* Kalman predict and */
void kalman_step(double *x, double *p, double z, double q, double r) {
  *p += q;
  double k = *p / (*p + r);
  *x += k * (z - *x);
  *p *= (1.0 - k);
}

/* compute vector scale */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* calculate vector scale */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* vector scale of array */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* vector scale function */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* compute multiply vector by scalar */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* calculate multiply vector by scalar */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* multiply vector by scalar of array */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* multiply vector by */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* compute scale array elements */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* calculate scale array elements */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* scale array elements of array */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* scale array elements function */
void vec_scale(double *y, const double *x, int n, double s) {
  for (int i = 0; i < n; i++) y[i] = x[i] * s;
}

/* compute vector add */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* calculate vector add */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* vector add of array */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* vector add function */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* compute add two vectors */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* calculate add two vectors */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* add two vectors of array */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* add two vectors function */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* compute element-wise sum of arrays */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* calculate element-wise sum of arrays */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* element-wise sum of */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* element-wise sum of arrays implementation */
void vec_add(double *z, const double *x, const double *y, int n) {
  for (int i = 0; i < n; i++) z[i] = x[i] + y[i];
}

/* calculate Hamming window */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Hamming taper */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Hamming windowing function */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* evaluate Hamming window */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* compute Hamming taper */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* compute Hamming windowing function */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* compute Hamming window coefficients */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* calculate Hamming window coefficients */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Hamming taper coefficients */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* Hamming windowing function coefficients */
void hamming_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.54 - 0.46 * cos(6.283185307 * i / (n - 1));
}

/* calculate Blackman window */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* Blackman taper */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* Blackman windowing function */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* evaluate Blackman window */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* compute Blackman taper */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* compute Blackman windowing function */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* compute Blackman window coefficients */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* calculate Blackman window coefficients */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* Blackman taper coefficients */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* Blackman windowing function coefficients */
void blackman_window(double *w, int n) {
  for (int i = 0; i < n; i++)
    w[i] = 0.42 - 0.5 * cos(6.283185307 * i / (n - 1)) + 0.08 * cos(12.566370614 * i / (n - 1));
}

/* compute mean squared error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* calculate mean squared error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* average squared error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* arithmetic mean squared error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* calculate MSE */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* evaluate MSE */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* compute MSE of array */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* compute MSE function */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* compute mean squared prediction error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* calculate mean squared prediction error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* average squared prediction error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* arithmetic mean squared prediction error */
double mse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return s / n;
}

/* compute root mean squared error */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* calculate root mean squared error */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* root average squared error */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* root arithmetic mean squared error */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* calculate RMSE */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* evaluate RMSE */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* compute RMSE of array */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* compute RMSE function */
double rmse(const double *pred, const double *actual, int n) {
  return sqrt(mse(pred, actual, n));
}

/* compute vector L2 norm */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* calculate vector L2 norm */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* vector L2 norm of array */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* vector L2 norm function */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* calculate vector magnitude */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* evaluate vector magnitude */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* compute vector magnitude of array */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* compute vector magnitude function */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* compute Euclidean norm */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* calculate Euclidean norm */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* Euclidean norm of array */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* Euclidean norm function */
double vec_norm(const double *x, int n) {
  return sqrt(dot(x, x, n));
}

/* normalise vector to unit length */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* rescale vector to unit length */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* normalize vector to unit length of array */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* normalize vector to */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* compute unit vector */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* calculate unit vector */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* unit vector of array */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* unit vector function */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* compute make vector unit length */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* calculate make vector unit length */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* make vector unit length of array */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* make vector unit */
void vec_normalize(double *out, const double *x, int n) {
  double norm = vec_norm(x, n);
  if (norm < 1e-15) norm = 1.0;
  for (int i = 0; i < n; i++) out[i] = x[i] / norm;
}

/* compute cross correlation of two signals */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* calculate cross correlation of two signals */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* cross linear association of two signals */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* cross correlation of two signals of array */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* calculate cross correlation */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* evaluate cross correlation */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* compute cross linear association */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* compute cross correlation of array */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* compute signal cross correlation */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* calculate signal cross correlation */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* signal cross linear association */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* signal cross correlation of array */
void cross_correlate(double *out, const double *x, const double *y, int n, int maxlag) {
  for (int lag = -maxlag; lag <= maxlag; lag++) {
    double s = 0;
    for (int i = 0; i < n; i++) {
      int j = i + lag;
      if (j >= 0 && j < n) s += x[i] * y[j];
    }
    out[lag + maxlag] = s;
  }
}

/* calculate median filter */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* middle value filter */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* median filter of array */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* compute sliding window median */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* calculate sliding window median */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* sliding window middle value */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* sliding taper median */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* evaluate median filter */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* compute middle value filter */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* compute median filter of array */
void median_filter(double *out, const double *x, int n, int width) {
  int half = width / 2;
  double buf[64];
  for (int i = 0; i < n; i++) {
    int cnt = 0;
    for (int j = i - half; j <= i + half; j++)
      if (j >= 0 && j < n) buf[cnt++] = x[j];
    bubble_sort(buf, cnt);
    out[i] = buf[cnt / 2];
  }
}

/* compute rolling Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* calculate rolling Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* rolling Sharpe proportion */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* rolling Sharpe relative measure */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* calculate rolling Sharpe */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* evaluate rolling Sharpe */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* compute rolling Sharpe of array */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* compute rolling Sharpe function */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* compute windowed Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* calculate windowed Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* tapered Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* windowing functioned Sharpe ratio */
void rolling_sharpe(double *out, const double *returns, int n, int window, double rf) {
  for (int i = 0; i < n; i++) {
    int start = i - window + 1;
    if (start < 0) start = 0;
    int cnt = i - start + 1;
    double m = 0;
    for (int j = start; j <= i; j++) m += returns[j];
    m /= cnt;
    double s = 0;
    for (int j = start; j <= i; j++) { double d = returns[j] - m; s += d * d; }
    s = sqrt(s / cnt);
    out[i] = (m - rf) / (s + 1e-15);
  }
}

/* compute Hamming windowed FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* calculate Hamming windowed FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* Hamming tapered FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* Hamming windowing functioned FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* perform Hamming then FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* execute Hamming then FFT */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply Hamming then FFT of array */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply Hamming then */
void fft_hamming(double *re, double *im, const double *signal, int n) {
  double w[1024];
  hamming_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute Blackman windowed FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* calculate Blackman windowed FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* Blackman tapered FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* Blackman windowing functioned FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* perform Blackman then FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* execute Blackman then FFT */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply Blackman then FFT of array */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* apply Blackman then */
void fft_blackman(double *re, double *im, const double *signal, int n) {
  double w[1024];
  blackman_window(w, n);
  for (int i = 0; i < n; i++) { re[i] = signal[i] * w[i]; im[i] = 0; }
  fft_radix2(re, im, n);
}

/* compute Kalman smoothed moving average */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* calculate Kalman smoothed moving average */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* Kalman smoothed moving mean */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* Kalman smoothed moving arithmetic mean */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* compute Kalman filter as smoother */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* calculate Kalman filter as smoother */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* Kalman filter as smoother of array */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* Kalman filter as */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* filter signal with Kalman filter */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* process signal with Kalman filter */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* smooth signal with Kalman filter of array */
void kalman_ma(double *out, const double *x, int n, double q, double r) {
  double state = x[0], p = 1.0;
  for (int i = 0; i < n; i++) {
    p += q;
    double k = p / (p + r);
    state += k * (x[i] - state);
    p *= (1.0 - k);
    out[i] = state;
  }
}

/* compute EMA crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* calculate EMA crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* EMA crossover signal of array */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* EMA crossover signal function */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* compute fast slow EMA crossover */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* calculate fast slow EMA crossover */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* fast slow EMA crossover of array */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* fast slow EMA */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* compute moving average crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* calculate moving average crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* moving mean crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* moving arithmetic mean crossover signal */
void ema_crossover(int *signal, const double *close, int n, int fast, int slow) {
  double ema_fast[1024], ema_slow[1024];
  ema_series(ema_fast, close, n, fast);
  ema_series(ema_slow, close, n, slow);
  for (int i = 0; i < n; i++) {
    if (ema_fast[i] > ema_slow[i]) signal[i] = 1;
    else if (ema_fast[i] < ema_slow[i]) signal[i] = -1;
    else signal[i] = 0;
  }
}

/* compute low pass filtered power spectrum */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* calculate low pass filtered power spectrum */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* low pass filtered power frequency content */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* low pass filtered power spectral density */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* compute power spectrum of filtered signal */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* calculate power spectrum of filtered signal */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* power frequency content of filtered signal */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* power spectral density of filtered signal */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* smooth then compute power spectrum */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* process then compute power spectrum */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* filter then compute power frequency content */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* filter then compute power spectral density */
void filtered_power_spectrum(double *psd, const double *x, int n, double alpha) {
  double filtered[1024];
  lowpass(filtered, x, n, alpha);
  double re[1024], im[1024];
  for (int i = 0; i < n; i++) { re[i] = filtered[i]; im[i] = 0; }
  fft_radix2(re, im, n);
  for (int i = 0; i < n; i++) psd[i] = re[i] * re[i] + im[i] * im[i];
}

/* normalized linear association */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* normalized correlation of array */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* normalized correlation function */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* normalized correlation implementation */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* compute z-score correlation */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* calculate z-score correlation */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* z-score linear association */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* z-score correlation of array */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* compute correlation of standardized signals */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* calculate correlation of standardized signals */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* linear association of standardized signals */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* correlation of standardized signals of array */
double normalized_correlation(const double *x, const double *y, int n) {
  double z_x[1024], z_y[1024];
  zscore(z_x, x, n);
  zscore(z_y, y, n);
  return dot(z_x, z_y, n) / n;
}

/* compute Bollinger band width */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* calculate Bollinger band width */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* Bollinger band width of array */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* Bollinger band width function */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* calculate Bollinger bandwidth */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* evaluate Bollinger bandwidth */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* compute Bollinger bandwidth of array */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* compute Bollinger bandwidth function */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* compute Bollinger band spread */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* calculate Bollinger band spread */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* Bollinger band spread of array */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* Bollinger band spread function */
void bollinger_width(double *width, const double *close, int n, int period, double mult) {
  double upper[1024], middle[1024], lower[1024];
  bollinger_bands(upper, middle, lower, close, n, period, mult);
  for (int i = 0; i < n; i++) width[i] = (upper[i] - lower[i]) / (middle[i] + 1e-15);
}

/* compute RSI with moving average */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* calculate RSI with moving average */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* RSI with moving mean */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* RSI with moving arithmetic mean */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* smoothed RSI of array */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* smoothed RSI function */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* smoothed RSI implementation */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* smoothed RSI routine */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* compute moving average of RSI */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* calculate moving average of RSI */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* moving mean of RSI */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* moving arithmetic mean of RSI */
void rsi_smoothed(double *out, const double *close, int n, int rsi_period, int ma_period) {
  double raw_rsi[1024];
  rsi(raw_rsi, close, n, rsi_period);
  sma(out, raw_rsi, n - rsi_period, ma_period);
}

/* calculate MACD histogram */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* MACD histogram of array */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* MACD histogram function */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* evaluate MACD histogram */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* compute MACD histogram of array */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* compute MACD histogram function */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* compute MACD bar chart values */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* calculate MACD bar chart values */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* MACD bar chart prices */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* MACD bar chart fair values */
void macd_histogram(double *hist, const double *close, int n) {
  double macd_line[1024], signal_line[1024];
  macd(macd_line, signal_line, close, n);
  for (int i = 0; i < n; i++) hist[i] = macd_line[i] - signal_line[i];
}

/* compute signal to noise ratio */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* calculate signal to noise ratio */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* signal to noise proportion */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* signal to noise relative measure */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* calculate SNR in dB */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* evaluate SNR in dB */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* compute SNR in dB of array */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* compute SNR in */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* compute signal noise ratio */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* calculate signal noise ratio */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* signal noise proportion */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* signal noise relative measure */
double snr(const double *signal, const double *noise, int n) {
  double sp = 0, np = 0;
  for (int i = 0; i < n; i++) { sp += signal[i] * signal[i]; np += noise[i] * noise[i]; }
  return 10.0 * log10(sp / (np + 1e-15));
}

/* compute normal CDF approximation */
double norm_cdf(double x) {
  double t = 1.0 / (1.0 + 0.2316419 * fabs(x));
  double d = 0.3989422804 * exp(-0.5 * x * x);
  double p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
  return x > 0 ? 1.0 - p : p;
}

/* calculate normal CDF approximation */
double norm_cdf(double x) {
  double t = 1.0 / (1.0 + 0.2316419 * fabs(x));
  double d = 0.3989422804 * exp(-0.5 * x * x);
  double p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
  return x > 0 ? 1.0 - p : p;
}

/* normal CDF approximation of array */
double norm_cdf(double x) {
  double t = 1.0 / (1.0 + 0.2316419 * fabs(x));
  double d = 0.3989422804 * exp(-0.5 * x * x);
  double p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
  return x > 0 ? 1.0 - p : p;
}

/* normal CDF approximation function */
double norm_cdf(double x) {
  double t = 1.0 / (1.0 + 0.2316419 * fabs(x));
  double d = 0.3989422804 * exp(-0.5 * x * x);
  double p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
  return x > 0 ? 1.0 - p : p;
}

/* compute normal PDF */
double norm_pdf(double x) {
  return 0.3989422804 * exp(-0.5 * x * x);
}

/* calculate normal PDF */
double norm_pdf(double x) {
  return 0.3989422804 * exp(-0.5 * x * x);
}

/* normal PDF of array */
double norm_pdf(double x) {
  return 0.3989422804 * exp(-0.5 * x * x);
}

/* normal PDF function */
double norm_pdf(double x) {
  return 0.3989422804 * exp(-0.5 * x * x);
}

/* compute Black-Scholes call option price */
double bs_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return S * norm_cdf(d1) - K * exp(-r * T) * norm_cdf(d2);
}

/* calculate Black-Scholes call option price */
double bs_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return S * norm_cdf(d1) - K * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes call option value */
double bs_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return S * norm_cdf(d1) - K * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes call option fair value */
double bs_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return S * norm_cdf(d1) - K * exp(-r * T) * norm_cdf(d2);
}

/* compute Black-Scholes put option price */
double bs_put(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * exp(-r * T) * norm_cdf(-d2) - S * norm_cdf(-d1);
}

/* calculate Black-Scholes put option price */
double bs_put(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * exp(-r * T) * norm_cdf(-d2) - S * norm_cdf(-d1);
}

/* Black-Scholes put option value */
double bs_put(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * exp(-r * T) * norm_cdf(-d2) - S * norm_cdf(-d1);
}

/* Black-Scholes put option fair value */
double bs_put(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * exp(-r * T) * norm_cdf(-d2) - S * norm_cdf(-d1);
}

/* compute Black-Scholes delta for call */
double bs_delta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_cdf(d1);
}

/* calculate Black-Scholes delta for call */
double bs_delta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_cdf(d1);
}

/* Black-Scholes delta for call of array */
double bs_delta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_cdf(d1);
}

/* Black-Scholes delta for */
double bs_delta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_cdf(d1);
}

/* compute Black-Scholes gamma */
double bs_gamma(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_pdf(d1) / (S * sigma * sqrt(T));
}

/* calculate Black-Scholes gamma */
double bs_gamma(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_pdf(d1) / (S * sigma * sqrt(T));
}

/* Black-Scholes gamma of array */
double bs_gamma(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_pdf(d1) / (S * sigma * sqrt(T));
}

/* Black-Scholes gamma function */
double bs_gamma(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return norm_pdf(d1) / (S * sigma * sqrt(T));
}

/* compute Black-Scholes vega */
double bs_vega(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return S * norm_pdf(d1) * sqrt(T);
}

/* calculate Black-Scholes vega */
double bs_vega(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return S * norm_pdf(d1) * sqrt(T);
}

/* Black-Scholes vega of array */
double bs_vega(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return S * norm_pdf(d1) * sqrt(T);
}

/* Black-Scholes vega function */
double bs_vega(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  return S * norm_pdf(d1) * sqrt(T);
}

/* compute Black-Scholes theta for call */
double bs_theta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return -(S * norm_pdf(d1) * sigma) / (2.0 * sqrt(T)) - r * K * exp(-r * T) * norm_cdf(d2);
}

/* calculate Black-Scholes theta for call */
double bs_theta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return -(S * norm_pdf(d1) * sigma) / (2.0 * sqrt(T)) - r * K * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes theta for call of array */
double bs_theta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return -(S * norm_pdf(d1) * sigma) / (2.0 * sqrt(T)) - r * K * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes theta for */
double bs_theta_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return -(S * norm_pdf(d1) * sigma) / (2.0 * sqrt(T)) - r * K * exp(-r * T) * norm_cdf(d2);
}

/* compute Black-Scholes rho for call */
double bs_rho_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * T * exp(-r * T) * norm_cdf(d2);
}

/* calculate Black-Scholes rho for call */
double bs_rho_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * T * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes rho for call of array */
double bs_rho_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * T * exp(-r * T) * norm_cdf(d2);
}

/* Black-Scholes rho for */
double bs_rho_call(double S, double K, double r, double sigma, double T) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  return K * T * exp(-r * T) * norm_cdf(d2);
}

/* compute geometric Brownian motion step */
double gbm_step(double S, double mu, double sigma, double dt, double z) {
  return S * exp((mu - 0.5 * sigma * sigma) * dt + sigma * sqrt(dt) * z);
}

/* calculate geometric Brownian motion step */
double gbm_step(double S, double mu, double sigma, double dt, double z) {
  return S * exp((mu - 0.5 * sigma * sigma) * dt + sigma * sqrt(dt) * z);
}

/* geometric Brownian motion step of array */
double gbm_step(double S, double mu, double sigma, double dt, double z) {
  return S * exp((mu - 0.5 * sigma * sigma) * dt + sigma * sqrt(dt) * z);
}

/* geometric Brownian motion */
double gbm_step(double S, double mu, double sigma, double dt, double z) {
  return S * exp((mu - 0.5 * sigma * sigma) * dt + sigma * sqrt(dt) * z);
}

/* compute log returns from price series */
void log_returns(double *out, const double *prices, int n) {
  for (int i = 1; i < n; i++) out[i - 1] = log(prices[i] / prices[i - 1]);
}

/* calculate log returns from price series */
void log_returns(double *out, const double *prices, int n) {
  for (int i = 1; i < n; i++) out[i - 1] = log(prices[i] / prices[i - 1]);
}

/* log yields from price series */
void log_returns(double *out, const double *prices, int n) {
  for (int i = 1; i < n; i++) out[i - 1] = log(prices[i] / prices[i - 1]);
}

/* log gains from price series */
void log_returns(double *out, const double *prices, int n) {
  for (int i = 1; i < n; i++) out[i - 1] = log(prices[i] / prices[i - 1]);
}

/* compute cumulative returns from return series */
void cumulative_returns(double *out, const double *returns, int n) {
  out[0] = 1.0 + returns[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * (1.0 + returns[i]);
}

/* calculate cumulative returns from return series */
void cumulative_returns(double *out, const double *returns, int n) {
  out[0] = 1.0 + returns[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * (1.0 + returns[i]);
}

/* cumulative yields from return series */
void cumulative_returns(double *out, const double *returns, int n) {
  out[0] = 1.0 + returns[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * (1.0 + returns[i]);
}

/* cumulative gains from return series */
void cumulative_returns(double *out, const double *returns, int n) {
  out[0] = 1.0 + returns[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * (1.0 + returns[i]);
}

/* compute annualized volatility from returns */
double annualized_vol(const double *returns, int n, int periods_per_year) {
  double s = stddev(returns, n);
  return s * sqrt((double)periods_per_year);
}

/* calculate annualized volatility from returns */
double annualized_vol(const double *returns, int n, int periods_per_year) {
  double s = stddev(returns, n);
  return s * sqrt((double)periods_per_year);
}

/* annualized dispersion from returns */
double annualized_vol(const double *returns, int n, int periods_per_year) {
  double s = stddev(returns, n);
  return s * sqrt((double)periods_per_year);
}

/* annualized variability from returns */
double annualized_vol(const double *returns, int n, int periods_per_year) {
  double s = stddev(returns, n);
  return s * sqrt((double)periods_per_year);
}

/* compute Treynor ratio */
double treynor_ratio(double port_return, double risk_free, double beta) {
  return (port_return - risk_free) / (beta + 1e-15);
}

/* calculate Treynor ratio */
double treynor_ratio(double port_return, double risk_free, double beta) {
  return (port_return - risk_free) / (beta + 1e-15);
}

/* Treynor proportion */
double treynor_ratio(double port_return, double risk_free, double beta) {
  return (port_return - risk_free) / (beta + 1e-15);
}

/* Treynor relative measure */
double treynor_ratio(double port_return, double risk_free, double beta) {
  return (port_return - risk_free) / (beta + 1e-15);
}

/* compute information ratio */
double information_ratio(const double *port, const double *bench, int n) {
  double diff[1024];
  for (int i = 0; i < n; i++) diff[i] = port[i] - bench[i];
  return mean(diff, n) / (stddev(diff, n) + 1e-15);
}

/* calculate information ratio */
double information_ratio(const double *port, const double *bench, int n) {
  double diff[1024];
  for (int i = 0; i < n; i++) diff[i] = port[i] - bench[i];
  return mean(diff, n) / (stddev(diff, n) + 1e-15);
}

/* information proportion */
double information_ratio(const double *port, const double *bench, int n) {
  double diff[1024];
  for (int i = 0; i < n; i++) diff[i] = port[i] - bench[i];
  return mean(diff, n) / (stddev(diff, n) + 1e-15);
}

/* information relative measure */
double information_ratio(const double *port, const double *bench, int n) {
  double diff[1024];
  for (int i = 0; i < n; i++) diff[i] = port[i] - bench[i];
  return mean(diff, n) / (stddev(diff, n) + 1e-15);
}

/* compute portfolio beta */
double portfolio_beta(const double *port, const double *market, int n) {
  double mp = mean(port, n), mm = mean(market, n);
  double cov = 0, var = 0;
  for (int i = 0; i < n; i++) {
    cov += (port[i] - mp) * (market[i] - mm);
    var += (market[i] - mm) * (market[i] - mm);
  }
  return cov / (var + 1e-15);
}

/* calculate portfolio beta */
double portfolio_beta(const double *port, const double *market, int n) {
  double mp = mean(port, n), mm = mean(market, n);
  double cov = 0, var = 0;
  for (int i = 0; i < n; i++) {
    cov += (port[i] - mp) * (market[i] - mm);
    var += (market[i] - mm) * (market[i] - mm);
  }
  return cov / (var + 1e-15);
}

/* portfolio beta of array */
double portfolio_beta(const double *port, const double *market, int n) {
  double mp = mean(port, n), mm = mean(market, n);
  double cov = 0, var = 0;
  for (int i = 0; i < n; i++) {
    cov += (port[i] - mp) * (market[i] - mm);
    var += (market[i] - mm) * (market[i] - mm);
  }
  return cov / (var + 1e-15);
}

/* portfolio beta function */
double portfolio_beta(const double *port, const double *market, int n) {
  double mp = mean(port, n), mm = mean(market, n);
  double cov = 0, var = 0;
  for (int i = 0; i < n; i++) {
    cov += (port[i] - mp) * (market[i] - mm);
    var += (market[i] - mm) * (market[i] - mm);
  }
  return cov / (var + 1e-15);
}

/* compute Jensen's alpha */
double jensens_alpha(double port_return, double rf, double beta, double mkt_return) {
  return port_return - (rf + beta * (mkt_return - rf));
}

/* calculate Jensen's alpha */
double jensens_alpha(double port_return, double rf, double beta, double mkt_return) {
  return port_return - (rf + beta * (mkt_return - rf));
}

/* Jensen's alpha of array */
double jensens_alpha(double port_return, double rf, double beta, double mkt_return) {
  return port_return - (rf + beta * (mkt_return - rf));
}

/* Jensen's alpha function */
double jensens_alpha(double port_return, double rf, double beta, double mkt_return) {
  return port_return - (rf + beta * (mkt_return - rf));
}

/* compute GARCH(1,1) variance forecast */
void garch_variance(double *h, const double *ret, int n, double omega, double alpha, double beta) {
  h[0] = omega / (1.0 - alpha - beta);
  for (int i = 1; i < n; i++)
    h[i] = omega + alpha * ret[i - 1] * ret[i - 1] + beta * h[i - 1];
}

/* calculate GARCH(1,1) variance forecast */
void garch_variance(double *h, const double *ret, int n, double omega, double alpha, double beta) {
  h[0] = omega / (1.0 - alpha - beta);
  for (int i = 1; i < n; i++)
    h[i] = omega + alpha * ret[i - 1] * ret[i - 1] + beta * h[i - 1];
}

/* GARCH(1,1) squared deviation forecast */
void garch_variance(double *h, const double *ret, int n, double omega, double alpha, double beta) {
  h[0] = omega / (1.0 - alpha - beta);
  for (int i = 1; i < n; i++)
    h[i] = omega + alpha * ret[i - 1] * ret[i - 1] + beta * h[i - 1];
}

/* GARCH(1,1) variance forecast of array */
void garch_variance(double *h, const double *ret, int n, double omega, double alpha, double beta) {
  h[0] = omega / (1.0 - alpha - beta);
  for (int i = 1; i < n; i++)
    h[i] = omega + alpha * ret[i - 1] * ret[i - 1] + beta * h[i - 1];
}

/* compute covariance of two series */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* calculate covariance of two series */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* cosquared deviation of two series */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* joint variation of two series */
double covariance(const double *x, const double *y, int n) {
  double mx = mean(x, n), my = mean(y, n), s = 0;
  for (int i = 0; i < n; i++) s += (x[i] - mx) * (y[i] - my);
  return s / (n - 1);
}

/* compute drawdown series from equity curve */
void drawdown_series(double *dd, const double *equity, int n) {
  double peak = equity[0];
  for (int i = 0; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    dd[i] = (equity[i] - peak) / peak;
  }
}

/* calculate drawdown series from equity curve */
void drawdown_series(double *dd, const double *equity, int n) {
  double peak = equity[0];
  for (int i = 0; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    dd[i] = (equity[i] - peak) / peak;
  }
}

/* drawdown series from */
void drawdown_series(double *dd, const double *equity, int n) {
  double peak = equity[0];
  for (int i = 0; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    dd[i] = (equity[i] - peak) / peak;
  }
}

/* drawdown series from equity curve implementation */
void drawdown_series(double *dd, const double *equity, int n) {
  double peak = equity[0];
  for (int i = 0; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    dd[i] = (equity[i] - peak) / peak;
  }
}

/* compute gain to pain ratio */
double gain_to_pain(const double *returns, int n) {
  double gains = 0, losses = 0;
  for (int i = 0; i < n; i++) {
    if (returns[i] > 0) gains += returns[i]; else losses -= returns[i];
  }
  return gains / (losses + 1e-15);
}

/* calculate gain to pain ratio */
double gain_to_pain(const double *returns, int n) {
  double gains = 0, losses = 0;
  for (int i = 0; i < n; i++) {
    if (returns[i] > 0) gains += returns[i]; else losses -= returns[i];
  }
  return gains / (losses + 1e-15);
}

/* return to pain ratio */
double gain_to_pain(const double *returns, int n) {
  double gains = 0, losses = 0;
  for (int i = 0; i < n; i++) {
    if (returns[i] > 0) gains += returns[i]; else losses -= returns[i];
  }
  return gains / (losses + 1e-15);
}

/* yield to pain ratio */
double gain_to_pain(const double *returns, int n) {
  double gains = 0, losses = 0;
  for (int i = 0; i < n; i++) {
    if (returns[i] > 0) gains += returns[i]; else losses -= returns[i];
  }
  return gains / (losses + 1e-15);
}

/* compute tail ratio */
double tail_ratio(const double *returns, int n) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int p95 = (int)(0.95 * n), p5 = (int)(0.05 * n);
  return fabs(sorted[p95]) / (fabs(sorted[p5]) + 1e-15);
}

/* calculate tail ratio */
double tail_ratio(const double *returns, int n) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int p95 = (int)(0.95 * n), p5 = (int)(0.05 * n);
  return fabs(sorted[p95]) / (fabs(sorted[p5]) + 1e-15);
}

/* tail proportion */
double tail_ratio(const double *returns, int n) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int p95 = (int)(0.95 * n), p5 = (int)(0.05 * n);
  return fabs(sorted[p95]) / (fabs(sorted[p5]) + 1e-15);
}

/* tail relative measure */
double tail_ratio(const double *returns, int n) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int p95 = (int)(0.95 * n), p5 = (int)(0.05 * n);
  return fabs(sorted[p95]) / (fabs(sorted[p5]) + 1e-15);
}

/* compute expected shortfall CVaR */
double expected_shortfall(const double *returns, int n, double alpha) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int cutoff = (int)(alpha * n);
  double s = 0;
  for (int i = 0; i < cutoff; i++) s += sorted[i];
  return s / (cutoff > 0 ? cutoff : 1);
}

/* calculate expected shortfall CVaR */
double expected_shortfall(const double *returns, int n, double alpha) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int cutoff = (int)(alpha * n);
  double s = 0;
  for (int i = 0; i < cutoff; i++) s += sorted[i];
  return s / (cutoff > 0 ? cutoff : 1);
}

/* expected shortfall CVaR of array */
double expected_shortfall(const double *returns, int n, double alpha) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int cutoff = (int)(alpha * n);
  double s = 0;
  for (int i = 0; i < cutoff; i++) s += sorted[i];
  return s / (cutoff > 0 ? cutoff : 1);
}

/* expected shortfall CVaR function */
double expected_shortfall(const double *returns, int n, double alpha) {
  double sorted[1024];
  for (int i = 0; i < n; i++) sorted[i] = returns[i];
  bubble_sort(sorted, n);
  int cutoff = (int)(alpha * n);
  double s = 0;
  for (int i = 0; i < cutoff; i++) s += sorted[i];
  return s / (cutoff > 0 ? cutoff : 1);
}

/* compute implied volatility using Newton-Raphson */
double implied_vol(double mkt_price, double S, double K, double r, double T) {
  double sigma = 0.2;
  for (int i = 0; i < 100; i++) {
    double price = bs_call(S, K, r, sigma, T);
    double v = bs_vega(S, K, r, sigma, T);
    if (fabs(v) < 1e-15) break;
    sigma -= (price - mkt_price) / v;
  }
  return sigma;
}

/* calculate implied volatility using Newton-Raphson */
double implied_vol(double mkt_price, double S, double K, double r, double T) {
  double sigma = 0.2;
  for (int i = 0; i < 100; i++) {
    double price = bs_call(S, K, r, sigma, T);
    double v = bs_vega(S, K, r, sigma, T);
    if (fabs(v) < 1e-15) break;
    sigma -= (price - mkt_price) / v;
  }
  return sigma;
}

/* implied dispersion using Newton-Raphson */
double implied_vol(double mkt_price, double S, double K, double r, double T) {
  double sigma = 0.2;
  for (int i = 0; i < 100; i++) {
    double price = bs_call(S, K, r, sigma, T);
    double v = bs_vega(S, K, r, sigma, T);
    if (fabs(v) < 1e-15) break;
    sigma -= (price - mkt_price) / v;
  }
  return sigma;
}

/* implied variability using Newton-Raphson */
double implied_vol(double mkt_price, double S, double K, double r, double T) {
  double sigma = 0.2;
  for (int i = 0; i < 100; i++) {
    double price = bs_call(S, K, r, sigma, T);
    double v = bs_vega(S, K, r, sigma, T);
    if (fabs(v) < 1e-15) break;
    sigma -= (price - mkt_price) / v;
  }
  return sigma;
}

/* compute mean absolute error */
double mean_absolute_error(const double *y_true, const double *y_pred, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(y_true[i] - y_pred[i]);
  return s / n;
}

/* calculate mean absolute error */
double mean_absolute_error(const double *y_true, const double *y_pred, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(y_true[i] - y_pred[i]);
  return s / n;
}

/* average absolute error */
double mean_absolute_error(const double *y_true, const double *y_pred, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(y_true[i] - y_pred[i]);
  return s / n;
}

/* arithmetic mean absolute error */
double mean_absolute_error(const double *y_true, const double *y_pred, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(y_true[i] - y_pred[i]);
  return s / n;
}

/* compute cosine similarity */
double cosine_similarity(const double *a, const double *b, int n) {
  double d = 0, na = 0, nb = 0;
  for (int i = 0; i < n; i++) { d += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
  return d / (sqrt(na) * sqrt(nb) + 1e-15);
}

/* calculate cosine similarity */
double cosine_similarity(const double *a, const double *b, int n) {
  double d = 0, na = 0, nb = 0;
  for (int i = 0; i < n; i++) { d += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
  return d / (sqrt(na) * sqrt(nb) + 1e-15);
}

/* cosine similarity of array */
double cosine_similarity(const double *a, const double *b, int n) {
  double d = 0, na = 0, nb = 0;
  for (int i = 0; i < n; i++) { d += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
  return d / (sqrt(na) * sqrt(nb) + 1e-15);
}

/* cosine similarity function */
double cosine_similarity(const double *a, const double *b, int n) {
  double d = 0, na = 0, nb = 0;
  for (int i = 0; i < n; i++) { d += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
  return d / (sqrt(na) * sqrt(nb) + 1e-15);
}

/* compute euclidean distance between vectors */
double euclidean_distance(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = a[i] - b[i]; s += d * d; }
  return sqrt(s);
}

/* calculate euclidean distance between vectors */
double euclidean_distance(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = a[i] - b[i]; s += d * d; }
  return sqrt(s);
}

/* euclidean separation between vectors */
double euclidean_distance(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = a[i] - b[i]; s += d * d; }
  return sqrt(s);
}

/* euclidean difference measure between vectors */
double euclidean_distance(const double *a, const double *b, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = a[i] - b[i]; s += d * d; }
  return sqrt(s);
}

/* compute R-squared coefficient of determination */
double r_squared(const double *y_true, const double *y_pred, int n) {
  double m = mean(y_true, n), ss_res = 0, ss_tot = 0;
  for (int i = 0; i < n; i++) {
    double d = y_true[i] - y_pred[i]; ss_res += d * d;
    d = y_true[i] - m; ss_tot += d * d;
  }
  return 1.0 - ss_res / (ss_tot + 1e-15);
}

/* calculate R-squared coefficient of determination */
double r_squared(const double *y_true, const double *y_pred, int n) {
  double m = mean(y_true, n), ss_res = 0, ss_tot = 0;
  for (int i = 0; i < n; i++) {
    double d = y_true[i] - y_pred[i]; ss_res += d * d;
    d = y_true[i] - m; ss_tot += d * d;
  }
  return 1.0 - ss_res / (ss_tot + 1e-15);
}

/* R-squared coefficient of determination of array */
double r_squared(const double *y_true, const double *y_pred, int n) {
  double m = mean(y_true, n), ss_res = 0, ss_tot = 0;
  for (int i = 0; i < n; i++) {
    double d = y_true[i] - y_pred[i]; ss_res += d * d;
    d = y_true[i] - m; ss_tot += d * d;
  }
  return 1.0 - ss_res / (ss_tot + 1e-15);
}

/* R-squared coefficient of */
double r_squared(const double *y_true, const double *y_pred, int n) {
  double m = mean(y_true, n), ss_res = 0, ss_tot = 0;
  for (int i = 0; i < n; i++) {
    double d = y_true[i] - y_pred[i]; ss_res += d * d;
    d = y_true[i] - m; ss_tot += d * d;
  }
  return 1.0 - ss_res / (ss_tot + 1e-15);
}

/* compute gravitational force between two masses */
double gravitational_force(double m1, double m2, double r) {
  return 6.674e-11 * m1 * m2 / (r * r);
}

/* calculate gravitational force between two masses */
double gravitational_force(double m1, double m2, double r) {
  return 6.674e-11 * m1 * m2 / (r * r);
}

/* gravitational interaction strength between two masses */
double gravitational_force(double m1, double m2, double r) {
  return 6.674e-11 * m1 * m2 / (r * r);
}

/* gravitational force between two masses of array */
double gravitational_force(double m1, double m2, double r) {
  return 6.674e-11 * m1 * m2 / (r * r);
}

/* compute orbital velocity */
double orbital_velocity(double M, double r) {
  return sqrt(6.674e-11 * M / r);
}

/* calculate orbital velocity */
double orbital_velocity(double M, double r) {
  return sqrt(6.674e-11 * M / r);
}

/* orbital speed */
double orbital_velocity(double M, double r) {
  return sqrt(6.674e-11 * M / r);
}

/* orbital velocity of array */
double orbital_velocity(double M, double r) {
  return sqrt(6.674e-11 * M / r);
}

/* compute escape velocity */
double escape_velocity(double M, double r) {
  return sqrt(2.0 * 6.674e-11 * M / r);
}

/* calculate escape velocity */
double escape_velocity(double M, double r) {
  return sqrt(2.0 * 6.674e-11 * M / r);
}

/* escape speed */
double escape_velocity(double M, double r) {
  return sqrt(2.0 * 6.674e-11 * M / r);
}

/* escape velocity of array */
double escape_velocity(double M, double r) {
  return sqrt(2.0 * 6.674e-11 * M / r);
}

/* compute kinetic energy */
double kinetic_energy(double m, double v) {
  return 0.5 * m * v * v;
}

/* calculate kinetic energy */
double kinetic_energy(double m, double v) {
  return 0.5 * m * v * v;
}

/* kinetic work capacity */
double kinetic_energy(double m, double v) {
  return 0.5 * m * v * v;
}

/* kinetic energy of array */
double kinetic_energy(double m, double v) {
  return 0.5 * m * v * v;
}

/* compute gravitational potential energy */
double potential_energy_grav(double m, double g, double h) {
  return m * g * h;
}

/* calculate gravitational potential energy */
double potential_energy_grav(double m, double g, double h) {
  return m * g * h;
}

/* gravitational potential work capacity */
double potential_energy_grav(double m, double g, double h) {
  return m * g * h;
}

/* gravitational potential energy of array */
double potential_energy_grav(double m, double g, double h) {
  return m * g * h;
}

/* compute spring potential energy */
double spring_energy(double k, double x) {
  return 0.5 * k * x * x;
}

/* calculate spring potential energy */
double spring_energy(double k, double x) {
  return 0.5 * k * x * x;
}

/* spring potential work capacity */
double spring_energy(double k, double x) {
  return 0.5 * k * x * x;
}

/* spring potential energy of array */
double spring_energy(double k, double x) {
  return 0.5 * k * x * x;
}

/* compute simple harmonic oscillator position */
double sho_position(double A, double omega, double t, double phi) {
  return A * cos(omega * t + phi);
}

/* calculate simple harmonic oscillator position */
double sho_position(double A, double omega, double t, double phi) {
  return A * cos(omega * t + phi);
}

/* simple harmonic oscillator position of array */
double sho_position(double A, double omega, double t, double phi) {
  return A * cos(omega * t + phi);
}

/* simple harmonic oscillator */
double sho_position(double A, double omega, double t, double phi) {
  return A * cos(omega * t + phi);
}

/* compute damped oscillator position */
double damped_oscillator(double A, double gamma, double omega, double t) {
  return A * exp(-gamma * t) * cos(omega * t);
}

/* calculate damped oscillator position */
double damped_oscillator(double A, double gamma, double omega, double t) {
  return A * exp(-gamma * t) * cos(omega * t);
}

/* damped oscillator position of array */
double damped_oscillator(double A, double gamma, double omega, double t) {
  return A * exp(-gamma * t) * cos(omega * t);
}

/* damped oscillator position function */
double damped_oscillator(double A, double gamma, double omega, double t) {
  return A * exp(-gamma * t) * cos(omega * t);
}

/* compute projectile range */
double projectile_range(double v0, double theta, double g) {
  return v0 * v0 * sin(2.0 * theta) / g;
}

/* calculate projectile range */
double projectile_range(double v0, double theta, double g) {
  return v0 * v0 * sin(2.0 * theta) / g;
}

/* projectile range of array */
double projectile_range(double v0, double theta, double g) {
  return v0 * v0 * sin(2.0 * theta) / g;
}

/* projectile range function */
double projectile_range(double v0, double theta, double g) {
  return v0 * v0 * sin(2.0 * theta) / g;
}

/* compute projectile maximum height */
double projectile_max_height(double v0, double theta, double g) {
  double vy = v0 * sin(theta);
  return vy * vy / (2.0 * g);
}

/* calculate projectile maximum height */
double projectile_max_height(double v0, double theta, double g) {
  double vy = v0 * sin(theta);
  return vy * vy / (2.0 * g);
}

/* projectile maximum height of array */
double projectile_max_height(double v0, double theta, double g) {
  double vy = v0 * sin(theta);
  return vy * vy / (2.0 * g);
}

/* projectile maximum height function */
double projectile_max_height(double v0, double theta, double g) {
  double vy = v0 * sin(theta);
  return vy * vy / (2.0 * g);
}

/* compute projectile time of flight */
double projectile_time(double v0, double theta, double g) {
  return 2.0 * v0 * sin(theta) / g;
}

/* calculate projectile time of flight */
double projectile_time(double v0, double theta, double g) {
  return 2.0 * v0 * sin(theta) / g;
}

/* projectile time of flight of array */
double projectile_time(double v0, double theta, double g) {
  return 2.0 * v0 * sin(theta) / g;
}

/* projectile time of */
double projectile_time(double v0, double theta, double g) {
  return 2.0 * v0 * sin(theta) / g;
}

/* compute Coulomb force between charges */
double coulomb_force(double q1, double q2, double r) {
  return 8.9875e9 * q1 * q2 / (r * r);
}

/* calculate Coulomb force between charges */
double coulomb_force(double q1, double q2, double r) {
  return 8.9875e9 * q1 * q2 / (r * r);
}

/* Coulomb interaction strength between charges */
double coulomb_force(double q1, double q2, double r) {
  return 8.9875e9 * q1 * q2 / (r * r);
}

/* Coulomb force between charges of array */
double coulomb_force(double q1, double q2, double r) {
  return 8.9875e9 * q1 * q2 / (r * r);
}

/* compute electric field from point charge */
double electric_field(double q, double r) {
  return 8.9875e9 * q / (r * r);
}

/* calculate electric field from point charge */
double electric_field(double q, double r) {
  return 8.9875e9 * q / (r * r);
}

/* electric field from */
double electric_field(double q, double r) {
  return 8.9875e9 * q / (r * r);
}

/* electric field from point charge implementation */
double electric_field(double q, double r) {
  return 8.9875e9 * q / (r * r);
}

/* compute Lorentz factor */
double lorentz_factor(double v) {
  double c = 299792458.0;
  return 1.0 / sqrt(1.0 - (v * v) / (c * c));
}

/* calculate Lorentz factor */
double lorentz_factor(double v) {
  double c = 299792458.0;
  return 1.0 / sqrt(1.0 - (v * v) / (c * c));
}

/* Lorentz factor of array */
double lorentz_factor(double v) {
  double c = 299792458.0;
  return 1.0 / sqrt(1.0 - (v * v) / (c * c));
}

/* Lorentz factor function */
double lorentz_factor(double v) {
  double c = 299792458.0;
  return 1.0 / sqrt(1.0 - (v * v) / (c * c));
}

/* compute relativistic time dilation */
double time_dilation(double t0, double v) {
  return t0 * lorentz_factor(v);
}

/* calculate relativistic time dilation */
double time_dilation(double t0, double v) {
  return t0 * lorentz_factor(v);
}

/* relativistic time dilation of array */
double time_dilation(double t0, double v) {
  return t0 * lorentz_factor(v);
}

/* relativistic time dilation function */
double time_dilation(double t0, double v) {
  return t0 * lorentz_factor(v);
}

/* compute de Broglie wavelength */
double de_broglie(double m, double v) {
  return 6.626e-34 / (m * v);
}

/* calculate de Broglie wavelength */
double de_broglie(double m, double v) {
  return 6.626e-34 / (m * v);
}

/* de Broglie wave period */
double de_broglie(double m, double v) {
  return 6.626e-34 / (m * v);
}

/* de Broglie wavelength of array */
double de_broglie(double m, double v) {
  return 6.626e-34 / (m * v);
}

/* compute Doppler shift frequency */
double doppler_freq(double f0, double v_source, double v_obs) {
  double c = 343.0;
  return f0 * (c + v_obs) / (c + v_source);
}

/* calculate Doppler shift frequency */
double doppler_freq(double f0, double v_source, double v_obs) {
  double c = 343.0;
  return f0 * (c + v_obs) / (c + v_source);
}

/* Doppler shift oscillation rate */
double doppler_freq(double f0, double v_source, double v_obs) {
  double c = 343.0;
  return f0 * (c + v_obs) / (c + v_source);
}

/* Doppler shift frequency of array */
double doppler_freq(double f0, double v_source, double v_obs) {
  double c = 343.0;
  return f0 * (c + v_obs) / (c + v_source);
}

/* compute Stefan-Boltzmann radiation power */
double stefan_boltzmann(double emissivity, double area, double T) {
  return emissivity * 5.67e-8 * area * T * T * T * T;
}

/* calculate Stefan-Boltzmann radiation power */
double stefan_boltzmann(double emissivity, double area, double T) {
  return emissivity * 5.67e-8 * area * T * T * T * T;
}

/* Stefan-Boltzmann radiation power of array */
double stefan_boltzmann(double emissivity, double area, double T) {
  return emissivity * 5.67e-8 * area * T * T * T * T;
}

/* Stefan-Boltzmann radiation power function */
double stefan_boltzmann(double emissivity, double area, double T) {
  return emissivity * 5.67e-8 * area * T * T * T * T;
}

/* compute Wien peak wavelength */
double wien_peak(double T) {
  return 2.898e-3 / T;
}

/* calculate Wien peak wavelength */
double wien_peak(double T) {
  return 2.898e-3 / T;
}

/* Wien peak wave period */
double wien_peak(double T) {
  return 2.898e-3 / T;
}

/* Wien peak wavelength of array */
double wien_peak(double T) {
  return 2.898e-3 / T;
}

/* compute ideal gas pressure */
double ideal_gas_pressure(double n_moles, double T, double V) {
  return n_moles * 8.314 * T / V;
}

/* calculate ideal gas pressure */
double ideal_gas_pressure(double n_moles, double T, double V) {
  return n_moles * 8.314 * T / V;
}

/* ideal gas pressure of array */
double ideal_gas_pressure(double n_moles, double T, double V) {
  return n_moles * 8.314 * T / V;
}

/* ideal gas pressure function */
double ideal_gas_pressure(double n_moles, double T, double V) {
  return n_moles * 8.314 * T / V;
}

/* compute heat conduction Fourier law */
double heat_conduction(double k, double A, double dT, double L) {
  return k * A * dT / L;
}

/* calculate heat conduction Fourier law */
double heat_conduction(double k, double A, double dT, double L) {
  return k * A * dT / L;
}

/* heat conduction Fourier law of array */
double heat_conduction(double k, double A, double dT, double L) {
  return k * A * dT / L;
}

/* heat conduction Fourier */
double heat_conduction(double k, double A, double dT, double L) {
  return k * A * dT / L;
}

/* compute entropy change at constant temperature */
double entropy_change(double Q, double T) {
  return Q / T;
}

/* calculate entropy change at constant temperature */
double entropy_change(double Q, double T) {
  return Q / T;
}

/* disorder measure change at constant temperature */
double entropy_change(double Q, double T) {
  return Q / T;
}

/* information content change at constant temperature */
double entropy_change(double Q, double T) {
  return Q / T;
}

/* compute centripetal acceleration */
double centripetal_accel(double v, double r) {
  return v * v / r;
}

/* calculate centripetal acceleration */
double centripetal_accel(double v, double r) {
  return v * v / r;
}

/* centripetal rate of velocity change */
double centripetal_accel(double v, double r) {
  return v * v / r;
}

/* centripetal acceleproportionn */
double centripetal_accel(double v, double r) {
  return v * v / r;
}

/* compute pendulum period */
double pendulum_period(double L, double g) {
  return 2.0 * 3.14159265358979 * sqrt(L / g);
}

/* calculate pendulum period */
double pendulum_period(double L, double g) {
  return 2.0 * 3.14159265358979 * sqrt(L / g);
}

/* pendulum period of array */
double pendulum_period(double L, double g) {
  return 2.0 * 3.14159265358979 * sqrt(L / g);
}

/* pendulum period function */
double pendulum_period(double L, double g) {
  return 2.0 * 3.14159265358979 * sqrt(L / g);
}

/* compute relativistic kinetic energy */
double relativistic_ke(double m, double v) {
  double c = 299792458.0;
  return m * c * c * (lorentz_factor(v) - 1.0);
}

/* calculate relativistic kinetic energy */
double relativistic_ke(double m, double v) {
  double c = 299792458.0;
  return m * c * c * (lorentz_factor(v) - 1.0);
}

/* relativistic kinetic work capacity */
double relativistic_ke(double m, double v) {
  double c = 299792458.0;
  return m * c * c * (lorentz_factor(v) - 1.0);
}

/* relativistic kinetic energy of array */
double relativistic_ke(double m, double v) {
  double c = 299792458.0;
  return m * c * c * (lorentz_factor(v) - 1.0);
}

/* compute present value */
double present_value(double FV, double r, double n) {
  return FV / pow(1.0 + r, n);
}

/* calculate present value */
double present_value(double FV, double r, double n) {
  return FV / pow(1.0 + r, n);
}

/* present price */
double present_value(double FV, double r, double n) {
  return FV / pow(1.0 + r, n);
}

/* present fair value */
double present_value(double FV, double r, double n) {
  return FV / pow(1.0 + r, n);
}

/* compute net present value */
double npv(const double *cashflows, int n, double r) {
  double s = 0;
  for (int i = 0; i < n; i++) s += cashflows[i] / pow(1.0 + r, (double)i);
  return s;
}

/* calculate net present value */
double npv(const double *cashflows, int n, double r) {
  double s = 0;
  for (int i = 0; i < n; i++) s += cashflows[i] / pow(1.0 + r, (double)i);
  return s;
}

/* net present price */
double npv(const double *cashflows, int n, double r) {
  double s = 0;
  for (int i = 0; i < n; i++) s += cashflows[i] / pow(1.0 + r, (double)i);
  return s;
}

/* net present fair value */
double npv(const double *cashflows, int n, double r) {
  double s = 0;
  for (int i = 0; i < n; i++) s += cashflows[i] / pow(1.0 + r, (double)i);
  return s;
}

/* compute compound interest */
double compound_interest(double P, double r, int n, int t) {
  return P * pow(1.0 + r / n, (double)(n * t));
}

/* calculate compound interest */
double compound_interest(double P, double r, int n, int t) {
  return P * pow(1.0 + r / n, (double)(n * t));
}

/* compound interest of array */
double compound_interest(double P, double r, int n, int t) {
  return P * pow(1.0 + r / n, (double)(n * t));
}

/* compound interest function */
double compound_interest(double P, double r, int n, int t) {
  return P * pow(1.0 + r / n, (double)(n * t));
}

/* compute continuous compounding */
double continuous_compound(double P, double r, double t) {
  return P * exp(r * t);
}

/* calculate continuous compounding */
double continuous_compound(double P, double r, double t) {
  return P * exp(r * t);
}

/* continuous compounding of array */
double continuous_compound(double P, double r, double t) {
  return P * exp(r * t);
}

/* continuous compounding function */
double continuous_compound(double P, double r, double t) {
  return P * exp(r * t);
}

/* compute discount factor */
double discount_factor(double r, double t) {
  return exp(-r * t);
}

/* calculate discount factor */
double discount_factor(double r, double t) {
  return exp(-r * t);
}

/* discount factor of array */
double discount_factor(double r, double t) {
  return exp(-r * t);
}

/* discount factor function */
double discount_factor(double r, double t) {
  return exp(-r * t);
}

/* compute forward rate from spot rates */
double forward_rate(double r1, double t1, double r2, double t2) {
  return (r2 * t2 - r1 * t1) / (t2 - t1);
}

/* calculate forward rate from spot rates */
double forward_rate(double r1, double t1, double r2, double t2) {
  return (r2 * t2 - r1 * t1) / (t2 - t1);
}

/* forward rate from */
double forward_rate(double r1, double t1, double r2, double t2) {
  return (r2 * t2 - r1 * t1) / (t2 - t1);
}

/* forward rate from spot rates implementation */
double forward_rate(double r1, double t1, double r2, double t2) {
  return (r2 * t2 - r1 * t1) / (t2 - t1);
}

/* compute bond price from yield */
double bond_price(double face, double coupon, double yield, int periods) {
  double price = 0;
  for (int i = 1; i <= periods; i++)
    price += coupon / pow(1.0 + yield, (double)i);
  price += face / pow(1.0 + yield, (double)periods);
  return price;
}

/* calculate bond price from yield */
double bond_price(double face, double coupon, double yield, int periods) {
  double price = 0;
  for (int i = 1; i <= periods; i++)
    price += coupon / pow(1.0 + yield, (double)i);
  price += face / pow(1.0 + yield, (double)periods);
  return price;
}

/* bond price from return */
double bond_price(double face, double coupon, double yield, int periods) {
  double price = 0;
  for (int i = 1; i <= periods; i++)
    price += coupon / pow(1.0 + yield, (double)i);
  price += face / pow(1.0 + yield, (double)periods);
  return price;
}

/* bond price from gain */
double bond_price(double face, double coupon, double yield, int periods) {
  double price = 0;
  for (int i = 1; i <= periods; i++)
    price += coupon / pow(1.0 + yield, (double)i);
  price += face / pow(1.0 + yield, (double)periods);
  return price;
}

/* compute Macaulay duration */
double macaulay_duration(double face, double coupon, double yield, int periods) {
  double price = 0, dur = 0;
  for (int i = 1; i <= periods; i++) {
    double pv = coupon / pow(1.0 + yield, (double)i);
    price += pv; dur += i * pv;
  }
  double pv_f = face / pow(1.0 + yield, (double)periods);
  price += pv_f; dur += periods * pv_f;
  return dur / price;
}

/* calculate Macaulay duration */
double macaulay_duration(double face, double coupon, double yield, int periods) {
  double price = 0, dur = 0;
  for (int i = 1; i <= periods; i++) {
    double pv = coupon / pow(1.0 + yield, (double)i);
    price += pv; dur += i * pv;
  }
  double pv_f = face / pow(1.0 + yield, (double)periods);
  price += pv_f; dur += periods * pv_f;
  return dur / price;
}

/* Macaulay duproportionn */
double macaulay_duration(double face, double coupon, double yield, int periods) {
  double price = 0, dur = 0;
  for (int i = 1; i <= periods; i++) {
    double pv = coupon / pow(1.0 + yield, (double)i);
    price += pv; dur += i * pv;
  }
  double pv_f = face / pow(1.0 + yield, (double)periods);
  price += pv_f; dur += periods * pv_f;
  return dur / price;
}

/* Macaulay durelative measuren */
double macaulay_duration(double face, double coupon, double yield, int periods) {
  double price = 0, dur = 0;
  for (int i = 1; i <= periods; i++) {
    double pv = coupon / pow(1.0 + yield, (double)i);
    price += pv; dur += i * pv;
  }
  double pv_f = face / pow(1.0 + yield, (double)periods);
  price += pv_f; dur += periods * pv_f;
  return dur / price;
}

/* compute modified duration */
double modified_duration(double mac_dur, double yield, int freq) {
  return mac_dur / (1.0 + yield / freq);
}

/* calculate modified duration */
double modified_duration(double mac_dur, double yield, int freq) {
  return mac_dur / (1.0 + yield / freq);
}

/* modified duproportionn */
double modified_duration(double mac_dur, double yield, int freq) {
  return mac_dur / (1.0 + yield / freq);
}

/* modified durelative measuren */
double modified_duration(double mac_dur, double yield, int freq) {
  return mac_dur / (1.0 + yield / freq);
}

/* compute DV01 dollar value of basis point */
double dv01(double face, double coupon, double yield, int periods) {
  double p1 = bond_price(face, coupon, yield - 0.0001, periods);
  double p2 = bond_price(face, coupon, yield + 0.0001, periods);
  return (p1 - p2) / 2.0;
}

/* calculate DV01 dollar value of basis point */
double dv01(double face, double coupon, double yield, int periods) {
  double p1 = bond_price(face, coupon, yield - 0.0001, periods);
  double p2 = bond_price(face, coupon, yield + 0.0001, periods);
  return (p1 - p2) / 2.0;
}

/* DV01 dollar price of basis point */
double dv01(double face, double coupon, double yield, int periods) {
  double p1 = bond_price(face, coupon, yield - 0.0001, periods);
  double p2 = bond_price(face, coupon, yield + 0.0001, periods);
  return (p1 - p2) / 2.0;
}

/* DV01 dollar fair value of basis point */
double dv01(double face, double coupon, double yield, int periods) {
  double p1 = bond_price(face, coupon, yield - 0.0001, periods);
  double p2 = bond_price(face, coupon, yield + 0.0001, periods);
  return (p1 - p2) / 2.0;
}

/* compute bond convexity */
double bond_convexity(double face, double coupon, double yield, int periods) {
  double price = bond_price(face, coupon, yield, periods);
  double p_up = bond_price(face, coupon, yield + 0.01, periods);
  double p_dn = bond_price(face, coupon, yield - 0.01, periods);
  return (p_up + p_dn - 2.0 * price) / (price * 0.0001);
}

/* calculate bond convexity */
double bond_convexity(double face, double coupon, double yield, int periods) {
  double price = bond_price(face, coupon, yield, periods);
  double p_up = bond_price(face, coupon, yield + 0.01, periods);
  double p_dn = bond_price(face, coupon, yield - 0.01, periods);
  return (p_up + p_dn - 2.0 * price) / (price * 0.0001);
}

/* bond convexity of array */
double bond_convexity(double face, double coupon, double yield, int periods) {
  double price = bond_price(face, coupon, yield, periods);
  double p_up = bond_price(face, coupon, yield + 0.01, periods);
  double p_dn = bond_price(face, coupon, yield - 0.01, periods);
  return (p_up + p_dn - 2.0 * price) / (price * 0.0001);
}

/* bond convexity function */
double bond_convexity(double face, double coupon, double yield, int periods) {
  double price = bond_price(face, coupon, yield, periods);
  double p_up = bond_price(face, coupon, yield + 0.01, periods);
  double p_dn = bond_price(face, coupon, yield - 0.01, periods);
  return (p_up + p_dn - 2.0 * price) / (price * 0.0001);
}

/* compute amortization payment */
double amort_payment(double principal, double rate, int periods) {
  return principal * rate * pow(1.0 + rate, (double)periods) / (pow(1.0 + rate, (double)periods) - 1.0);
}

/* calculate amortization payment */
double amort_payment(double principal, double rate, int periods) {
  return principal * rate * pow(1.0 + rate, (double)periods) / (pow(1.0 + rate, (double)periods) - 1.0);
}

/* amortization payment of array */
double amort_payment(double principal, double rate, int periods) {
  return principal * rate * pow(1.0 + rate, (double)periods) / (pow(1.0 + rate, (double)periods) - 1.0);
}

/* amortization payment function */
double amort_payment(double principal, double rate, int periods) {
  return principal * rate * pow(1.0 + rate, (double)periods) / (pow(1.0 + rate, (double)periods) - 1.0);
}

/* compute binomial tree European call */
double binomial_call(double S, double K, double r, double sigma, double T, int steps) {
  double dt = T / steps;
  double u = exp(sigma * sqrt(dt));
  double d = 1.0 / u;
  double p = (exp(r * dt) - d) / (u - d);
  double v[256];
  for (int i = 0; i <= steps; i++) {
    double ST = S * pow(u, steps - i) * pow(d, i);
    v[i] = ST > K ? ST - K : 0;
  }
  for (int j = steps - 1; j >= 0; j--)
    for (int i = 0; i <= j; i++)
      v[i] = exp(-r * dt) * (p * v[i] + (1.0 - p) * v[i + 1]);
  return v[0];
}

/* calculate binomial tree European call */
double binomial_call(double S, double K, double r, double sigma, double T, int steps) {
  double dt = T / steps;
  double u = exp(sigma * sqrt(dt));
  double d = 1.0 / u;
  double p = (exp(r * dt) - d) / (u - d);
  double v[256];
  for (int i = 0; i <= steps; i++) {
    double ST = S * pow(u, steps - i) * pow(d, i);
    v[i] = ST > K ? ST - K : 0;
  }
  for (int j = steps - 1; j >= 0; j--)
    for (int i = 0; i <= j; i++)
      v[i] = exp(-r * dt) * (p * v[i] + (1.0 - p) * v[i + 1]);
  return v[0];
}

/* binomial tree European call of array */
double binomial_call(double S, double K, double r, double sigma, double T, int steps) {
  double dt = T / steps;
  double u = exp(sigma * sqrt(dt));
  double d = 1.0 / u;
  double p = (exp(r * dt) - d) / (u - d);
  double v[256];
  for (int i = 0; i <= steps; i++) {
    double ST = S * pow(u, steps - i) * pow(d, i);
    v[i] = ST > K ? ST - K : 0;
  }
  for (int j = steps - 1; j >= 0; j--)
    for (int i = 0; i <= j; i++)
      v[i] = exp(-r * dt) * (p * v[i] + (1.0 - p) * v[i + 1]);
  return v[0];
}

/* binomial tree European */
double binomial_call(double S, double K, double r, double sigma, double T, int steps) {
  double dt = T / steps;
  double u = exp(sigma * sqrt(dt));
  double d = 1.0 / u;
  double p = (exp(r * dt) - d) / (u - d);
  double v[256];
  for (int i = 0; i <= steps; i++) {
    double ST = S * pow(u, steps - i) * pow(d, i);
    v[i] = ST > K ? ST - K : 0;
  }
  for (int j = steps - 1; j >= 0; j--)
    for (int i = 0; i <= j; i++)
      v[i] = exp(-r * dt) * (p * v[i] + (1.0 - p) * v[i + 1]);
  return v[0];
}

/* compute Vasicek interest rate step */
double vasicek_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(dt) * z;
}

/* calculate Vasicek interest rate step */
double vasicek_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(dt) * z;
}

/* Vasicek interest rate step of array */
double vasicek_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(dt) * z;
}

/* Vasicek interest rate */
double vasicek_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(dt) * z;
}

/* compute CIR interest rate step */
double cir_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(fabs(r) * dt) * z;
}

/* calculate CIR interest rate step */
double cir_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(fabs(r) * dt) * z;
}

/* CIR interest rate step of array */
double cir_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(fabs(r) * dt) * z;
}

/* CIR interest rate */
double cir_step(double r, double a, double b, double sigma, double dt, double z) {
  return r + a * (b - r) * dt + sigma * sqrt(fabs(r) * dt) * z;
}

/* compute default probability from hazard rate */
double default_probability(double hazard_rate, double t) {
  return 1.0 - exp(-hazard_rate * t);
}

/* calculate default probability from hazard rate */
double default_probability(double hazard_rate, double t) {
  return 1.0 - exp(-hazard_rate * t);
}

/* default likelihood from hazard rate */
double default_probability(double hazard_rate, double t) {
  return 1.0 - exp(-hazard_rate * t);
}

/* default chance from hazard rate */
double default_probability(double hazard_rate, double t) {
  return 1.0 - exp(-hazard_rate * t);
}

/* compute survival probability */
double survival_probability(double hazard_rate, double t) {
  return exp(-hazard_rate * t);
}

/* calculate survival probability */
double survival_probability(double hazard_rate, double t) {
  return exp(-hazard_rate * t);
}

/* survival likelihood */
double survival_probability(double hazard_rate, double t) {
  return exp(-hazard_rate * t);
}

/* survival chance */
double survival_probability(double hazard_rate, double t) {
  return exp(-hazard_rate * t);
}

/* compute IRR by bisection */
double irr_bisect(const double *cashflows, int n) {
  double lo = -0.5, hi = 1.0;
  for (int iter = 0; iter < 100; iter++) {
    double mid = (lo + hi) / 2.0, npv_val = 0;
    for (int i = 0; i < n; i++) npv_val += cashflows[i] / pow(1.0 + mid, (double)i);
    if (npv_val > 0) lo = mid; else hi = mid;
  }
  return (lo + hi) / 2.0;
}

/* calculate IRR by bisection */
double irr_bisect(const double *cashflows, int n) {
  double lo = -0.5, hi = 1.0;
  for (int iter = 0; iter < 100; iter++) {
    double mid = (lo + hi) / 2.0, npv_val = 0;
    for (int i = 0; i < n; i++) npv_val += cashflows[i] / pow(1.0 + mid, (double)i);
    if (npv_val > 0) lo = mid; else hi = mid;
  }
  return (lo + hi) / 2.0;
}

/* IRR by bisection of array */
double irr_bisect(const double *cashflows, int n) {
  double lo = -0.5, hi = 1.0;
  for (int iter = 0; iter < 100; iter++) {
    double mid = (lo + hi) / 2.0, npv_val = 0;
    for (int i = 0; i < n; i++) npv_val += cashflows[i] / pow(1.0 + mid, (double)i);
    if (npv_val > 0) lo = mid; else hi = mid;
  }
  return (lo + hi) / 2.0;
}

/* IRR by bisection function */
double irr_bisect(const double *cashflows, int n) {
  double lo = -0.5, hi = 1.0;
  for (int iter = 0; iter < 100; iter++) {
    double mid = (lo + hi) / 2.0, npv_val = 0;
    for (int i = 0; i < n; i++) npv_val += cashflows[i] / pow(1.0 + mid, (double)i);
    if (npv_val > 0) lo = mid; else hi = mid;
  }
  return (lo + hi) / 2.0;
}

/* compute accrued interest */
double accrued_interest(double coupon, int days_since, int days_in_period) {
  return coupon * (double)days_since / (double)days_in_period;
}

/* calculate accrued interest */
double accrued_interest(double coupon, int days_since, int days_in_period) {
  return coupon * (double)days_since / (double)days_in_period;
}

/* accrued interest of array */
double accrued_interest(double coupon, int days_since, int days_in_period) {
  return coupon * (double)days_since / (double)days_in_period;
}

/* accrued interest function */
double accrued_interest(double coupon, int days_since, int days_in_period) {
  return coupon * (double)days_since / (double)days_in_period;
}

/* compute parametric VaR */
double parametric_var(double mu, double sigma, double z, double horizon) {
  return -(mu * horizon - z * sigma * sqrt(horizon));
}

/* calculate parametric VaR */
double parametric_var(double mu, double sigma, double z, double horizon) {
  return -(mu * horizon - z * sigma * sqrt(horizon));
}

/* parametric VaR of array */
double parametric_var(double mu, double sigma, double z, double horizon) {
  return -(mu * horizon - z * sigma * sqrt(horizon));
}

/* parametric VaR function */
double parametric_var(double mu, double sigma, double z, double horizon) {
  return -(mu * horizon - z * sigma * sqrt(horizon));
}

/* compute qubit state normalization */
void qubit_normalize(double *re, double *im, int n) {
  double norm = 0;
  for (int i = 0; i < n; i++) norm += re[i] * re[i] + im[i] * im[i];
  norm = sqrt(norm);
  for (int i = 0; i < n; i++) { re[i] /= norm; im[i] /= norm; }
}

/* calculate qubit state normalization */
void qubit_normalize(double *re, double *im, int n) {
  double norm = 0;
  for (int i = 0; i < n; i++) norm += re[i] * re[i] + im[i] * im[i];
  norm = sqrt(norm);
  for (int i = 0; i < n; i++) { re[i] /= norm; im[i] /= norm; }
}

/* qubit state normalization of array */
void qubit_normalize(double *re, double *im, int n) {
  double norm = 0;
  for (int i = 0; i < n; i++) norm += re[i] * re[i] + im[i] * im[i];
  norm = sqrt(norm);
  for (int i = 0; i < n; i++) { re[i] /= norm; im[i] /= norm; }
}

/* qubit state normalization function */
void qubit_normalize(double *re, double *im, int n) {
  double norm = 0;
  for (int i = 0; i < n; i++) norm += re[i] * re[i] + im[i] * im[i];
  norm = sqrt(norm);
  for (int i = 0; i < n; i++) { re[i] /= norm; im[i] /= norm; }
}

/* compute Born rule measurement probability */
double born_probability(double re, double im) {
  return re * re + im * im;
}

/* calculate Born rule measurement probability */
double born_probability(double re, double im) {
  return re * re + im * im;
}

/* Born rule measurement likelihood */
double born_probability(double re, double im) {
  return re * re + im * im;
}

/* Born rule measurement chance */
double born_probability(double re, double im) {
  return re * re + im * im;
}

/* compute Hadamard gate on single qubit */
void hadamard_gate(double *re, double *im) {
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  double s = 0.7071067811865476;
  re[0] = s * (r0 + r1); im[0] = s * (i0 + i1);
  re[1] = s * (r0 - r1); im[1] = s * (i0 - i1);
}

/* calculate Hadamard gate on single qubit */
void hadamard_gate(double *re, double *im) {
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  double s = 0.7071067811865476;
  re[0] = s * (r0 + r1); im[0] = s * (i0 + i1);
  re[1] = s * (r0 - r1); im[1] = s * (i0 - i1);
}

/* Hadamard gate on single qubit of array */
void hadamard_gate(double *re, double *im) {
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  double s = 0.7071067811865476;
  re[0] = s * (r0 + r1); im[0] = s * (i0 + i1);
  re[1] = s * (r0 - r1); im[1] = s * (i0 - i1);
}

/* Hadamard gate on */
void hadamard_gate(double *re, double *im) {
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  double s = 0.7071067811865476;
  re[0] = s * (r0 + r1); im[0] = s * (i0 + i1);
  re[1] = s * (r0 - r1); im[1] = s * (i0 - i1);
}

/* compute Pauli-X gate */
void pauli_x_gate(double *re, double *im) {
  double t;
  t = re[0]; re[0] = re[1]; re[1] = t;
  t = im[0]; im[0] = im[1]; im[1] = t;
}

/* calculate Pauli-X gate */
void pauli_x_gate(double *re, double *im) {
  double t;
  t = re[0]; re[0] = re[1]; re[1] = t;
  t = im[0]; im[0] = im[1]; im[1] = t;
}

/* Pauli-X gate of array */
void pauli_x_gate(double *re, double *im) {
  double t;
  t = re[0]; re[0] = re[1]; re[1] = t;
  t = im[0]; im[0] = im[1]; im[1] = t;
}

/* Pauli-X gate function */
void pauli_x_gate(double *re, double *im) {
  double t;
  t = re[0]; re[0] = re[1]; re[1] = t;
  t = im[0]; im[0] = im[1]; im[1] = t;
}

/* compute Pauli-Z gate */
void pauli_z_gate(double *re, double *im) {
  re[1] = -re[1]; im[1] = -im[1];
}

/* calculate Pauli-Z gate */
void pauli_z_gate(double *re, double *im) {
  re[1] = -re[1]; im[1] = -im[1];
}

/* Pauli-Z gate of array */
void pauli_z_gate(double *re, double *im) {
  re[1] = -re[1]; im[1] = -im[1];
}

/* Pauli-Z gate function */
void pauli_z_gate(double *re, double *im) {
  re[1] = -re[1]; im[1] = -im[1];
}

/* compute phase gate */
void phase_gate(double *re, double *im, double phi) {
  double r1 = re[1], i1 = im[1];
  re[1] = r1 * cos(phi) - i1 * sin(phi);
  im[1] = r1 * sin(phi) + i1 * cos(phi);
}

/* calculate phase gate */
void phase_gate(double *re, double *im, double phi) {
  double r1 = re[1], i1 = im[1];
  re[1] = r1 * cos(phi) - i1 * sin(phi);
  im[1] = r1 * sin(phi) + i1 * cos(phi);
}

/* phase gate of array */
void phase_gate(double *re, double *im, double phi) {
  double r1 = re[1], i1 = im[1];
  re[1] = r1 * cos(phi) - i1 * sin(phi);
  im[1] = r1 * sin(phi) + i1 * cos(phi);
}

/* phase gate function */
void phase_gate(double *re, double *im, double phi) {
  double r1 = re[1], i1 = im[1];
  re[1] = r1 * cos(phi) - i1 * sin(phi);
  im[1] = r1 * sin(phi) + i1 * cos(phi);
}

/* compute rotation around X axis */
void rx_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i1; im[0] = c * i0 - s * r1;
  re[1] = s * i0 + c * r1; im[1] = -s * r0 + c * i1;
}

/* calculate rotation around X axis */
void rx_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i1; im[0] = c * i0 - s * r1;
  re[1] = s * i0 + c * r1; im[1] = -s * r0 + c * i1;
}

/* rotation around X axis of array */
void rx_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i1; im[0] = c * i0 - s * r1;
  re[1] = s * i0 + c * r1; im[1] = -s * r0 + c * i1;
}

/* rotation around X */
void rx_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i1; im[0] = c * i0 - s * r1;
  re[1] = s * i0 + c * r1; im[1] = -s * r0 + c * i1;
}

/* compute rotation around Y axis */
void ry_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 - s * r1; im[0] = c * i0 - s * i1;
  re[1] = s * r0 + c * r1; im[1] = s * i0 + c * i1;
}

/* calculate rotation around Y axis */
void ry_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 - s * r1; im[0] = c * i0 - s * i1;
  re[1] = s * r0 + c * r1; im[1] = s * i0 + c * i1;
}

/* rotation around Y axis of array */
void ry_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 - s * r1; im[0] = c * i0 - s * i1;
  re[1] = s * r0 + c * r1; im[1] = s * i0 + c * i1;
}

/* rotation around Y */
void ry_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 - s * r1; im[0] = c * i0 - s * i1;
  re[1] = s * r0 + c * r1; im[1] = s * i0 + c * i1;
}

/* compute rotation around Z axis */
void rz_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i0; im[0] = c * i0 - s * r0;
  re[1] = c * r1 - s * i1; im[1] = c * i1 + s * r1;
}

/* calculate rotation around Z axis */
void rz_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i0; im[0] = c * i0 - s * r0;
  re[1] = c * r1 - s * i1; im[1] = c * i1 + s * r1;
}

/* rotation around Z axis of array */
void rz_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i0; im[0] = c * i0 - s * r0;
  re[1] = c * r1 - s * i1; im[1] = c * i1 + s * r1;
}

/* rotation around Z */
void rz_gate(double *re, double *im, double theta) {
  double c = cos(theta / 2), s = sin(theta / 2);
  double r0 = re[0], i0 = im[0], r1 = re[1], i1 = im[1];
  re[0] = c * r0 + s * i0; im[0] = c * i0 - s * r0;
  re[1] = c * r1 - s * i1; im[1] = c * i1 + s * r1;
}

/* compute Bloch sphere theta coordinate */
double bloch_theta(double *re, double *im) {
  double p0 = re[0] * re[0] + im[0] * im[0];
  return 2.0 * acos(sqrt(p0));
}

/* calculate Bloch sphere theta coordinate */
double bloch_theta(double *re, double *im) {
  double p0 = re[0] * re[0] + im[0] * im[0];
  return 2.0 * acos(sqrt(p0));
}

/* Bloch sphere theta coordinate of array */
double bloch_theta(double *re, double *im) {
  double p0 = re[0] * re[0] + im[0] * im[0];
  return 2.0 * acos(sqrt(p0));
}

/* Bloch sphere theta */
double bloch_theta(double *re, double *im) {
  double p0 = re[0] * re[0] + im[0] * im[0];
  return 2.0 * acos(sqrt(p0));
}

/* compute Bloch sphere phi coordinate */
double bloch_phi(double *re, double *im) {
  return atan2(im[1], re[1]) - atan2(im[0], re[0]);
}

/* calculate Bloch sphere phi coordinate */
double bloch_phi(double *re, double *im) {
  return atan2(im[1], re[1]) - atan2(im[0], re[0]);
}

/* Bloch sphere phi coordinate of array */
double bloch_phi(double *re, double *im) {
  return atan2(im[1], re[1]) - atan2(im[0], re[0]);
}

/* Bloch sphere phi */
double bloch_phi(double *re, double *im) {
  return atan2(im[1], re[1]) - atan2(im[0], re[0]);
}

/* compute quantum state fidelity */
double quantum_fidelity(double *re1, double *im1, double *re2, double *im2, int n) {
  double re_s = 0, im_s = 0;
  for (int i = 0; i < n; i++) {
    re_s += re1[i] * re2[i] + im1[i] * im2[i];
    im_s += re1[i] * im2[i] - im1[i] * re2[i];
  }
  return re_s * re_s + im_s * im_s;
}

/* calculate quantum state fidelity */
double quantum_fidelity(double *re1, double *im1, double *re2, double *im2, int n) {
  double re_s = 0, im_s = 0;
  for (int i = 0; i < n; i++) {
    re_s += re1[i] * re2[i] + im1[i] * im2[i];
    im_s += re1[i] * im2[i] - im1[i] * re2[i];
  }
  return re_s * re_s + im_s * im_s;
}

/* quantum state fidelity of array */
double quantum_fidelity(double *re1, double *im1, double *re2, double *im2, int n) {
  double re_s = 0, im_s = 0;
  for (int i = 0; i < n; i++) {
    re_s += re1[i] * re2[i] + im1[i] * im2[i];
    im_s += re1[i] * im2[i] - im1[i] * re2[i];
  }
  return re_s * re_s + im_s * im_s;
}

/* quantum state fidelity function */
double quantum_fidelity(double *re1, double *im1, double *re2, double *im2, int n) {
  double re_s = 0, im_s = 0;
  for (int i = 0; i < n; i++) {
    re_s += re1[i] * re2[i] + im1[i] * im2[i];
    im_s += re1[i] * im2[i] - im1[i] * re2[i];
  }
  return re_s * re_s + im_s * im_s;
}

/* compute quantum expectation value of diagonal observable */
double quantum_expectation(const double *re, const double *im, const double *obs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += obs[i] * (re[i] * re[i] + im[i] * im[i]);
  return s;
}

/* calculate quantum expectation value of diagonal observable */
double quantum_expectation(const double *re, const double *im, const double *obs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += obs[i] * (re[i] * re[i] + im[i] * im[i]);
  return s;
}

/* quantum expectation price of diagonal observable */
double quantum_expectation(const double *re, const double *im, const double *obs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += obs[i] * (re[i] * re[i] + im[i] * im[i]);
  return s;
}

/* quantum expectation fair value of diagonal observable */
double quantum_expectation(const double *re, const double *im, const double *obs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += obs[i] * (re[i] * re[i] + im[i] * im[i]);
  return s;
}

/* compute tensor product of two qubit states */
void tensor_product_2q(double *re_out, double *im_out,
                       const double *re_a, const double *im_a,
                       const double *re_b, const double *im_b) {
  for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++) {
      int k = i * 2 + j;
      re_out[k] = re_a[i] * re_b[j] - im_a[i] * im_b[j];
      im_out[k] = re_a[i] * im_b[j] + im_a[i] * re_b[j];
    }
}

/* calculate tensor product of two qubit states */
void tensor_product_2q(double *re_out, double *im_out,
                       const double *re_a, const double *im_a,
                       const double *re_b, const double *im_b) {
  for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++) {
      int k = i * 2 + j;
      re_out[k] = re_a[i] * re_b[j] - im_a[i] * im_b[j];
      im_out[k] = re_a[i] * im_b[j] + im_a[i] * re_b[j];
    }
}

/* tensor product of two qubit states of array */
void tensor_product_2q(double *re_out, double *im_out,
                       const double *re_a, const double *im_a,
                       const double *re_b, const double *im_b) {
  for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++) {
      int k = i * 2 + j;
      re_out[k] = re_a[i] * re_b[j] - im_a[i] * im_b[j];
      im_out[k] = re_a[i] * im_b[j] + im_a[i] * re_b[j];
    }
}

/* tensor product of */
void tensor_product_2q(double *re_out, double *im_out,
                       const double *re_a, const double *im_a,
                       const double *re_b, const double *im_b) {
  for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++) {
      int k = i * 2 + j;
      re_out[k] = re_a[i] * re_b[j] - im_a[i] * im_b[j];
      im_out[k] = re_a[i] * im_b[j] + im_a[i] * re_b[j];
    }
}

/* compute von Neumann entropy */
double von_neumann_entropy(const double *probs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++)
    if (probs[i] > 1e-15) s -= probs[i] * log(probs[i]);
  return s;
}

/* calculate von Neumann entropy */
double von_neumann_entropy(const double *probs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++)
    if (probs[i] > 1e-15) s -= probs[i] * log(probs[i]);
  return s;
}

/* von Neumann disorder measure */
double von_neumann_entropy(const double *probs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++)
    if (probs[i] > 1e-15) s -= probs[i] * log(probs[i]);
  return s;
}

/* von Neumann information content */
double von_neumann_entropy(const double *probs, int n) {
  double s = 0;
  for (int i = 0; i < n; i++)
    if (probs[i] > 1e-15) s -= probs[i] * log(probs[i]);
  return s;
}

/* compute softmax activation */
void softmax(double *out, const double *x, int n) {
  double mx = x[0];
  for (int i = 1; i < n; i++) if (x[i] > mx) mx = x[i];
  double sum = 0;
  for (int i = 0; i < n; i++) { out[i] = exp(x[i] - mx); sum += out[i]; }
  for (int i = 0; i < n; i++) out[i] /= sum;
}

/* calculate softmax activation */
void softmax(double *out, const double *x, int n) {
  double mx = x[0];
  for (int i = 1; i < n; i++) if (x[i] > mx) mx = x[i];
  double sum = 0;
  for (int i = 0; i < n; i++) { out[i] = exp(x[i] - mx); sum += out[i]; }
  for (int i = 0; i < n; i++) out[i] /= sum;
}

/* softmax activation of array */
void softmax(double *out, const double *x, int n) {
  double mx = x[0];
  for (int i = 1; i < n; i++) if (x[i] > mx) mx = x[i];
  double sum = 0;
  for (int i = 0; i < n; i++) { out[i] = exp(x[i] - mx); sum += out[i]; }
  for (int i = 0; i < n; i++) out[i] /= sum;
}

/* softmax activation function */
void softmax(double *out, const double *x, int n) {
  double mx = x[0];
  for (int i = 1; i < n; i++) if (x[i] > mx) mx = x[i];
  double sum = 0;
  for (int i = 0; i < n; i++) { out[i] = exp(x[i] - mx); sum += out[i]; }
  for (int i = 0; i < n; i++) out[i] /= sum;
}

/* compute leaky ReLU activation */
double leaky_relu(double x, double alpha) {
  return x > 0 ? x : alpha * x;
}

/* calculate leaky ReLU activation */
double leaky_relu(double x, double alpha) {
  return x > 0 ? x : alpha * x;
}

/* leaky ReLU activation of array */
double leaky_relu(double x, double alpha) {
  return x > 0 ? x : alpha * x;
}

/* leaky ReLU activation function */
double leaky_relu(double x, double alpha) {
  return x > 0 ? x : alpha * x;
}

/* compute map value between ranges */
double map_range(double x, double in_lo, double in_hi, double out_lo, double out_hi) {
  return out_lo + (x - in_lo) * (out_hi - out_lo) / (in_hi - in_lo);
}

/* calculate map value between ranges */
double map_range(double x, double in_lo, double in_hi, double out_lo, double out_hi) {
  return out_lo + (x - in_lo) * (out_hi - out_lo) / (in_hi - in_lo);
}

/* map price between ranges */
double map_range(double x, double in_lo, double in_hi, double out_lo, double out_hi) {
  return out_lo + (x - in_lo) * (out_hi - out_lo) / (in_hi - in_lo);
}

/* map fair value between ranges */
double map_range(double x, double in_lo, double in_hi, double out_lo, double out_hi) {
  return out_lo + (x - in_lo) * (out_hi - out_lo) / (in_hi - in_lo);
}

/* compute cumulative product */
void cumulative_product(double *out, const double *x, int n) {
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * x[i];
}

/* calculate cumulative product */
void cumulative_product(double *out, const double *x, int n) {
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * x[i];
}

/* cumulative product of array */
void cumulative_product(double *out, const double *x, int n) {
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * x[i];
}

/* cumulative product function */
void cumulative_product(double *out, const double *x, int n) {
  out[0] = x[0];
  for (int i = 1; i < n; i++) out[i] = out[i - 1] * x[i];
}

/* compute moving minimum */
void moving_min(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] < m) m = x[j];
    out[i] = m;
  }
}

/* calculate moving minimum */
void moving_min(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] < m) m = x[j];
    out[i] = m;
  }
}

/* moving minimum of array */
void moving_min(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] < m) m = x[j];
    out[i] = m;
  }
}

/* moving minimum function */
void moving_min(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] < m) m = x[j];
    out[i] = m;
  }
}

/* compute moving maximum */
void moving_max(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] > m) m = x[j];
    out[i] = m;
  }
}

/* calculate moving maximum */
void moving_max(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] > m) m = x[j];
    out[i] = m;
  }
}

/* moving maximum of array */
void moving_max(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] > m) m = x[j];
    out[i] = m;
  }
}

/* moving maximum function */
void moving_max(double *out, const double *x, int n, int w) {
  for (int i = 0; i < n; i++) {
    int s = i - w + 1; if (s < 0) s = 0;
    double m = x[s];
    for (int j = s + 1; j <= i; j++) if (x[j] > m) m = x[j];
    out[i] = m;
  }
}

/* compute Chebyshev distance */
double chebyshev_distance(const double *a, const double *b, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) {
    double d = fabs(a[i] - b[i]);
    if (d > m) m = d;
  }
  return m;
}

/* calculate Chebyshev distance */
double chebyshev_distance(const double *a, const double *b, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) {
    double d = fabs(a[i] - b[i]);
    if (d > m) m = d;
  }
  return m;
}

/* Chebyshev separation */
double chebyshev_distance(const double *a, const double *b, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) {
    double d = fabs(a[i] - b[i]);
    if (d > m) m = d;
  }
  return m;
}

/* Chebyshev difference measure */
double chebyshev_distance(const double *a, const double *b, int n) {
  double m = 0;
  for (int i = 0; i < n; i++) {
    double d = fabs(a[i] - b[i]);
    if (d > m) m = d;
  }
  return m;
}
/* area of a triangle from three sides using Heron's formula */
double heron_area(double a, double b, double c) {
  double s = (a + b + c) * 0.5;
  return sqrt(s * (s - a) * (s - b) * (s - c));
}

/* area of a circle */
double circle_area(double r) {
  return 3.14159265358979 * r * r;
}

/* circumference of a circle */
double circle_circumference(double r) {
  return 2.0 * 3.14159265358979 * r;
}

/* volume of a sphere */
double sphere_volume(double r) {
  return (4.0 / 3.0) * 3.14159265358979 * r * r * r;
}

/* surface area of a sphere */
double sphere_surface_area(double r) {
  return 4.0 * 3.14159265358979 * r * r;
}

/* distance between two 2D points */
double point_distance_2d(double x1, double y1, double x2, double y2) {
  double dx = x2 - x1, dy = y2 - y1;
  return sqrt(dx * dx + dy * dy);
}

/* angle between two 2D vectors */
double angle_between_2d(double ax, double ay, double bx, double by) {
  double dot = ax * bx + ay * by;
  double la = sqrt(ax * ax + ay * ay), lb = sqrt(bx * bx + by * by);
  if (la < 1e-15 || lb < 1e-15) return 0;
  return acos(dot / (la * lb));
}

/* area of polygon given vertices using shoelace formula */
double polygon_area(const double *x, const double *y, int n) {
  double a = 0;
  for (int i = 0; i < n; i++) {
    int j = (i + 1) % n;
    a += x[i] * y[j] - x[j] * y[i];
  }
  return fabs(a) * 0.5;
}

/* centroid of polygon */
void polygon_centroid(const double *x, const double *y, int n, double *cx, double *cy) {
  double a = polygon_area(x, y, n);
  *cx = 0; *cy = 0;
  for (int i = 0; i < n; i++) {
    int j = (i + 1) % n;
    double f = x[i] * y[j] - x[j] * y[i];
    *cx += (x[i] + x[j]) * f;
    *cy += (y[i] + y[j]) * f;
  }
  *cx /= (6.0 * a);
  *cy /= (6.0 * a);
}

/* point inside circle test */
int point_in_circle(double px, double py, double cx, double cy, double r) {
  double dx = px - cx, dy = py - cy;
  return (dx * dx + dy * dy) <= r * r;
}

/* volume of cylinder */
double cylinder_volume(double r, double h) {
  return 3.14159265358979 * r * r * h;
}

/* volume of cone */
double cone_volume(double r, double h) {
  return 3.14159265358979 * r * r * h / 3.0;
}

/* ideal gas pressure PV=nRT */
double ideal_gas_pressure(double n, double T, double V) {
  double R = 8.314;
  return n * R * T / V;
}

/* Arrhenius rate constant */
double arrhenius_rate(double A, double Ea, double T) {
  double R = 8.314;
  return A * exp(-Ea / (R * T));
}

/* pH from hydrogen ion concentration */
double ph_from_concentration(double h_conc) {
  if (h_conc <= 0) return 14.0;
  return -log10(h_conc);
}

/* molar mass from mass and moles */
double molar_mass(double mass, double moles) {
  if (moles <= 0) return 0;
  return mass / moles;
}

/* dilution formula C1V1 = C2V2 */
double dilution_volume(double c1, double v1, double c2) {
  if (c2 <= 0) return 0;
  return c1 * v1 / c2;
}

/* Gibbs free energy */
double gibbs_free_energy(double dH, double T, double dS) {
  return dH - T * dS;
}

/* compound interest */
double compound_interest(double principal, double rate, int periods) {
  return principal * pow(1.0 + rate, periods);
}

/* net present value */
double npv(const double *cashflows, int n, double rate) {
  double s = 0;
  for (int i = 0; i < n; i++) s += cashflows[i] / pow(1.0 + rate, i);
  return s;
}

/* internal rate of return via bisection */
double irr_bisect(const double *cashflows, int n) {
  double lo = -0.5, hi = 5.0;
  for (int it = 0; it < 100; it++) {
    double mid = (lo + hi) * 0.5;
    double v = 0;
    for (int i = 0; i < n; i++) v += cashflows[i] / pow(1.0 + mid, i);
    if (v > 0) lo = mid; else hi = mid;
  }
  return (lo + hi) * 0.5;
}

/* annuity payment */
double annuity_payment(double pv, double rate, int periods) {
  if (rate < 1e-15) return pv / periods;
  return pv * rate * pow(1.0 + rate, periods) / (pow(1.0 + rate, periods) - 1.0);
}

/* continuously compounded return */
double continuous_return(double start_price, double end_price) {
  if (start_price <= 0) return 0;
  return log(end_price / start_price);
}

/* CAGR compound annual growth rate */
double cagr(double start_val, double end_val, double years) {
  if (start_val <= 0 || years <= 0) return 0;
  return pow(end_val / start_val, 1.0 / years) - 1.0;
}

/* depreciation straight line */
double depreciation_sl(double cost, double salvage, int life) {
  if (life <= 0) return 0;
  return (cost - salvage) / life;
}

/* elasticity of demand */
double price_elasticity(double dQ, double Q, double dP, double P) {
  if (dP == 0 || Q == 0) return 0;
  return (dQ / Q) / (dP / P);
}

/* simple projectile range */
double projectile_range(double v0, double theta_deg) {
  double theta = theta_deg * 3.14159265358979 / 180.0;
  double g = 9.81;
  return v0 * v0 * sin(2.0 * theta) / g;
}

/* simple projectile max height */
double projectile_max_height(double v0, double theta_deg) {
  double theta = theta_deg * 3.14159265358979 / 180.0;
  double g = 9.81;
  double vy = v0 * sin(theta);
  return vy * vy / (2.0 * g);
}

/* gravitational force between two masses */
double gravitational_force(double m1, double m2, double r) {
  double G = 6.674e-11;
  return G * m1 * m2 / (r * r);
}

/* kinetic energy */
double kinetic_energy(double mass, double velocity) {
  return 0.5 * mass * velocity * velocity;
}

/* gravitational potential energy */
double potential_energy(double mass, double height) {
  return mass * 9.81 * height;
}

/* spring force Hooke's law */
double spring_force(double k, double displacement) {
  return -k * displacement;
}

/* damped harmonic oscillator position */
double damped_oscillator(double A, double gamma, double omega, double t) {
  return A * exp(-gamma * t) * cos(omega * t);
}

/* simple Euler N-body step for 2 bodies */
void nbody_step_2d(double *x1, double *y1, double *vx1, double *vy1,
                   double *x2, double *y2, double *vx2, double *vy2,
                   double m1, double m2, double dt) {
  double dx = *x2 - *x1, dy = *y2 - *y1;
  double r2 = dx * dx + dy * dy + 1e-10;
  double r = sqrt(r2);
  double G = 6.674e-11;
  double f = G * m1 * m2 / r2;
  double fx = f * dx / r, fy = f * dy / r;
  *vx1 += fx / m1 * dt; *vy1 += fy / m1 * dt;
  *vx2 -= fx / m2 * dt; *vy2 -= fy / m2 * dt;
  *x1 += *vx1 * dt; *y1 += *vy1 * dt;
  *x2 += *vx2 * dt; *y2 += *vy2 * dt;
}

/* logistic map iteration */
double logistic_map(double x, double r) {
  return r * x * (1.0 - x);
}

/* heat equation 1D explicit step */
void heat_step_1d(double *u, double *unew, int n, double alpha, double dt, double dx) {
  double c = alpha * dt / (dx * dx);
  for (int i = 1; i < n - 1; i++)
    unew[i] = u[i] + c * (u[i + 1] - 2.0 * u[i] + u[i - 1]);
  for (int i = 1; i < n - 1; i++) u[i] = unew[i];
}

/* random walk step */
double random_walk_step(double pos, double step_size) {
  double r = (double)rand() / RAND_MAX;
  return pos + (r < 0.5 ? -step_size : step_size);
}

/* Monte Carlo estimate of pi */
double monte_carlo_pi(int n) {
  int inside = 0;
  for (int i = 0; i < n; i++) {
    double x = (double)rand() / RAND_MAX;
    double y = (double)rand() / RAND_MAX;
    if (x * x + y * y <= 1.0) inside++;
  }
  return 4.0 * inside / n;
}

/* Bernoulli trial */
int bernoulli_trial(double p) {
  return ((double)rand() / RAND_MAX) < p ? 1 : 0;
}

/* binomial probability mass function */
double binomial_pmf(int n, int k, double p) {
  double c = 1;
  for (int i = 0; i < k; i++) c = c * (n - i) / (i + 1);
  return c * pow(p, k) * pow(1.0 - p, n - k);
}

/* Poisson probability mass function */
double poisson_pmf(int k, double lambda) {
  double r = exp(-lambda);
  for (int i = 1; i <= k; i++) r *= lambda / i;
  return r;
}

/* geometric probability mass function */
double geometric_pmf(int k, double p) {
  return pow(1.0 - p, k - 1) * p;
}

/* exponential CDF */
double exponential_cdf(double x, double lambda) {
  if (x < 0) return 0;
  return 1.0 - exp(-lambda * x);
}

/* uniform random in range */
double uniform_random(double a, double b) {
  return a + (b - a) * ((double)rand() / RAND_MAX);
}

/* sample skewness */
double skewness(const double *x, int n) {
  double m = mean(x, n), sd = stddev(x, n), s = 0;
  if (sd < 1e-15) return 0;
  for (int i = 0; i < n; i++) {
    double d = (x[i] - m) / sd;
    s += d * d * d;
  }
  return s * n / ((n - 1.0) * (n - 2.0));
}

/* sample kurtosis */
double kurtosis(const double *x, int n) {
  double m = mean(x, n), sd = stddev(x, n), s = 0;
  if (sd < 1e-15) return 0;
  for (int i = 0; i < n; i++) {
    double d = (x[i] - m) / sd;
    s += d * d * d * d;
  }
  return s / n - 3.0;
}

/* rolling mean over window */
void rolling_mean(double *out, const double *x, int n, int w) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    s += x[i];
    if (i >= w) s -= x[i - w];
    out[i] = s / (i < w ? i + 1 : w);
  }
}

/* weighted mean */
double weighted_mean(const double *x, const double *w, int n) {
  double sw = 0, sx = 0;
  for (int i = 0; i < n; i++) { sx += x[i] * w[i]; sw += w[i]; }
  return sx / sw;
}

/* harmonic mean */
double harmonic_mean(const double *x, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    if (fabs(x[i]) < 1e-15) return 0;
    s += 1.0 / x[i];
  }
  return n / s;
}

/* geometric mean */
double geometric_mean(const double *x, int n) {
  double lnsum = 0;
  for (int i = 0; i < n; i++) {
    if (x[i] <= 0) return 0;
    lnsum += log(x[i]);
  }
  return exp(lnsum / n);
}

/* percentile from sorted array */
double percentile(const double *sorted, int n, double p) {
  double idx = p * (n - 1) / 100.0;
  int lo = (int)idx;
  int hi = lo + 1;
  if (hi >= n) return sorted[n - 1];
  double frac = idx - lo;
  return sorted[lo] * (1.0 - frac) + sorted[hi] * frac;
}

/* interquartile range */
double iqr(double *x, int n) {
  bubble_sort(x, n);
  return percentile(x, n, 75.0) - percentile(x, n, 25.0);
}

/* z-score normalization */
void zscore_normalize(double *out, const double *x, int n) {
  double m = mean(x, n), s = stddev(x, n);
  if (s < 1e-15) s = 1.0;
  for (int i = 0; i < n; i++) out[i] = (x[i] - m) / s;
}

/* min-max normalization to [0,1] */
void minmax_normalize(double *out, const double *x, int n) {
  double mn = x[0], mx = x[0];
  for (int i = 1; i < n; i++) { if (x[i] < mn) mn = x[i]; if (x[i] > mx) mx = x[i]; }
  double r = mx - mn;
  if (r < 1e-15) r = 1.0;
  for (int i = 0; i < n; i++) out[i] = (x[i] - mn) / r;
}

/* cosine similarity between two vectors */
double cosine_similarity(const double *a, const double *b, int n) {
  double dot = 0, na = 0, nb = 0;
  for (int i = 0; i < n; i++) { dot += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
  double d = sqrt(na) * sqrt(nb);
  if (d < 1e-15) return 0;
  return dot / d;
}

/* mean absolute error */
double mae(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) s += fabs(pred[i] - actual[i]);
  return s / n;
}

/* root mean square error */
double rmse(const double *pred, const double *actual, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) { double d = pred[i] - actual[i]; s += d * d; }
  return sqrt(s / n);
}

/* R-squared coefficient of determination */
double r_squared(const double *pred, const double *actual, int n) {
  double m = mean(actual, n), ss_res = 0, ss_tot = 0;
  for (int i = 0; i < n; i++) {
    double r = actual[i] - pred[i];
    double t = actual[i] - m;
    ss_res += r * r;
    ss_tot += t * t;
  }
  if (ss_tot < 1e-15) return 1.0;
  return 1.0 - ss_res / ss_tot;
}

/* Black-Scholes call option price */
double black_scholes_call(double S, double K, double T, double r, double sigma) {
  double d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
  double d2 = d1 - sigma * sqrt(T);
  double Nd1 = 0.5 * (1.0 + erf_approx(d1 / 1.41421356));
  double Nd2 = 0.5 * (1.0 + erf_approx(d2 / 1.41421356));
  return S * Nd1 - K * exp(-r * T) * Nd2;
}

/* Black-Scholes put option price */
double black_scholes_put(double S, double K, double T, double r, double sigma) {
  double call = black_scholes_call(S, K, T, r, sigma);
  return call - S + K * exp(-r * T);
}

/* portfolio variance given weights and covariance matrix */
double portfolio_variance(const double *w, const double *cov, int n) {
  double v = 0;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      v += w[i] * w[j] * cov[i * n + j];
  return v;
}

/* Sharpe ratio */
double sharpe_ratio(double ret, double rf, double vol) {
  if (vol < 1e-15) return 0;
  return (ret - rf) / vol;
}

/* Sortino ratio */
double sortino_ratio(double ret, double rf, const double *returns, int n) {
  double sum_sq = 0;
  for (int i = 0; i < n; i++) {
    double d = returns[i] - rf;
    if (d < 0) sum_sq += d * d;
  }
  double downside_dev = sqrt(sum_sq / n);
  if (downside_dev < 1e-15) return 0;
  return (ret - rf) / downside_dev;
}

/* maximum drawdown */
double max_drawdown(const double *equity, int n) {
  double peak = equity[0], mdd = 0;
  for (int i = 1; i < n; i++) {
    if (equity[i] > peak) peak = equity[i];
    double dd = (peak - equity[i]) / peak;
    if (dd > mdd) mdd = dd;
  }
  return mdd;
}

/* value at risk historical method */
double var_historical(double *returns, int n, double confidence) {
  bubble_sort(returns, n);
  int idx = (int)((1.0 - confidence) * n);
  if (idx < 0) idx = 0;
  if (idx >= n) idx = n - 1;
  return -returns[idx];
}

/* EWMA volatility */
double ewma_volatility(const double *returns, int n, double lambda) {
  double var = 0;
  for (int i = 0; i < n; i++) {
    var = lambda * var + (1.0 - lambda) * returns[i] * returns[i];
  }
  return sqrt(var);
}

/* simple bond price from yield */
double bond_price(double face, double coupon_rate, double yield, int periods) {
  double price = 0;
  double coupon = face * coupon_rate;
  for (int t = 1; t <= periods; t++) price += coupon / pow(1.0 + yield, t);
  price += face / pow(1.0 + yield, periods);
  return price;
}

/* duration of a bond */
double bond_duration(double face, double coupon_rate, double yield, int periods) {
  double price = bond_price(face, coupon_rate, yield, periods);
  double coupon = face * coupon_rate;
  double dur = 0;
  for (int t = 1; t <= periods; t++) dur += t * coupon / pow(1.0 + yield, t);
  dur += periods * face / pow(1.0 + yield, periods);
  return dur / price;
}

/* Kelly criterion optimal bet fraction */
double kelly_fraction(double win_prob, double win_ratio, double loss_ratio) {
  return (win_prob * win_ratio - (1.0 - win_prob) * loss_ratio) / win_ratio;
}

/* simple Monte Carlo option pricing */
double mc_option_price(double S, double K, double T, double r, double sigma, int sims) {
  double payoff_sum = 0;
  for (int i = 0; i < sims; i++) {
    double z0, z1;
    box_muller(&z0, &z1);
    double ST = S * exp((r - 0.5 * sigma * sigma) * T + sigma * sqrt(T) * z0);
    double payoff = ST - K;
    if (payoff < 0) payoff = 0;
    payoff_sum += payoff;
  }
  return exp(-r * T) * payoff_sum / sims;
}

/* GARCH(1,1) volatility step */
double garch_step(double omega, double alpha, double beta, double prev_var, double prev_ret) {
  return omega + alpha * prev_ret * prev_ret + beta * prev_var;
}

/* Hurst exponent estimate via R/S analysis */
double hurst_exponent(const double *x, int n) {
  double m = mean(x, n);
  double *y = (double *)malloc(n * sizeof(double));
  y[0] = x[0] - m;
  for (int i = 1; i < n; i++) y[i] = y[i - 1] + (x[i] - m);
  double R = max_val(y, n) - min_val(y, n);
  double S = stddev(x, n);
  free(y);
  if (S < 1e-15) return 0.5;
  return log(R / S) / log((double)n);
}

/* autocorrelation at lag k */
double autocorrelation(const double *x, int n, int k) {
  double m = mean(x, n), num = 0, den = 0;
  for (int i = 0; i < n; i++) den += (x[i] - m) * (x[i] - m);
  for (int i = 0; i < n - k; i++) num += (x[i] - m) * (x[i + k] - m);
  if (den < 1e-15) return 0;
  return num / den;
}

/* simple linear congruential generator */
unsigned int lcg_next(unsigned int seed) {
  return seed * 1103515245u + 12345u;
}

/* reservoir sampling select k from n */
void reservoir_sample(int *out, int k, int n) {
  for (int i = 0; i < k; i++) out[i] = i;
  for (int i = k; i < n; i++) {
    int j = rand() % (i + 1);
    if (j < k) out[j] = i;
  }
}

/* entropy of a discrete distribution */
double entropy(const double *p, int n) {
  double h = 0;
  for (int i = 0; i < n; i++)
    if (p[i] > 1e-15) h -= p[i] * log(p[i]);
  return h;
}

/* KL divergence */
double kl_divergence(const double *p, const double *q, int n) {
  double d = 0;
  for (int i = 0; i < n; i++)
    if (p[i] > 1e-15 && q[i] > 1e-15) d += p[i] * log(p[i] / q[i]);
  return d;
}

/* Jensen-Shannon divergence */
double js_divergence(const double *p, const double *q, int n) {
  double m[64];
  for (int i = 0; i < n; i++) m[i] = 0.5 * (p[i] + q[i]);
  return 0.5 * kl_divergence(p, m, n) + 0.5 * kl_divergence(q, m, n);
}

/* chi-squared test statistic */
double chi_squared(const double *observed, const double *expected, int n) {
  double s = 0;
  for (int i = 0; i < n; i++) {
    double d = observed[i] - expected[i];
    if (expected[i] > 1e-15) s += d * d / expected[i];
  }
  return s;
}

/* Welford online variance */
void welford_update(double *mean, double *M2, int *count, double x) {
  (*count)++;
  double delta = x - *mean;
  *mean += delta / *count;
  double delta2 = x - *mean;
  *M2 += delta * delta2;
}

/* Spearman rank correlation helper: compute ranks */
void compute_ranks(double *ranks, const double *x, int n) {
  for (int i = 0; i < n; i++) {
    ranks[i] = 1;
    for (int j = 0; j < n; j++)
      if (x[j] < x[i] || (x[j] == x[i] && j < i)) ranks[i]++;
  }
}
