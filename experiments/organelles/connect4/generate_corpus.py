#!/usr/bin/env python3
# Copyright (c) 2026 Ajay Soni (ajay.soni@enjector.com), Enjector Software Ltd.
# MIT License — see LICENSE file for details.
"""
Generate training corpora for the Connect-4 multi-organelle demo.

Creates 2 corpus files:
  - connect4_planner.txt  (board + empties → plan)
  - connect4_player.txt   (board + context → column 0-6)

DESIGN PRINCIPLE: Keep outputs SHORT and DETERMINISTIC.
  - Player outputs just a column: "0", "1", ..., "6"
  - Planner outputs "todo=move,check,move,check"
  - Judge is deterministic (C code) — no corpus needed.

Uses alpha-beta minimax with depth-limited evaluation to find optimal
moves. Positions are generated by self-play to cover realistic game trees.

Connect-4 board: 7 columns × 6 rows.
  - Board string: 42 chars, row-major (top-to-bottom, left-to-right)
  - Characters: '.' (empty), 'X' (player 1, us), 'O' (player 2, opponent)
  - Column numbering: 0-6 (leftmost to rightmost)
"""

import random
import sys

ROWS = 6
COLS = 7
EMPTY = '.'
X = 'X'
O = 'O'


# ---- Board Operations ----

def make_board():
    return [EMPTY] * (ROWS * COLS)

def board_to_str(board):
    return ''.join(board)

def cell(r, c):
    return r * COLS + c

def get_valid_columns(board):
    """Return list of columns that are not full (top row is empty)."""
    return [c for c in range(COLS) if board[cell(0, c)] == EMPTY]

def drop_piece(board, col, player):
    """Drop a piece into column. Returns new board and the row it landed on, or None."""
    for r in range(ROWS - 1, -1, -1):
        if board[cell(r, col)] == EMPTY:
            new_board = list(board)
            new_board[cell(r, col)] = player
            return new_board, r
    return None, -1

def count_pieces(board):
    return sum(1 for c in board if c != EMPTY)


# ---- Win Detection ----

DIRECTIONS = [(0, 1), (1, 0), (1, 1), (1, -1)]  # horiz, vert, diag-down, diag-up

def check_winner(board):
    """Return 'X', 'O', or None."""
    for r in range(ROWS):
        for c in range(COLS):
            if board[cell(r, c)] == EMPTY:
                continue
            player = board[cell(r, c)]
            for dr, dc in DIRECTIONS:
                # Check if 4 in a row starting from (r, c) in direction (dr, dc)
                er, ec = r + 3 * dr, c + 3 * dc
                if 0 <= er < ROWS and 0 <= ec < COLS:
                    if all(board[cell(r + i*dr, c + i*dc)] == player for i in range(4)):
                        return player
    return None

def is_terminal(board):
    return check_winner(board) is not None or len(get_valid_columns(board)) == 0


# ---- Evaluation Function ----

def evaluate_window(window, player):
    """Score a window of 4 cells."""
    opp = O if player == X else X
    score = 0
    p_count = window.count(player)
    o_count = window.count(opp)
    e_count = window.count(EMPTY)

    if p_count == 4:
        score += 100000
    elif p_count == 3 and e_count == 1:
        score += 50
    elif p_count == 2 and e_count == 2:
        score += 5
    if o_count == 3 and e_count == 1:
        score -= 80  # prioritise blocking opponent threats
    return score

def evaluate_board(board, player):
    """Heuristic evaluation for non-terminal positions."""
    score = 0

    # Centre column preference (columns closer to centre are more valuable)
    centre_col = COLS // 2
    centre_count = sum(1 for r in range(ROWS) if board[cell(r, centre_col)] == player)
    score += centre_count * 6

    # Score all possible windows of 4
    for r in range(ROWS):
        for c in range(COLS):
            for dr, dc in DIRECTIONS:
                er, ec = r + 3*dr, c + 3*dc
                if 0 <= er < ROWS and 0 <= ec < COLS:
                    window = [board[cell(r + i*dr, c + i*dc)] for i in range(4)]
                    score += evaluate_window(window, player)

    return score


# ---- Alpha-Beta Minimax ----

MAX_DEPTH = 4  # depth limit for alpha-beta search (4 = fast, 6 = slow)

def alphabeta(board, depth, alpha, beta, maximising, move_player):
    """Alpha-beta minimax. Returns (score, best_col)."""
    winner = check_winner(board)
    if winner == X:
        return (100000 + depth, -1)  # prefer faster wins
    if winner == O:
        return (-100000 - depth, -1)
    valid_cols = get_valid_columns(board)
    if not valid_cols:
        return (0, -1)  # draw
    if depth == 0:
        return (evaluate_board(board, X), -1)

    # Order columns: centre first for better pruning
    ordered = sorted(valid_cols, key=lambda c: abs(c - COLS // 2))

    if maximising:
        best_score = -999999
        best_col = ordered[0]
        for col in ordered:
            new_board, _ = drop_piece(board, col, X)
            if new_board is None:
                continue
            score, _ = alphabeta(new_board, depth - 1, alpha, beta, False, O)
            if score > best_score:
                best_score = score
                best_col = col
            alpha = max(alpha, score)
            if alpha >= beta:
                break
        return (best_score, best_col)
    else:
        best_score = 999999
        best_col = ordered[0]
        for col in ordered:
            new_board, _ = drop_piece(board, col, O)
            if new_board is None:
                continue
            score, _ = alphabeta(new_board, depth - 1, alpha, beta, True, X)
            if score < best_score:
                best_score = score
                best_col = col
            beta = min(beta, score)
            if alpha >= beta:
                break
        return (best_score, best_col)

def rank_columns(board, player):
    """Return all valid columns ranked by score for the given player."""
    valid_cols = get_valid_columns(board)
    is_max = (player == X)
    scored = []
    for col in valid_cols:
        new_board, _ = drop_piece(board, col, player)
        if new_board is None:
            continue
        score, _ = alphabeta(new_board, MAX_DEPTH - 1, -999999, 999999, not is_max, O if player == X else X)
        scored.append((score, col))
    scored.sort(key=lambda x: x[0], reverse=is_max)
    return scored


# ---- Mirror Symmetry ----

def mirror_board(board):
    """Horizontally mirror the board."""
    mirrored = list(board)
    for r in range(ROWS):
        for c in range(COLS):
            mirrored[cell(r, COLS - 1 - c)] = board[cell(r, c)]
    return mirrored

def mirror_col(col):
    return COLS - 1 - col


# ---- Position Generation via Self-Play ----

def generate_positions(num_games=500, max_ply=20):
    """Generate training positions from self-play games.

    Plays games with a mix of:
    - Random vs random (diverse positions)
    - Minimax vs random (optimal X play)
    - Random X moves for first few plies then minimax (mid-game positions)
    """
    positions = {}  # board_str -> (board, optimal_col_for_X)

    for game_idx in range(num_games):
        board = make_board()
        turn = X

        # Vary strategy per game
        strategy = game_idx % 4
        random_plies = random.randint(2, 8) if strategy >= 2 else 0

        for ply in range(max_ply):
            if is_terminal(board):
                break

            valid_cols = get_valid_columns(board)
            if not valid_cols:
                break

            if turn == X:
                # Always record optimal move for X using alpha-beta
                board_str = board_to_str(board)
                if board_str not in positions:
                    _, best_col = alphabeta(board, MAX_DEPTH, -999999, 999999, True, X)
                    if best_col >= 0:
                        positions[board_str] = (list(board), best_col)

                # Decide how X actually plays this game (for position diversity)
                if strategy == 0:
                    # Random play (generates losing positions too)
                    col = random.choice(valid_cols)
                elif strategy == 1:
                    # Optimal play
                    _, col = alphabeta(board, MAX_DEPTH, -999999, 999999, True, X)
                elif ply < random_plies:
                    # Random opening then optimal
                    col = random.choice(valid_cols)
                else:
                    _, col = alphabeta(board, MAX_DEPTH, -999999, 999999, True, X)

            else:  # O's turn
                if strategy == 1:
                    # O plays optimally too (for defensive training data)
                    _, col = alphabeta(board, MAX_DEPTH, -999999, 999999, False, O)
                else:
                    # Random opponent
                    col = random.choice(valid_cols)

            board, _ = drop_piece(board, col, turn)
            if board is None:
                break
            turn = O if turn == X else X

        if (game_idx + 1) % 100 == 0:
            print(f"  Self-play: {game_idx + 1}/{num_games} games, {len(positions)} positions", file=sys.stderr)

    return positions


# ---- Corpus Generation ----

def generate_planner_corpus(positions):
    """Planner: board|empties → plan."""
    entries = []
    seen = set()

    for board_str, (board, optimal_col) in positions.items():
        empties = ROWS * COLS - count_pieces(board)

        if empties <= 4:
            plan = "move,check"
        elif empties <= 14:
            plan = "move,check,move,check"
        elif empties <= 28:
            plan = "move,check,move,check,move,check"
        else:
            plan = "move,check,move,check,move,check,move,check"

        prompt = f"board={board_str}|empties={empties}"
        if prompt not in seen:
            entries.append(f"{prompt}\ntodo={plan}")
            seen.add(prompt)

        # Stalled variant
        if empties >= 8:
            prompt_s = f"board={board_str}|empties={empties}|stalled"
            if prompt_s not in seen:
                entries.append(f"{prompt_s}\ntodo=move,check,move,check")
                seen.add(prompt_s)

    # Add mirrored variants
    mirrored_entries = []
    mirrored_seen = set()
    for board_str, (board, _) in positions.items():
        m_board = mirror_board(board)
        m_str = board_to_str(m_board)
        empties = ROWS * COLS - count_pieces(board)

        if empties <= 4:
            plan = "move,check"
        elif empties <= 14:
            plan = "move,check,move,check"
        elif empties <= 28:
            plan = "move,check,move,check,move,check"
        else:
            plan = "move,check,move,check,move,check,move,check"

        prompt = f"board={m_str}|empties={empties}"
        if prompt not in seen and prompt not in mirrored_seen:
            mirrored_entries.append(f"{prompt}\ntodo={plan}")
            mirrored_seen.add(prompt)

    entries.extend(mirrored_entries)
    return entries


def generate_player_corpus(positions):
    """Player: board + valid + context → column number (just the number 0-6).

    Variants:
    1. Base: board|valid=... → optimal_col
    2. Blocked: board|valid=...|blocked=X → next-best col
    """
    entries = []
    seen = set()

    count = 0
    total = len(positions)
    for board_str, (board, optimal_col) in positions.items():
        count += 1
        if count % 500 == 0:
            print(f"  Player corpus: {count}/{total} positions", file=sys.stderr)

        valid_cols = get_valid_columns(board)
        valid_str = ','.join(str(c) for c in valid_cols)

        # ---- Type 1: Base (no blocked) ----
        prompt = f"board={board_str}|valid={valid_str}"
        if prompt not in seen:
            entries.append(f"{prompt}\n{optimal_col}")
            seen.add(prompt)

        # ---- Type 2: Simple blocked variants (no expensive rank_columns) ----

        # Block non-optimal columns → still output optimal
        for col in valid_cols:
            if col == optimal_col:
                continue
            remaining_valid = [c for c in valid_cols if c != col]
            remaining_str = ','.join(str(c) for c in remaining_valid)
            prompt_b = f"board={board_str}|valid={remaining_str}|blocked={col}"
            if prompt_b not in seen:
                entries.append(f"{prompt_b}\n{optimal_col}")
                seen.add(prompt_b)

        # Block optimal → pick centre-biased fallback from remaining valid cols
        remaining = [c for c in valid_cols if c != optimal_col]
        if remaining:
            # Prefer centre columns as fallback
            fallback = min(remaining, key=lambda c: abs(c - COLS // 2))
            remaining_str = ','.join(str(c) for c in remaining)
            prompt_b = f"board={board_str}|valid={remaining_str}|blocked={optimal_col}"
            if prompt_b not in seen:
                entries.append(f"{prompt_b}\n{fallback}")
                seen.add(prompt_b)

    # Add mirrored variants
    mirrored_entries = []
    mirrored_seen = set()
    for board_str, (board, optimal_col) in positions.items():
        m_board = mirror_board(board)
        m_str = board_to_str(m_board)
        m_col = mirror_col(optimal_col)
        m_valid = [mirror_col(c) for c in get_valid_columns(board)]
        m_valid.sort()
        m_valid_str = ','.join(str(c) for c in m_valid)

        prompt = f"board={m_str}|valid={m_valid_str}"
        if prompt not in seen and prompt not in mirrored_seen:
            mirrored_entries.append(f"{prompt}\n{m_col}")
            mirrored_seen.add(prompt)

    entries.extend(mirrored_entries)
    return entries


# ---- Main ----

def main():
    print("Generating Connect-4 training corpora (alpha-beta minimax)...\n", file=sys.stderr)

    # Generate positions from self-play
    print("Phase 1: Position generation via self-play...", file=sys.stderr)
    positions = generate_positions(num_games=500, max_ply=20)
    print(f"\nTotal unique X-turn positions: {len(positions)}\n", file=sys.stderr)

    # Generate corpora
    print("Phase 2: Generating planner corpus...", file=sys.stderr)
    planner_entries = generate_planner_corpus(positions)
    print(f"  Planner: {len(planner_entries)} entries", file=sys.stderr)

    print("Phase 3: Generating player corpus (this takes a while)...", file=sys.stderr)
    player_entries = generate_player_corpus(positions)
    print(f"  Player: {len(player_entries)} entries", file=sys.stderr)

    # Write files
    print("\nWriting corpus files:", file=sys.stderr)

    for name, entries in [
        ("connect4_planner.txt", planner_entries),
        ("connect4_player.txt", player_entries),
    ]:
        content = "\n\n".join(entries) + "\n"
        with open(name, "w") as f:
            f.write(content)

        doc_lengths = [len(e) for e in entries]
        max_len = max(doc_lengths) if doc_lengths else 0

        print(f"  {name}: {len(entries)} entries, {len(content)} bytes, "
              f"max_doc={max_len} chars", file=sys.stderr)

    print("\nDone! Corpora ready for MicroGPT-C training.", file=sys.stderr)


if __name__ == "__main__":
    main()
